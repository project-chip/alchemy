package zapdiff

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const alchemyComment = "XML generated by Alchemy; DO NOT EDIT."

func isAlchemyFile(p string) bool {
	f, err := os.Open(p)
	if err != nil {
		return false
	}
	defer f.Close()

	// Read first 30 lines to find the comment
	s := bufio.NewScanner(f)
	for i := 0; i < 30 && s.Scan(); i++ {
		if strings.Contains(s.Text(), alchemyComment) {
			return true
		}
	}
	return false
}

func excludeNonAlchemyFiles(ff []string) (out []string) {
	out = make([]string, 0)
	for _, p := range ff {
		if isAlchemyFile(p) {
			out = append(out, p)
		}
	}
	return out
}

func getFilePairs(ff1, ff2 []string) (common []filePair) {
	common = make([]filePair, 0)
	for _, p1 := range ff1 {
		base1 := filepath.Base(p1)
		for _, p2 := range ff2 {
			if filepath.Base(p2) == base1 {
				common = append(common, filePair{p1: p1, p2: p2})
				break
			}
		}
	}
	return
}

func fileListDiff(ff1, ff2 []string, n1, n2 string) (mm []XmlMismatch) {
	mm = make([]XmlMismatch, 0)

	for _, p1 := range ff1 {
		b1 := filepath.Base(p1)
		found := false
		for _, p2 := range ff2 {
			if filepath.Base(p2) == b1 {
				found = true
				break
			}
		}
		if !found {
			m := XmlMismatch{
				Path:      b1,
				Type:      XmlMismatchNewFile,
				Details:   fmt.Sprintf("Only found in %s, or the file is not alchemy-generated.", n1),
				ElementID: b1,
			}
			mm = append(mm, m)
		}
	}

	for _, p2 := range ff2 {
		b2 := filepath.Base(p2)
		found := false
		for _, p1 := range ff1 {
			if filepath.Base(p1) == b2 {
				found = true
				break
			}
		}
		if !found {
			m := XmlMismatch{
				Path:      b2,
				Type:      XmlMismatchNewFile,
				Details:   fmt.Sprintf("Only found in %s, or the file is not alchemy-generated.", n2),
				ElementID: b2,
			}
			mm = append(mm, m)
		}
	}

	return
}
