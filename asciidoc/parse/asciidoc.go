// Code generated by pigeon; DO NOT EDIT.

package parse

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/hasty/alchemy/asciidoc"
)

var g = &grammar{
	rules: []*rule{
		{
			name: "Document",
			pos:  position{line: 14, col: 1, offset: 92},
			expr: &actionExpr{
				pos: position{line: 14, col: 12, offset: 103},
				run: (*parser).callonDocument1,
				expr: &seqExpr{
					pos: position{line: 14, col: 12, offset: 103},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 14, col: 12, offset: 103},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 14, col: 20, offset: 111},
								expr: &ruleRefExpr{
									pos:  position{line: 14, col: 21, offset: 112},
									name: "Element",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 14, col: 31, offset: 122},
							name: "EndOfFile",
						},
					},
				},
			},
		},
		{
			name: "Element",
			pos:  position{line: 19, col: 1, offset: 240},
			expr: &actionExpr{
				pos: position{line: 19, col: 11, offset: 250},
				run: (*parser).callonElement1,
				expr: &labeledExpr{
					pos:   position{line: 19, col: 11, offset: 250},
					label: "element",
					expr: &choiceExpr{
						pos: position{line: 19, col: 20, offset: 259},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 19, col: 20, offset: 259},
								name: "BlockElement",
							},
							&ruleRefExpr{
								pos:  position{line: 19, col: 35, offset: 274},
								name: "InlineElements",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElement",
			pos:  position{line: 27, col: 1, offset: 385},
			expr: &actionExpr{
				pos: position{line: 27, col: 16, offset: 400},
				run: (*parser).callonBlockElement1,
				expr: &seqExpr{
					pos: position{line: 27, col: 16, offset: 400},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 27, col: 16, offset: 400},
							name: "BeginningOfLine",
						},
						&labeledExpr{
							pos:   position{line: 27, col: 32, offset: 416},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 27, col: 41, offset: 425},
								name: "BlockElements",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 27, col: 56, offset: 440},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 28, col: 1, offset: 450},
							run: (*parser).callonBlockElement7,
						},
					},
				},
			},
		},
		{
			name: "BlockElements",
			pos:  position{line: 36, col: 1, offset: 680},
			expr: &actionExpr{
				pos: position{line: 36, col: 17, offset: 696},
				run: (*parser).callonBlockElements1,
				expr: &labeledExpr{
					pos:   position{line: 36, col: 17, offset: 696},
					label: "blockElement",
					expr: &choiceExpr{
						pos: position{line: 37, col: 5, offset: 716},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 37, col: 5, offset: 716},
								name: "BlockEmptyLine",
							},
							&ruleRefExpr{
								pos:  position{line: 38, col: 5, offset: 737},
								name: "AttributableBlocks",
							},
							&ruleRefExpr{
								pos:  position{line: 39, col: 5, offset: 762},
								name: "Table",
							},
							&ruleRefExpr{
								pos:  position{line: 41, col: 5, offset: 797},
								name: "NakedBlocks",
							},
							&ruleRefExpr{
								pos:  position{line: 42, col: 5, offset: 815},
								name: "NakedBlockAttributes",
							},
						},
					},
				},
			},
		},
		{
			name: "NakedBlocks",
			pos:  position{line: 48, col: 1, offset: 938},
			expr: &actionExpr{
				pos: position{line: 48, col: 15, offset: 952},
				run: (*parser).callonNakedBlocks1,
				expr: &labeledExpr{
					pos:   position{line: 48, col: 15, offset: 952},
					label: "block",
					expr: &choiceExpr{
						pos: position{line: 49, col: 5, offset: 965},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 49, col: 5, offset: 965},
								name: "MultiLineComment",
							},
							&ruleRefExpr{
								pos:  position{line: 50, col: 5, offset: 989},
								name: "SingleLineComment",
							},
							&ruleRefExpr{
								pos:  position{line: 51, col: 5, offset: 1013},
								name: "AttributeEntry",
							},
							&ruleRefExpr{
								pos:  position{line: 52, col: 5, offset: 1035},
								name: "AttributeReset",
							},
							&ruleRefExpr{
								pos:  position{line: 53, col: 5, offset: 1056},
								name: "IfDef",
							},
							&ruleRefExpr{
								pos:  position{line: 54, col: 5, offset: 1068},
								name: "IfNDef",
							},
							&ruleRefExpr{
								pos:  position{line: 55, col: 5, offset: 1082},
								name: "IfEval",
							},
							&ruleRefExpr{
								pos:  position{line: 56, col: 5, offset: 1095},
								name: "EndIfDef",
							},
							&ruleRefExpr{
								pos:  position{line: 57, col: 5, offset: 1110},
								name: "FileInclude",
							},
							&ruleRefExpr{
								pos:  position{line: 58, col: 5, offset: 1128},
								name: "DescriptionListItem",
							},
							&ruleRefExpr{
								pos:  position{line: 59, col: 5, offset: 1154},
								name: "ListContinuation",
							},
							&ruleRefExpr{
								pos:  position{line: 60, col: 5, offset: 1177},
								name: "NewLine",
							},
						},
					},
				},
			},
		},
		{
			name: "AttributableBlocks",
			pos:  position{line: 66, col: 1, offset: 1298},
			expr: &actionExpr{
				pos: position{line: 66, col: 22, offset: 1319},
				run: (*parser).callonAttributableBlocks1,
				expr: &seqExpr{
					pos: position{line: 66, col: 22, offset: 1319},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 66, col: 22, offset: 1319},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 66, col: 33, offset: 1330},
								expr: &ruleRefExpr{
									pos:  position{line: 66, col: 34, offset: 1331},
									name: "BlockElementAttributes",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 66, col: 59, offset: 1356},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 67, col: 5, offset: 1371},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 67, col: 5, offset: 1371},
										name: "Listing",
									},
									&ruleRefExpr{
										pos:  position{line: 68, col: 5, offset: 1386},
										name: "Open",
									},
									&ruleRefExpr{
										pos:  position{line: 69, col: 5, offset: 1397},
										name: "Example",
									},
									&ruleRefExpr{
										pos:  position{line: 70, col: 5, offset: 1411},
										name: "Sidebar",
									},
									&ruleRefExpr{
										pos:  position{line: 71, col: 5, offset: 1425},
										name: "Quote",
									},
									&ruleRefExpr{
										pos:  position{line: 72, col: 5, offset: 1437},
										name: "Literal",
									},
									&ruleRefExpr{
										pos:  position{line: 73, col: 5, offset: 1451},
										name: "Stem",
									},
									&ruleRefExpr{
										pos:  position{line: 74, col: 5, offset: 1462},
										name: "Section",
									},
									&ruleRefExpr{
										pos:  position{line: 75, col: 5, offset: 1477},
										name: "ThematicBreak",
									},
									&ruleRefExpr{
										pos:  position{line: 76, col: 5, offset: 1497},
										name: "PageBreak",
									},
									&ruleRefExpr{
										pos:  position{line: 77, col: 5, offset: 1513},
										name: "BlockImage",
									},
									&ruleRefExpr{
										pos:  position{line: 78, col: 5, offset: 1530},
										name: "OrderedListItem",
									},
									&ruleRefExpr{
										pos:  position{line: 79, col: 5, offset: 1553},
										name: "UnorderedListItem",
									},
									&ruleRefExpr{
										pos:  position{line: 80, col: 5, offset: 1578},
										name: "DescriptionListItem",
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 81, col: 9, offset: 1607},
							run: (*parser).callonAttributableBlocks22,
						},
					},
				},
			},
		},
		{
			name: "BlockAttributes",
			pos:  position{line: 96, col: 1, offset: 2324},
			expr: &actionExpr{
				pos: position{line: 96, col: 19, offset: 2342},
				run: (*parser).callonBlockAttributes1,
				expr: &labeledExpr{
					pos:   position{line: 96, col: 19, offset: 2342},
					label: "attribute",
					expr: &choiceExpr{
						pos: position{line: 97, col: 5, offset: 2358},
						alternatives: []any{
							&actionExpr{
								pos: position{line: 97, col: 6, offset: 2359},
								run: (*parser).callonBlockAttributes4,
								expr: &labeledExpr{
									pos:   position{line: 97, col: 6, offset: 2359},
									label: "anchor",
									expr: &ruleRefExpr{
										pos:  position{line: 97, col: 14, offset: 2367},
										name: "AnchorAttribute",
									},
								},
							},
							&actionExpr{
								pos: position{line: 100, col: 8, offset: 2428},
								run: (*parser).callonBlockAttributes7,
								expr: &labeledExpr{
									pos:   position{line: 100, col: 8, offset: 2428},
									label: "title",
									expr: &ruleRefExpr{
										pos:  position{line: 100, col: 15, offset: 2435},
										name: "BlockTitle",
									},
								},
							},
							&actionExpr{
								pos: position{line: 103, col: 8, offset: 2490},
								run: (*parser).callonBlockAttributes10,
								expr: &labeledExpr{
									pos:   position{line: 103, col: 8, offset: 2490},
									label: "attributes",
									expr: &ruleRefExpr{
										pos:  position{line: 103, col: 20, offset: 2502},
										name: "Attributes",
									},
								},
							},
							&actionExpr{
								pos: position{line: 106, col: 8, offset: 2563},
								run: (*parser).callonBlockAttributes13,
								expr: &labeledExpr{
									pos:   position{line: 106, col: 8, offset: 2563},
									label: "attributes",
									expr: &ruleRefExpr{
										pos:  position{line: 106, col: 20, offset: 2575},
										name: "ShorthandAttributes",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTitle",
			pos:  position{line: 114, col: 1, offset: 2738},
			expr: &actionExpr{
				pos: position{line: 114, col: 14, offset: 2751},
				run: (*parser).callonBlockTitle1,
				expr: &seqExpr{
					pos: position{line: 114, col: 14, offset: 2751},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 114, col: 14, offset: 2751},
							name: "BeginningOfLine",
						},
						&litMatcher{
							pos:        position{line: 114, col: 30, offset: 2767},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&notExpr{
							pos: position{line: 114, col: 34, offset: 2771},
							expr: &charClassMatcher{
								pos:             position{line: 114, col: 35, offset: 2772},
								val:             "[ .]",
								chars:           []rune{' ', '.'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
						},
						&labeledExpr{
							pos:   position{line: 114, col: 40, offset: 2777},
							label: "content",
							expr: &ruleRefExpr{
								pos:  position{line: 114, col: 49, offset: 2786},
								name: "BlockTitleContent",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTitleContent",
			pos:  position{line: 123, col: 1, offset: 3024},
			expr: &actionExpr{
				pos: position{line: 123, col: 21, offset: 3044},
				run: (*parser).callonBlockTitleContent1,
				expr: &labeledExpr{
					pos:   position{line: 123, col: 21, offset: 3044},
					label: "content",
					expr: &oneOrMoreExpr{
						pos: position{line: 123, col: 29, offset: 3052},
						expr: &choiceExpr{
							pos: position{line: 123, col: 30, offset: 3053},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 123, col: 30, offset: 3053},
									name: "NakedInlineText",
								},
								&ruleRefExpr{
									pos:  position{line: 123, col: 48, offset: 3071},
									name: "Alphanumeric",
								},
								&ruleRefExpr{
									pos:  position{line: 123, col: 63, offset: 3086},
									name: "_",
								},
								&ruleRefExpr{
									pos:  position{line: 123, col: 67, offset: 3090},
									name: "Punctuation",
								},
								&ruleRefExpr{
									pos:  position{line: 123, col: 81, offset: 3104},
									name: "AttributeReference",
								},
								&ruleRefExpr{
									pos:  position{line: 123, col: 102, offset: 3125},
									name: "CharacterClassInline",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockEmptyLine",
			pos:  position{line: 127, col: 1, offset: 3192},
			expr: &actionExpr{
				pos: position{line: 127, col: 18, offset: 3209},
				run: (*parser).callonBlockEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 127, col: 18, offset: 3209},
					exprs: []any{
						&zeroOrMoreExpr{
							pos: position{line: 127, col: 18, offset: 3209},
							expr: &ruleRefExpr{
								pos:  position{line: 127, col: 18, offset: 3209},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 127, col: 21, offset: 3212},
							expr: &ruleRefExpr{
								pos:  position{line: 127, col: 22, offset: 3213},
								name: "NewLine",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElementAttribute",
			pos:  position{line: 132, col: 1, offset: 3391},
			expr: &actionExpr{
				pos: position{line: 132, col: 25, offset: 3415},
				run: (*parser).callonBlockElementAttribute1,
				expr: &seqExpr{
					pos: position{line: 132, col: 25, offset: 3415},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 132, col: 25, offset: 3415},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 132, col: 37, offset: 3427},
								name: "BlockAttributes",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 132, col: 54, offset: 3444},
							expr: &ruleRefExpr{
								pos:  position{line: 132, col: 54, offset: 3444},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 132, col: 57, offset: 3447},
							expr: &ruleRefExpr{
								pos:  position{line: 132, col: 58, offset: 3448},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElementAdditionalAttribute",
			pos:  position{line: 137, col: 1, offset: 3571},
			expr: &actionExpr{
				pos: position{line: 137, col: 35, offset: 3605},
				run: (*parser).callonBlockElementAdditionalAttribute1,
				expr: &seqExpr{
					pos: position{line: 137, col: 35, offset: 3605},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 137, col: 35, offset: 3605},
							name: "NewLine",
						},
						&labeledExpr{
							pos:   position{line: 137, col: 43, offset: 3613},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 137, col: 55, offset: 3625},
								name: "BlockAttributes",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 137, col: 72, offset: 3642},
							expr: &ruleRefExpr{
								pos:  position{line: 137, col: 72, offset: 3642},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 137, col: 75, offset: 3645},
							expr: &ruleRefExpr{
								pos:  position{line: 137, col: 76, offset: 3646},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElementAttributes",
			pos:  position{line: 142, col: 1, offset: 3780},
			expr: &actionExpr{
				pos: position{line: 142, col: 26, offset: 3805},
				run: (*parser).callonBlockElementAttributes1,
				expr: &seqExpr{
					pos: position{line: 142, col: 26, offset: 3805},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 142, col: 26, offset: 3805},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:  position{line: 142, col: 37, offset: 3816},
								name: "BlockElementAttribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 142, col: 60, offset: 3839},
							label: "additionalAttributes",
							expr: &zeroOrMoreExpr{
								pos: position{line: 142, col: 81, offset: 3860},
								expr: &ruleRefExpr{
									pos:  position{line: 142, col: 82, offset: 3861},
									name: "BlockElementAdditionalAttribute",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 142, col: 116, offset: 3895},
							name: "EndOfLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 142, col: 126, offset: 3905},
							expr: &ruleRefExpr{
								pos:  position{line: 142, col: 126, offset: 3905},
								name: "EmptyLine",
							},
						},
					},
				},
			},
		},
		{
			name: "NakedBlockAttributes",
			pos:  position{line: 151, col: 1, offset: 4237},
			expr: &actionExpr{
				pos: position{line: 151, col: 24, offset: 4260},
				run: (*parser).callonNakedBlockAttributes1,
				expr: &seqExpr{
					pos: position{line: 151, col: 24, offset: 4260},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 151, col: 24, offset: 4260},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:  position{line: 151, col: 35, offset: 4271},
								name: "BlockElementAttribute",
							},
						},
						&labeledExpr{
							pos:   position{line: 151, col: 58, offset: 4294},
							label: "additionalAttributes",
							expr: &zeroOrMoreExpr{
								pos: position{line: 151, col: 79, offset: 4315},
								expr: &ruleRefExpr{
									pos:  position{line: 151, col: 80, offset: 4316},
									name: "BlockElementAdditionalAttribute",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockDelimiters",
			pos:  position{line: 164, col: 1, offset: 4734},
			expr: &actionExpr{
				pos: position{line: 165, col: 5, offset: 4757},
				run: (*parser).callonBlockDelimiters1,
				expr: &seqExpr{
					pos: position{line: 165, col: 5, offset: 4757},
					exprs: []any{
						&notExpr{
							pos: position{line: 165, col: 5, offset: 4757},
							expr: &ruleRefExpr{
								pos:  position{line: 165, col: 6, offset: 4758},
								name: "Alphanumeric",
							},
						},
						&labeledExpr{
							pos:   position{line: 166, col: 5, offset: 4775},
							label: "delimiter",
							expr: &choiceExpr{
								pos: position{line: 167, col: 9, offset: 4795},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 167, col: 9, offset: 4795},
										name: "MultiLineCommentForwardSlashes",
									},
									&ruleRefExpr{
										pos:  position{line: 168, col: 11, offset: 4836},
										name: "ExampleEquals",
									},
									&ruleRefExpr{
										pos:  position{line: 169, col: 11, offset: 4860},
										name: "FencedBackticks",
									},
									&ruleRefExpr{
										pos:  position{line: 170, col: 11, offset: 4886},
										name: "ListingHyphens",
									},
									&ruleRefExpr{
										pos:  position{line: 171, col: 11, offset: 4911},
										name: "LiteralDots",
									},
									&ruleRefExpr{
										pos:  position{line: 172, col: 11, offset: 4933},
										name: "StemPluses",
									},
									&ruleRefExpr{
										pos:  position{line: 173, col: 11, offset: 4954},
										name: "QuoteUnderlines",
									},
									&ruleRefExpr{
										pos:  position{line: 174, col: 11, offset: 4980},
										name: "SidebarAsterisks",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Section",
			pos:  position{line: 178, col: 1, offset: 5045},
			expr: &actionExpr{
				pos: position{line: 178, col: 11, offset: 5055},
				run: (*parser).callonSection1,
				expr: &seqExpr{
					pos: position{line: 178, col: 11, offset: 5055},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 178, col: 11, offset: 5055},
							label: "level",
							expr: &actionExpr{
								pos: position{line: 178, col: 18, offset: 5062},
								run: (*parser).callonSection4,
								expr: &oneOrMoreExpr{
									pos: position{line: 178, col: 18, offset: 5062},
									expr: &charClassMatcher{
										pos:             position{line: 178, col: 18, offset: 5062},
										val:             "[=]",
										chars:           []rune{'='},
										basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
										ignoreCase:      false,
										inverted:        false,
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 182, col: 5, offset: 5184},
							run: (*parser).callonSection7,
						},
						&ruleRefExpr{
							pos:  position{line: 186, col: 5, offset: 5300},
							name: "__",
						},
						&labeledExpr{
							pos:   position{line: 186, col: 8, offset: 5303},
							label: "title",
							expr: &ruleRefExpr{
								pos:  position{line: 186, col: 15, offset: 5310},
								name: "SectionTitle",
							},
						},
						&andExpr{
							pos: position{line: 186, col: 29, offset: 5324},
							expr: &ruleRefExpr{
								pos:  position{line: 186, col: 30, offset: 5325},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "SectionTitle",
			pos:  position{line: 191, col: 1, offset: 5478},
			expr: &oneOrMoreExpr{
				pos: position{line: 191, col: 16, offset: 5493},
				expr: &ruleRefExpr{
					pos:  position{line: 191, col: 17, offset: 5494},
					name: "SectionTitleValue",
				},
			},
		},
		{
			name: "SectionTitleValue",
			pos:  position{line: 193, col: 1, offset: 5515},
			expr: &actionExpr{
				pos: position{line: 193, col: 21, offset: 5535},
				run: (*parser).callonSectionTitleValue1,
				expr: &seqExpr{
					pos: position{line: 193, col: 21, offset: 5535},
					exprs: []any{
						&notExpr{
							pos: position{line: 193, col: 21, offset: 5535},
							expr: &ruleRefExpr{
								pos:  position{line: 193, col: 22, offset: 5536},
								name: "EndOfLine",
							},
						},
						&labeledExpr{
							pos:   position{line: 193, col: 32, offset: 5546},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 194, col: 5, offset: 5560},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 194, col: 5, offset: 5560},
										name: "UnbrokenText",
									},
									&ruleRefExpr{
										pos:  position{line: 195, col: 7, offset: 5580},
										name: "__",
									},
									&ruleRefExpr{
										pos:  position{line: 196, col: 7, offset: 5590},
										name: "Apostrophe",
									},
									&ruleRefExpr{
										pos:  position{line: 197, col: 7, offset: 5608},
										name: "Punctuation",
									},
									&ruleRefExpr{
										pos:  position{line: 198, col: 7, offset: 5628},
										name: "FormattedText",
									},
									&ruleRefExpr{
										pos:  position{line: 200, col: 7, offset: 5673},
										name: "Link",
									},
									&ruleRefExpr{
										pos:  position{line: 201, col: 7, offset: 5685},
										name: "SpecialCharacter",
									},
									&ruleRefExpr{
										pos:  position{line: 202, col: 7, offset: 5709},
										name: "Icon",
									},
									&ruleRefExpr{
										pos:  position{line: 203, col: 7, offset: 5721},
										name: "AttributeReference",
									},
									&ruleRefExpr{
										pos:  position{line: 204, col: 7, offset: 5747},
										name: "Anchor",
									},
									&ruleRefExpr{
										pos:  position{line: 206, col: 7, offset: 5776},
										name: "CharacterClassInline",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeEntry",
			pos:  position{line: 211, col: 1, offset: 5828},
			expr: &actionExpr{
				pos: position{line: 211, col: 18, offset: 5845},
				run: (*parser).callonAttributeEntry1,
				expr: &seqExpr{
					pos: position{line: 211, col: 18, offset: 5845},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 211, col: 18, offset: 5845},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 211, col: 22, offset: 5849},
							label: "name",
							expr: &ruleRefExpr{
								pos:  position{line: 211, col: 28, offset: 5855},
								name: "AttributeEntryName",
							},
						},
						&litMatcher{
							pos:        position{line: 211, col: 48, offset: 5875},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 211, col: 52, offset: 5879},
							expr: &ruleRefExpr{
								pos:  position{line: 211, col: 52, offset: 5879},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 211, col: 55, offset: 5882},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 211, col: 62, offset: 5889},
								name: "AttributeEntryElements",
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeEntryName",
			pos:  position{line: 216, col: 1, offset: 6116},
			expr: &actionExpr{
				pos: position{line: 216, col: 22, offset: 6137},
				run: (*parser).callonAttributeEntryName1,
				expr: &seqExpr{
					pos: position{line: 216, col: 22, offset: 6137},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 216, col: 22, offset: 6137},
							name: "CharacterGroupWord",
						},
						&zeroOrMoreExpr{
							pos: position{line: 216, col: 41, offset: 6156},
							expr: &choiceExpr{
								pos: position{line: 216, col: 42, offset: 6157},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 216, col: 42, offset: 6157},
										name: "CharacterGroupWord",
									},
									&litMatcher{
										pos:        position{line: 216, col: 63, offset: 6178},
										val:        "-",
										ignoreCase: false,
										want:       "\"-\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeEntryElements",
			pos:  position{line: 221, col: 1, offset: 6295},
			expr: &actionExpr{
				pos: position{line: 221, col: 26, offset: 6320},
				run: (*parser).callonAttributeEntryElements1,
				expr: &labeledExpr{
					pos:   position{line: 221, col: 26, offset: 6320},
					label: "value",
					expr: &zeroOrMoreExpr{
						pos: position{line: 221, col: 32, offset: 6326},
						expr: &ruleRefExpr{
							pos:  position{line: 221, col: 32, offset: 6326},
							name: "AttributeEntryElement",
						},
					},
				},
			},
		},
		{
			name: "AttributeEntryElement",
			pos:  position{line: 226, col: 1, offset: 6520},
			expr: &choiceExpr{
				pos: position{line: 226, col: 26, offset: 6545},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 226, col: 26, offset: 6545},
						exprs: []any{
							&ruleRefExpr{
								pos:  position{line: 226, col: 26, offset: 6545},
								name: "LineBreak",
							},
							&ruleRefExpr{
								pos:  position{line: 226, col: 36, offset: 6555},
								name: "EndOfLine",
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 226, col: 48, offset: 6567},
						name: "CharacterClassInline",
					},
				},
			},
		},
		{
			name: "AttributeReset",
			pos:  position{line: 228, col: 1, offset: 6591},
			expr: &choiceExpr{
				pos: position{line: 228, col: 18, offset: 6608},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 228, col: 18, offset: 6608},
						run: (*parser).callonAttributeReset2,
						expr: &seqExpr{
							pos: position{line: 228, col: 18, offset: 6608},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 228, col: 18, offset: 6608},
									val:        ":!",
									ignoreCase: false,
									want:       "\":!\"",
								},
								&labeledExpr{
									pos:   position{line: 228, col: 23, offset: 6613},
									label: "name",
									expr: &ruleRefExpr{
										pos:  position{line: 228, col: 29, offset: 6619},
										name: "AttributeEntryName",
									},
								},
								&litMatcher{
									pos:        position{line: 228, col: 49, offset: 6639},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 228, col: 53, offset: 6643},
									expr: &ruleRefExpr{
										pos:  position{line: 228, col: 53, offset: 6643},
										name: "_",
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 230, col: 5, offset: 6718},
						run: (*parser).callonAttributeReset10,
						expr: &seqExpr{
							pos: position{line: 230, col: 5, offset: 6718},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 230, col: 5, offset: 6718},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&labeledExpr{
									pos:   position{line: 230, col: 9, offset: 6722},
									label: "name",
									expr: &ruleRefExpr{
										pos:  position{line: 230, col: 15, offset: 6728},
										name: "AttributeEntryName",
									},
								},
								&litMatcher{
									pos:        position{line: 230, col: 35, offset: 6748},
									val:        "!:",
									ignoreCase: false,
									want:       "\"!:\"",
								},
								&zeroOrMoreExpr{
									pos: position{line: 230, col: 40, offset: 6753},
									expr: &ruleRefExpr{
										pos:  position{line: 230, col: 40, offset: 6753},
										name: "_",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Attributes",
			pos:  position{line: 235, col: 1, offset: 6906},
			expr: &actionExpr{
				pos: position{line: 235, col: 14, offset: 6919},
				run: (*parser).callonAttributes1,
				expr: &seqExpr{
					pos: position{line: 235, col: 14, offset: 6919},
					exprs: []any{
						&notExpr{
							pos: position{line: 235, col: 14, offset: 6919},
							expr: &litMatcher{
								pos:        position{line: 235, col: 15, offset: 6920},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 235, col: 20, offset: 6925},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&notExpr{
							pos: position{line: 235, col: 24, offset: 6929},
							expr: &litMatcher{
								pos:        position{line: 235, col: 25, offset: 6930},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 235, col: 29, offset: 6934},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 235, col: 41, offset: 6946},
								name: "AttributeList",
							},
						},
						&litMatcher{
							pos:        position{line: 235, col: 56, offset: 6961},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "AttributeList",
			pos:  position{line: 241, col: 1, offset: 7064},
			expr: &actionExpr{
				pos: position{line: 241, col: 17, offset: 7080},
				run: (*parser).callonAttributeList1,
				expr: &labeledExpr{
					pos:   position{line: 241, col: 17, offset: 7080},
					label: "attributes",
					expr: &zeroOrMoreExpr{
						pos: position{line: 241, col: 28, offset: 7091},
						expr: &ruleRefExpr{
							pos:  position{line: 241, col: 29, offset: 7092},
							name: "AttributeListItem",
						},
					},
				},
			},
		},
		{
			name: "AttributeListItem",
			pos:  position{line: 246, col: 1, offset: 7242},
			expr: &actionExpr{
				pos: position{line: 246, col: 21, offset: 7262},
				run: (*parser).callonAttributeListItem1,
				expr: &seqExpr{
					pos: position{line: 246, col: 21, offset: 7262},
					exprs: []any{
						&notExpr{
							pos: position{line: 246, col: 21, offset: 7262},
							expr: &litMatcher{
								pos:        position{line: 246, col: 22, offset: 7263},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 246, col: 26, offset: 7267},
							expr: &ruleRefExpr{
								pos:  position{line: 246, col: 26, offset: 7267},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 246, col: 29, offset: 7270},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:  position{line: 246, col: 40, offset: 7281},
								name: "Attribute",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 246, col: 51, offset: 7292},
							expr: &ruleRefExpr{
								pos:  position{line: 246, col: 51, offset: 7292},
								name: "_",
							},
						},
						&zeroOrOneExpr{
							pos: position{line: 246, col: 54, offset: 7295},
							expr: &litMatcher{
								pos:        position{line: 246, col: 54, offset: 7295},
								val:        ",",
								ignoreCase: false,
								want:       "\",\"",
							},
						},
					},
				},
			},
		},
		{
			name: "Attribute",
			pos:  position{line: 250, col: 1, offset: 7331},
			expr: &actionExpr{
				pos: position{line: 250, col: 13, offset: 7343},
				run: (*parser).callonAttribute1,
				expr: &seqExpr{
					pos: position{line: 250, col: 13, offset: 7343},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 250, col: 13, offset: 7343},
							label: "name",
							expr: &zeroOrOneExpr{
								pos: position{line: 250, col: 18, offset: 7348},
								expr: &actionExpr{
									pos: position{line: 250, col: 20, offset: 7350},
									run: (*parser).callonAttribute5,
									expr: &seqExpr{
										pos: position{line: 250, col: 21, offset: 7351},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 250, col: 21, offset: 7351},
												label: "name",
												expr: &ruleRefExpr{
													pos:  position{line: 250, col: 27, offset: 7357},
													name: "NamedAttributeName",
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 250, col: 47, offset: 7377},
												expr: &ruleRefExpr{
													pos:  position{line: 250, col: 47, offset: 7377},
													name: "_",
												},
											},
											&litMatcher{
												pos:        position{line: 250, col: 50, offset: 7380},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
											&zeroOrMoreExpr{
												pos: position{line: 250, col: 54, offset: 7384},
												expr: &ruleRefExpr{
													pos:  position{line: 250, col: 54, offset: 7384},
													name: "_",
												},
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 250, col: 81, offset: 7411},
							label: "value",
							expr: &choiceExpr{
								pos: position{line: 250, col: 88, offset: 7418},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 250, col: 88, offset: 7418},
										name: "SingleQuoteAttributeValue",
									},
									&ruleRefExpr{
										pos:  position{line: 250, col: 116, offset: 7446},
										name: "DoubleQuoteAttributeValue",
									},
									&ruleRefExpr{
										pos:  position{line: 250, col: 144, offset: 7474},
										name: "NakedAttributeValue",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandAttributes",
			pos:  position{line: 257, col: 1, offset: 7730},
			expr: &actionExpr{
				pos: position{line: 257, col: 23, offset: 7752},
				run: (*parser).callonShorthandAttributes1,
				expr: &seqExpr{
					pos: position{line: 257, col: 23, offset: 7752},
					exprs: []any{
						&notExpr{
							pos: position{line: 257, col: 23, offset: 7752},
							expr: &litMatcher{
								pos:        position{line: 257, col: 24, offset: 7753},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 257, col: 29, offset: 7758},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&notExpr{
							pos: position{line: 257, col: 33, offset: 7762},
							expr: &litMatcher{
								pos:        position{line: 257, col: 34, offset: 7763},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 257, col: 38, offset: 7767},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:  position{line: 257, col: 49, offset: 7778},
								name: "ShorthandAttribute",
							},
						},
						&litMatcher{
							pos:        position{line: 257, col: 69, offset: 7798},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "ShorthandAttribute",
			pos:  position{line: 262, col: 1, offset: 7899},
			expr: &actionExpr{
				pos: position{line: 262, col: 22, offset: 7920},
				run: (*parser).callonShorthandAttribute1,
				expr: &seqExpr{
					pos: position{line: 262, col: 22, offset: 7920},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 262, col: 22, offset: 7920},
							label: "style",
							expr: &zeroOrOneExpr{
								pos: position{line: 262, col: 28, offset: 7926},
								expr: &ruleRefExpr{
									pos:  position{line: 262, col: 29, offset: 7927},
									name: "ShorthandAttributeValue",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 262, col: 55, offset: 7953},
							label: "values",
							expr: &oneOrMoreExpr{
								pos: position{line: 262, col: 62, offset: 7960},
								expr: &choiceExpr{
									pos: position{line: 262, col: 63, offset: 7961},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 262, col: 63, offset: 7961},
											name: "ShorthandID",
										},
										&ruleRefExpr{
											pos:  position{line: 262, col: 77, offset: 7975},
											name: "ShorthandRole",
										},
										&ruleRefExpr{
											pos:  position{line: 262, col: 93, offset: 7991},
											name: "ShorthandOption",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandStyle",
			pos:  position{line: 266, col: 1, offset: 8079},
			expr: &actionExpr{
				pos: position{line: 266, col: 18, offset: 8096},
				run: (*parser).callonShorthandStyle1,
				expr: &labeledExpr{
					pos:   position{line: 266, col: 18, offset: 8096},
					label: "value",
					expr: &ruleRefExpr{
						pos:  position{line: 266, col: 24, offset: 8102},
						name: "ShorthandAttributeValue",
					},
				},
			},
		},
		{
			name: "ShorthandID",
			pos:  position{line: 270, col: 1, offset: 8193},
			expr: &actionExpr{
				pos: position{line: 270, col: 15, offset: 8207},
				run: (*parser).callonShorthandID1,
				expr: &seqExpr{
					pos: position{line: 270, col: 15, offset: 8207},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 270, col: 15, offset: 8207},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 270, col: 19, offset: 8211},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 270, col: 25, offset: 8217},
								name: "ShorthandAttributeValue",
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandRole",
			pos:  position{line: 274, col: 1, offset: 8308},
			expr: &actionExpr{
				pos: position{line: 274, col: 17, offset: 8324},
				run: (*parser).callonShorthandRole1,
				expr: &seqExpr{
					pos: position{line: 274, col: 17, offset: 8324},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 274, col: 17, offset: 8324},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&labeledExpr{
							pos:   position{line: 274, col: 21, offset: 8328},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 274, col: 27, offset: 8334},
								name: "ShorthandAttributeValue",
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandOption",
			pos:  position{line: 278, col: 1, offset: 8427},
			expr: &actionExpr{
				pos: position{line: 278, col: 19, offset: 8445},
				run: (*parser).callonShorthandOption1,
				expr: &seqExpr{
					pos: position{line: 278, col: 19, offset: 8445},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 278, col: 19, offset: 8445},
							val:        "%",
							ignoreCase: false,
							want:       "\"%\"",
						},
						&labeledExpr{
							pos:   position{line: 278, col: 23, offset: 8449},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 278, col: 29, offset: 8455},
								name: "ShorthandAttributeValue",
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandAttributeValue",
			pos:  position{line: 282, col: 1, offset: 8550},
			expr: &actionExpr{
				pos: position{line: 282, col: 27, offset: 8576},
				run: (*parser).callonShorthandAttributeValue1,
				expr: &labeledExpr{
					pos:   position{line: 282, col: 27, offset: 8576},
					label: "value",
					expr: &choiceExpr{
						pos: position{line: 282, col: 34, offset: 8583},
						alternatives: []any{
							&seqExpr{
								pos: position{line: 282, col: 34, offset: 8583},
								exprs: []any{
									&notExpr{
										pos: position{line: 282, col: 34, offset: 8583},
										expr: &litMatcher{
											pos:        position{line: 282, col: 35, offset: 8584},
											val:        "#",
											ignoreCase: false,
											want:       "\"#\"",
										},
									},
									&notExpr{
										pos: position{line: 282, col: 39, offset: 8588},
										expr: &litMatcher{
											pos:        position{line: 282, col: 40, offset: 8589},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
									&notExpr{
										pos: position{line: 282, col: 44, offset: 8593},
										expr: &litMatcher{
											pos:        position{line: 282, col: 45, offset: 8594},
											val:        "%",
											ignoreCase: false,
											want:       "\"%\"",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 282, col: 49, offset: 8598},
										name: "SingleQuoteAttributeValue",
									},
								},
							},
							&ruleRefExpr{
								pos:  position{line: 282, col: 77, offset: 8626},
								name: "DoubleQuoteAttributeValue",
							},
							&ruleRefExpr{
								pos:  position{line: 282, col: 105, offset: 8654},
								name: "NakedAttributeValue",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleQuoteAttributeValue",
			pos:  position{line: 286, col: 1, offset: 8702},
			expr: &actionExpr{
				pos: position{line: 286, col: 29, offset: 8730},
				run: (*parser).callonSingleQuoteAttributeValue1,
				expr: &seqExpr{
					pos: position{line: 286, col: 29, offset: 8730},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 286, col: 29, offset: 8730},
							val:        "'",
							ignoreCase: false,
							want:       "\"'\"",
						},
						&labeledExpr{
							pos:   position{line: 286, col: 33, offset: 8734},
							label: "value",
							expr: &zeroOrMoreExpr{
								pos: position{line: 286, col: 39, offset: 8740},
								expr: &ruleRefExpr{
									pos:  position{line: 286, col: 40, offset: 8741},
									name: "SingleQuoteAttributeValueElement",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 286, col: 75, offset: 8776},
							val:        "'",
							ignoreCase: false,
							want:       "\"'\"",
						},
					},
				},
			},
		},
		{
			name: "SingleQuoteAttributeValueElement",
			pos:  position{line: 290, col: 1, offset: 8885},
			expr: &choiceExpr{
				pos: position{line: 291, col: 5, offset: 8926},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 291, col: 5, offset: 8926},
						run: (*parser).callonSingleQuoteAttributeValueElement2,
						expr: &litMatcher{
							pos:        position{line: 291, col: 5, offset: 8926},
							val:        "\\'",
							ignoreCase: false,
							want:       "\"\\\\'\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 292, col: 5, offset: 8979},
						name: "Alphanumeric",
					},
					&ruleRefExpr{
						pos:  position{line: 293, col: 5, offset: 8999},
						name: "_",
					},
					&ruleRefExpr{
						pos:  position{line: 294, col: 5, offset: 9008},
						name: "CurvedQuote",
					},
					&ruleRefExpr{
						pos:  position{line: 295, col: 5, offset: 9027},
						name: "AttributeReference",
					},
					&actionExpr{
						pos: position{line: 296, col: 5, offset: 9052},
						run: (*parser).callonSingleQuoteAttributeValueElement8,
						expr: &oneOrMoreExpr{
							pos: position{line: 296, col: 5, offset: 9052},
							expr: &charClassMatcher{
								pos:             position{line: 296, col: 5, offset: 9052},
								val:             "[^\\r\\n\\\\' ]",
								chars:           []rune{'\r', '\n', '\\', '\'', ' '},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        true,
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValue",
			pos:  position{line: 301, col: 1, offset: 9131},
			expr: &actionExpr{
				pos: position{line: 301, col: 29, offset: 9159},
				run: (*parser).callonDoubleQuoteAttributeValue1,
				expr: &seqExpr{
					pos: position{line: 301, col: 29, offset: 9159},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 301, col: 29, offset: 9159},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
						&labeledExpr{
							pos:   position{line: 301, col: 34, offset: 9164},
							label: "value",
							expr: &zeroOrMoreExpr{
								pos: position{line: 301, col: 40, offset: 9170},
								expr: &ruleRefExpr{
									pos:  position{line: 301, col: 41, offset: 9171},
									name: "DoubleQuoteAttributeValueElement",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 301, col: 76, offset: 9206},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValueElement",
			pos:  position{line: 305, col: 1, offset: 9316},
			expr: &choiceExpr{
				pos: position{line: 306, col: 5, offset: 9357},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 306, col: 5, offset: 9357},
						run: (*parser).callonDoubleQuoteAttributeValueElement2,
						expr: &litMatcher{
							pos:        position{line: 306, col: 5, offset: 9357},
							val:        "\\\"",
							ignoreCase: false,
							want:       "\"\\\\\\\"\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 307, col: 5, offset: 9413},
						name: "Alphanumeric",
					},
					&ruleRefExpr{
						pos:  position{line: 308, col: 5, offset: 9433},
						name: "_",
					},
					&ruleRefExpr{
						pos:  position{line: 309, col: 5, offset: 9442},
						name: "CurvedQuote",
					},
					&ruleRefExpr{
						pos:  position{line: 310, col: 5, offset: 9460},
						name: "AttributeReference",
					},
					&actionExpr{
						pos: position{line: 311, col: 5, offset: 9485},
						run: (*parser).callonDoubleQuoteAttributeValueElement8,
						expr: &oneOrMoreExpr{
							pos: position{line: 311, col: 5, offset: 9485},
							expr: &charClassMatcher{
								pos:             position{line: 311, col: 5, offset: 9485},
								val:             "[^\\r\\n\\\\\" ]",
								chars:           []rune{'\r', '\n', '\\', '"', ' '},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        true,
							},
						},
					},
				},
			},
		},
		{
			name: "NakedAttributeValue",
			pos:  position{line: 316, col: 1, offset: 9564},
			expr: &actionExpr{
				pos: position{line: 316, col: 23, offset: 9586},
				run: (*parser).callonNakedAttributeValue1,
				expr: &seqExpr{
					pos: position{line: 316, col: 23, offset: 9586},
					exprs: []any{
						&notExpr{
							pos: position{line: 316, col: 23, offset: 9586},
							expr: &ruleRefExpr{
								pos:  position{line: 316, col: 24, offset: 9587},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 316, col: 26, offset: 9589},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 316, col: 32, offset: 9595},
								expr: &choiceExpr{
									pos: position{line: 317, col: 5, offset: 9601},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 317, col: 5, offset: 9601},
											name: "AttributeReference",
										},
										&ruleRefExpr{
											pos:  position{line: 318, col: 5, offset: 9627},
											name: "_",
										},
										&actionExpr{
											pos: position{line: 319, col: 5, offset: 9636},
											run: (*parser).callonNakedAttributeValue10,
											expr: &oneOrMoreExpr{
												pos: position{line: 319, col: 5, offset: 9636},
												expr: &charClassMatcher{
													pos:             position{line: 319, col: 5, offset: 9636},
													val:             "[^=\\], ]",
													chars:           []rune{'=', ']', ',', ' '},
													basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
													ignoreCase:      false,
													inverted:        true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineAttributes",
			pos:  position{line: 327, col: 1, offset: 9930},
			expr: &actionExpr{
				pos: position{line: 327, col: 20, offset: 9949},
				run: (*parser).callonInlineAttributes1,
				expr: &seqExpr{
					pos: position{line: 327, col: 20, offset: 9949},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 327, col: 20, offset: 9949},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 327, col: 24, offset: 9953},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 327, col: 36, offset: 9965},
								name: "AttributeList",
							},
						},
						&litMatcher{
							pos:        position{line: 327, col: 51, offset: 9980},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "NamedAttributeName",
			pos:  position{line: 332, col: 1, offset: 10088},
			expr: &actionExpr{
				pos: position{line: 332, col: 22, offset: 10109},
				run: (*parser).callonNamedAttributeName1,
				expr: &seqExpr{
					pos: position{line: 332, col: 22, offset: 10109},
					exprs: []any{
						&charClassMatcher{
							pos:             position{line: 332, col: 22, offset: 10109},
							val:             "[A-Za-z0-9_]",
							chars:           []rune{'_'},
							ranges:          []rune{'A', 'Z', 'a', 'z', '0', '9'},
							basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
							ignoreCase:      false,
							inverted:        false,
						},
						&zeroOrMoreExpr{
							pos: position{line: 332, col: 35, offset: 10122},
							expr: &charClassMatcher{
								pos:             position{line: 332, col: 35, offset: 10122},
								val:             "[A-Za-z0-9_-]",
								chars:           []rune{'_', '-'},
								ranges:          []rune{'A', 'Z', 'a', 'z', '0', '9'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeReference",
			pos:  position{line: 337, col: 1, offset: 10248},
			expr: &actionExpr{
				pos: position{line: 337, col: 22, offset: 10269},
				run: (*parser).callonAttributeReference1,
				expr: &labeledExpr{
					pos:   position{line: 337, col: 22, offset: 10269},
					label: "attribute",
					expr: &choiceExpr{
						pos: position{line: 337, col: 33, offset: 10280},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 337, col: 33, offset: 10280},
								name: "AttributeReferenceValue",
							},
							&ruleRefExpr{
								pos:  position{line: 337, col: 59, offset: 10306},
								name: "Counter",
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeReferenceValue",
			pos:  position{line: 341, col: 1, offset: 10346},
			expr: &actionExpr{
				pos: position{line: 341, col: 27, offset: 10372},
				run: (*parser).callonAttributeReferenceValue1,
				expr: &seqExpr{
					pos: position{line: 341, col: 27, offset: 10372},
					exprs: []any{
						&notExpr{
							pos: position{line: 341, col: 27, offset: 10372},
							expr: &litMatcher{
								pos:        position{line: 341, col: 28, offset: 10373},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 341, col: 33, offset: 10378},
							val:        "{",
							ignoreCase: false,
							want:       "\"{\"",
						},
						&labeledExpr{
							pos:   position{line: 341, col: 37, offset: 10382},
							label: "name",
							expr: &ruleRefExpr{
								pos:  position{line: 341, col: 42, offset: 10387},
								name: "AttributeEntryName",
							},
						},
						&litMatcher{
							pos:        position{line: 341, col: 61, offset: 10406},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
					},
				},
			},
		},
		{
			name: "BoldText",
			pos:  position{line: 349, col: 1, offset: 10502},
			expr: &choiceExpr{
				pos: position{line: 349, col: 13, offset: 10514},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 349, col: 13, offset: 10514},
						name: "SingleBoldText",
					},
					&ruleRefExpr{
						pos:  position{line: 349, col: 30, offset: 10531},
						name: "DoubleBoldText",
					},
				},
			},
		},
		{
			name: "SingleBoldText",
			pos:  position{line: 351, col: 1, offset: 10548},
			expr: &actionExpr{
				pos: position{line: 351, col: 18, offset: 10565},
				run: (*parser).callonSingleBoldText1,
				expr: &seqExpr{
					pos: position{line: 351, col: 18, offset: 10565},
					exprs: []any{
						&notExpr{
							pos: position{line: 351, col: 18, offset: 10565},
							expr: &ruleRefExpr{
								pos:  position{line: 351, col: 19, offset: 10566},
								name: "Escape",
							},
						},
						&litMatcher{
							pos:        position{line: 351, col: 26, offset: 10573},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
						&andExpr{
							pos: position{line: 351, col: 30, offset: 10577},
							expr: &notExpr{
								pos: position{line: 351, col: 32, offset: 10579},
								expr: &litMatcher{
									pos:        position{line: 351, col: 33, offset: 10580},
									val:        "*",
									ignoreCase: false,
									want:       "\"*\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 351, col: 38, offset: 10585},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 351, col: 45, offset: 10592},
								name: "SingleBoldTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 351, col: 66, offset: 10613},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
						&notExpr{
							pos: position{line: 351, col: 70, offset: 10617},
							expr: &litMatcher{
								pos:        position{line: 351, col: 71, offset: 10618},
								val:        "*",
								ignoreCase: false,
								want:       "\"*\"",
							},
						},
						&andExpr{
							pos: position{line: 351, col: 75, offset: 10622},
							expr: &notExpr{
								pos: position{line: 351, col: 77, offset: 10624},
								expr: &ruleRefExpr{
									pos:  position{line: 351, col: 78, offset: 10625},
									name: "Alphanumeric",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleBoldTextValue",
			pos:  position{line: 356, col: 1, offset: 10727},
			expr: &actionExpr{
				pos: position{line: 356, col: 23, offset: 10749},
				run: (*parser).callonSingleBoldTextValue1,
				expr: &seqExpr{
					pos: position{line: 356, col: 23, offset: 10749},
					exprs: []any{
						&notExpr{
							pos: position{line: 356, col: 23, offset: 10749},
							expr: &ruleRefExpr{
								pos:  position{line: 356, col: 24, offset: 10750},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 356, col: 26, offset: 10752},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 356, col: 32, offset: 10758},
								expr: &actionExpr{
									pos: position{line: 356, col: 33, offset: 10759},
									run: (*parser).callonSingleBoldTextValue7,
									expr: &seqExpr{
										pos: position{line: 356, col: 33, offset: 10759},
										exprs: []any{
											&notExpr{
												pos: position{line: 356, col: 33, offset: 10759},
												expr: &ruleRefExpr{
													pos:  position{line: 356, col: 34, offset: 10760},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 356, col: 36, offset: 10762},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 356, col: 42, offset: 10768},
													expr: &ruleRefExpr{
														pos:  position{line: 356, col: 43, offset: 10769},
														name: "SingleBoldTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleBoldTextElement",
			pos:  position{line: 361, col: 1, offset: 10977},
			expr: &actionExpr{
				pos: position{line: 361, col: 25, offset: 11001},
				run: (*parser).callonSingleBoldTextElement1,
				expr: &seqExpr{
					pos: position{line: 361, col: 25, offset: 11001},
					exprs: []any{
						&notExpr{
							pos: position{line: 361, col: 25, offset: 11001},
							expr: &seqExpr{
								pos: position{line: 361, col: 27, offset: 11003},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 361, col: 27, offset: 11003},
										val:        "*",
										ignoreCase: false,
										want:       "\"*\"",
									},
									&notExpr{
										pos: position{line: 361, col: 31, offset: 11007},
										expr: &litMatcher{
											pos:        position{line: 361, col: 32, offset: 11008},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 361, col: 37, offset: 11013},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 361, col: 46, offset: 11022},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleBoldText",
			pos:  position{line: 366, col: 1, offset: 11142},
			expr: &actionExpr{
				pos: position{line: 366, col: 18, offset: 11159},
				run: (*parser).callonDoubleBoldText1,
				expr: &seqExpr{
					pos: position{line: 366, col: 18, offset: 11159},
					exprs: []any{
						&notExpr{
							pos: position{line: 366, col: 18, offset: 11159},
							expr: &ruleRefExpr{
								pos:  position{line: 366, col: 19, offset: 11160},
								name: "DoubleEscape",
							},
						},
						&litMatcher{
							pos:        position{line: 366, col: 32, offset: 11173},
							val:        "**",
							ignoreCase: false,
							want:       "\"**\"",
						},
						&labeledExpr{
							pos:   position{line: 366, col: 37, offset: 11178},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 366, col: 44, offset: 11185},
								name: "DoubleBoldTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 366, col: 65, offset: 11206},
							val:        "**",
							ignoreCase: false,
							want:       "\"**\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleBoldTextValue",
			pos:  position{line: 371, col: 1, offset: 11307},
			expr: &actionExpr{
				pos: position{line: 371, col: 23, offset: 11329},
				run: (*parser).callonDoubleBoldTextValue1,
				expr: &seqExpr{
					pos: position{line: 371, col: 23, offset: 11329},
					exprs: []any{
						&notExpr{
							pos: position{line: 371, col: 23, offset: 11329},
							expr: &ruleRefExpr{
								pos:  position{line: 371, col: 24, offset: 11330},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 371, col: 26, offset: 11332},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 371, col: 32, offset: 11338},
								expr: &actionExpr{
									pos: position{line: 371, col: 33, offset: 11339},
									run: (*parser).callonDoubleBoldTextValue7,
									expr: &seqExpr{
										pos: position{line: 371, col: 33, offset: 11339},
										exprs: []any{
											&notExpr{
												pos: position{line: 371, col: 33, offset: 11339},
												expr: &ruleRefExpr{
													pos:  position{line: 371, col: 34, offset: 11340},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 371, col: 36, offset: 11342},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 371, col: 42, offset: 11348},
													expr: &ruleRefExpr{
														pos:  position{line: 371, col: 43, offset: 11349},
														name: "DoubleBoldTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleBoldTextElement",
			pos:  position{line: 376, col: 1, offset: 11576},
			expr: &actionExpr{
				pos: position{line: 376, col: 25, offset: 11600},
				run: (*parser).callonDoubleBoldTextElement1,
				expr: &seqExpr{
					pos: position{line: 376, col: 25, offset: 11600},
					exprs: []any{
						&notExpr{
							pos: position{line: 376, col: 25, offset: 11600},
							expr: &litMatcher{
								pos:        position{line: 376, col: 27, offset: 11602},
								val:        "**",
								ignoreCase: false,
								want:       "\"**\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 376, col: 33, offset: 11608},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 376, col: 42, offset: 11617},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "ItalicText",
			pos:  position{line: 383, col: 1, offset: 11746},
			expr: &choiceExpr{
				pos: position{line: 383, col: 15, offset: 11760},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 383, col: 15, offset: 11760},
						name: "SingleItalicText",
					},
					&ruleRefExpr{
						pos:  position{line: 383, col: 34, offset: 11779},
						name: "DoubleItalicText",
					},
				},
			},
		},
		{
			name: "SingleItalicText",
			pos:  position{line: 385, col: 1, offset: 11798},
			expr: &actionExpr{
				pos: position{line: 385, col: 20, offset: 11817},
				run: (*parser).callonSingleItalicText1,
				expr: &seqExpr{
					pos: position{line: 385, col: 20, offset: 11817},
					exprs: []any{
						&notExpr{
							pos: position{line: 385, col: 20, offset: 11817},
							expr: &ruleRefExpr{
								pos:  position{line: 385, col: 21, offset: 11818},
								name: "Escape",
							},
						},
						&litMatcher{
							pos:        position{line: 385, col: 28, offset: 11825},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
						&andExpr{
							pos: position{line: 385, col: 32, offset: 11829},
							expr: &notExpr{
								pos: position{line: 385, col: 34, offset: 11831},
								expr: &litMatcher{
									pos:        position{line: 385, col: 35, offset: 11832},
									val:        "_",
									ignoreCase: false,
									want:       "\"_\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 385, col: 40, offset: 11837},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 385, col: 47, offset: 11844},
								name: "SingleItalicTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 385, col: 70, offset: 11867},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
						&notExpr{
							pos: position{line: 385, col: 74, offset: 11871},
							expr: &litMatcher{
								pos:        position{line: 385, col: 75, offset: 11872},
								val:        "_",
								ignoreCase: false,
								want:       "\"_\"",
							},
						},
						&andExpr{
							pos: position{line: 385, col: 79, offset: 11876},
							expr: &notExpr{
								pos: position{line: 385, col: 81, offset: 11878},
								expr: &ruleRefExpr{
									pos:  position{line: 385, col: 82, offset: 11879},
									name: "Alphanumeric",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleItalicTextValue",
			pos:  position{line: 390, col: 1, offset: 11983},
			expr: &actionExpr{
				pos: position{line: 390, col: 25, offset: 12007},
				run: (*parser).callonSingleItalicTextValue1,
				expr: &seqExpr{
					pos: position{line: 390, col: 25, offset: 12007},
					exprs: []any{
						&notExpr{
							pos: position{line: 390, col: 25, offset: 12007},
							expr: &ruleRefExpr{
								pos:  position{line: 390, col: 26, offset: 12008},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 390, col: 28, offset: 12010},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 390, col: 34, offset: 12016},
								expr: &actionExpr{
									pos: position{line: 390, col: 35, offset: 12017},
									run: (*parser).callonSingleItalicTextValue7,
									expr: &seqExpr{
										pos: position{line: 390, col: 35, offset: 12017},
										exprs: []any{
											&notExpr{
												pos: position{line: 390, col: 35, offset: 12017},
												expr: &ruleRefExpr{
													pos:  position{line: 390, col: 36, offset: 12018},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 390, col: 38, offset: 12020},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 390, col: 44, offset: 12026},
													expr: &ruleRefExpr{
														pos:  position{line: 390, col: 45, offset: 12027},
														name: "SingleItalicTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleItalicTextElement",
			pos:  position{line: 395, col: 1, offset: 12203},
			expr: &actionExpr{
				pos: position{line: 395, col: 27, offset: 12229},
				run: (*parser).callonSingleItalicTextElement1,
				expr: &seqExpr{
					pos: position{line: 395, col: 27, offset: 12229},
					exprs: []any{
						&notExpr{
							pos: position{line: 395, col: 27, offset: 12229},
							expr: &seqExpr{
								pos: position{line: 395, col: 29, offset: 12231},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 395, col: 29, offset: 12231},
										val:        "_",
										ignoreCase: false,
										want:       "\"_\"",
									},
									&notExpr{
										pos: position{line: 395, col: 33, offset: 12235},
										expr: &litMatcher{
											pos:        position{line: 395, col: 34, offset: 12236},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 395, col: 39, offset: 12241},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 395, col: 48, offset: 12250},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleItalicText",
			pos:  position{line: 400, col: 1, offset: 12372},
			expr: &actionExpr{
				pos: position{line: 400, col: 20, offset: 12391},
				run: (*parser).callonDoubleItalicText1,
				expr: &seqExpr{
					pos: position{line: 400, col: 20, offset: 12391},
					exprs: []any{
						&notExpr{
							pos: position{line: 400, col: 20, offset: 12391},
							expr: &ruleRefExpr{
								pos:  position{line: 400, col: 21, offset: 12392},
								name: "DoubleEscape",
							},
						},
						&litMatcher{
							pos:        position{line: 400, col: 34, offset: 12405},
							val:        "__",
							ignoreCase: false,
							want:       "\"__\"",
						},
						&labeledExpr{
							pos:   position{line: 400, col: 39, offset: 12410},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 400, col: 46, offset: 12417},
								name: "DoubleItalicTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 400, col: 69, offset: 12440},
							val:        "__",
							ignoreCase: false,
							want:       "\"__\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleItalicTextValue",
			pos:  position{line: 405, col: 1, offset: 12543},
			expr: &actionExpr{
				pos: position{line: 405, col: 25, offset: 12567},
				run: (*parser).callonDoubleItalicTextValue1,
				expr: &seqExpr{
					pos: position{line: 405, col: 25, offset: 12567},
					exprs: []any{
						&notExpr{
							pos: position{line: 405, col: 25, offset: 12567},
							expr: &ruleRefExpr{
								pos:  position{line: 405, col: 26, offset: 12568},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 405, col: 28, offset: 12570},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 405, col: 34, offset: 12576},
								expr: &actionExpr{
									pos: position{line: 405, col: 35, offset: 12577},
									run: (*parser).callonDoubleItalicTextValue7,
									expr: &seqExpr{
										pos: position{line: 405, col: 35, offset: 12577},
										exprs: []any{
											&notExpr{
												pos: position{line: 405, col: 35, offset: 12577},
												expr: &ruleRefExpr{
													pos:  position{line: 405, col: 36, offset: 12578},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 405, col: 38, offset: 12580},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 405, col: 44, offset: 12586},
													expr: &ruleRefExpr{
														pos:  position{line: 405, col: 45, offset: 12587},
														name: "DoubleItalicTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleItalicTextElement",
			pos:  position{line: 410, col: 1, offset: 12776},
			expr: &actionExpr{
				pos: position{line: 410, col: 27, offset: 12802},
				run: (*parser).callonDoubleItalicTextElement1,
				expr: &seqExpr{
					pos: position{line: 410, col: 27, offset: 12802},
					exprs: []any{
						&notExpr{
							pos: position{line: 410, col: 27, offset: 12802},
							expr: &litMatcher{
								pos:        position{line: 410, col: 29, offset: 12804},
								val:        "__",
								ignoreCase: false,
								want:       "\"__\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 410, col: 35, offset: 12810},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 410, col: 44, offset: 12819},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "SubscriptText",
			pos:  position{line: 418, col: 1, offset: 12951},
			expr: &actionExpr{
				pos: position{line: 418, col: 17, offset: 12967},
				run: (*parser).callonSubscriptText1,
				expr: &seqExpr{
					pos: position{line: 418, col: 17, offset: 12967},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 418, col: 17, offset: 12967},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
						&labeledExpr{
							pos:   position{line: 418, col: 22, offset: 12972},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 418, col: 29, offset: 12979},
								name: "SubscriptTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 418, col: 49, offset: 12999},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
					},
				},
			},
		},
		{
			name: "SubscriptTextValue",
			pos:  position{line: 423, col: 1, offset: 13096},
			expr: &actionExpr{
				pos: position{line: 423, col: 22, offset: 13117},
				run: (*parser).callonSubscriptTextValue1,
				expr: &seqExpr{
					pos: position{line: 423, col: 22, offset: 13117},
					exprs: []any{
						&notExpr{
							pos: position{line: 423, col: 22, offset: 13117},
							expr: &ruleRefExpr{
								pos:  position{line: 423, col: 23, offset: 13118},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 423, col: 25, offset: 13120},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 423, col: 31, offset: 13126},
								expr: &actionExpr{
									pos: position{line: 423, col: 32, offset: 13127},
									run: (*parser).callonSubscriptTextValue7,
									expr: &seqExpr{
										pos: position{line: 423, col: 32, offset: 13127},
										exprs: []any{
											&notExpr{
												pos: position{line: 423, col: 32, offset: 13127},
												expr: &ruleRefExpr{
													pos:  position{line: 423, col: 33, offset: 13128},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 423, col: 35, offset: 13130},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 423, col: 41, offset: 13136},
													expr: &ruleRefExpr{
														pos:  position{line: 423, col: 42, offset: 13137},
														name: "SubscriptTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SubscriptTextElement",
			pos:  position{line: 428, col: 1, offset: 13359},
			expr: &actionExpr{
				pos: position{line: 428, col: 24, offset: 13382},
				run: (*parser).callonSubscriptTextElement1,
				expr: &seqExpr{
					pos: position{line: 428, col: 24, offset: 13382},
					exprs: []any{
						&notExpr{
							pos: position{line: 428, col: 24, offset: 13382},
							expr: &litMatcher{
								pos:        position{line: 428, col: 26, offset: 13384},
								val:        "~",
								ignoreCase: false,
								want:       "\"~\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 428, col: 31, offset: 13389},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 428, col: 40, offset: 13398},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "EscapedSubscript",
			pos:  position{line: 433, col: 1, offset: 13523},
			expr: &actionExpr{
				pos: position{line: 433, col: 20, offset: 13542},
				run: (*parser).callonEscapedSubscript1,
				expr: &seqExpr{
					pos: position{line: 433, col: 21, offset: 13543},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 433, col: 21, offset: 13543},
							name: "Escape",
						},
						&litMatcher{
							pos:        position{line: 433, col: 28, offset: 13550},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
						&ruleRefExpr{
							pos:  position{line: 433, col: 32, offset: 13554},
							name: "SubscriptTextValue",
						},
						&litMatcher{
							pos:        position{line: 433, col: 51, offset: 13573},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
					},
				},
			},
		},
		{
			name: "SuperscriptText",
			pos:  position{line: 439, col: 1, offset: 13636},
			expr: &actionExpr{
				pos: position{line: 439, col: 19, offset: 13654},
				run: (*parser).callonSuperscriptText1,
				expr: &seqExpr{
					pos: position{line: 439, col: 19, offset: 13654},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 439, col: 19, offset: 13654},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
						&labeledExpr{
							pos:   position{line: 439, col: 24, offset: 13659},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 439, col: 31, offset: 13666},
								name: "SuperscriptTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 439, col: 53, offset: 13688},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
					},
				},
			},
		},
		{
			name: "SuperscriptTextValue",
			pos:  position{line: 444, col: 1, offset: 13787},
			expr: &actionExpr{
				pos: position{line: 444, col: 24, offset: 13810},
				run: (*parser).callonSuperscriptTextValue1,
				expr: &seqExpr{
					pos: position{line: 444, col: 24, offset: 13810},
					exprs: []any{
						&notExpr{
							pos: position{line: 444, col: 24, offset: 13810},
							expr: &ruleRefExpr{
								pos:  position{line: 444, col: 25, offset: 13811},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 444, col: 27, offset: 13813},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 444, col: 33, offset: 13819},
								expr: &actionExpr{
									pos: position{line: 444, col: 34, offset: 13820},
									run: (*parser).callonSuperscriptTextValue7,
									expr: &seqExpr{
										pos: position{line: 444, col: 34, offset: 13820},
										exprs: []any{
											&notExpr{
												pos: position{line: 444, col: 34, offset: 13820},
												expr: &ruleRefExpr{
													pos:  position{line: 444, col: 35, offset: 13821},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 444, col: 37, offset: 13823},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 444, col: 43, offset: 13829},
													expr: &ruleRefExpr{
														pos:  position{line: 444, col: 44, offset: 13830},
														name: "SuperscriptTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SuperscriptTextElement",
			pos:  position{line: 449, col: 1, offset: 14060},
			expr: &actionExpr{
				pos: position{line: 449, col: 26, offset: 14085},
				run: (*parser).callonSuperscriptTextElement1,
				expr: &seqExpr{
					pos: position{line: 449, col: 26, offset: 14085},
					exprs: []any{
						&notExpr{
							pos: position{line: 449, col: 26, offset: 14085},
							expr: &litMatcher{
								pos:        position{line: 449, col: 28, offset: 14087},
								val:        "^",
								ignoreCase: false,
								want:       "\"^\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 449, col: 33, offset: 14092},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 449, col: 42, offset: 14101},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "EscapedSuperscript",
			pos:  position{line: 454, col: 1, offset: 14228},
			expr: &actionExpr{
				pos: position{line: 454, col: 22, offset: 14249},
				run: (*parser).callonEscapedSuperscript1,
				expr: &seqExpr{
					pos: position{line: 454, col: 23, offset: 14250},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 454, col: 23, offset: 14250},
							name: "Escape",
						},
						&litMatcher{
							pos:        position{line: 454, col: 30, offset: 14257},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
						&ruleRefExpr{
							pos:  position{line: 454, col: 34, offset: 14261},
							name: "SuperscriptTextValue",
						},
						&litMatcher{
							pos:        position{line: 454, col: 55, offset: 14282},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
					},
				},
			},
		},
		{
			name: "MonospaceText",
			pos:  position{line: 459, col: 1, offset: 14344},
			expr: &choiceExpr{
				pos: position{line: 459, col: 18, offset: 14361},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 459, col: 18, offset: 14361},
						name: "SingleMonospaceText",
					},
					&ruleRefExpr{
						pos:  position{line: 459, col: 40, offset: 14383},
						name: "DoubleMonospaceText",
					},
				},
			},
		},
		{
			name: "SingleMonospaceText",
			pos:  position{line: 461, col: 1, offset: 14405},
			expr: &actionExpr{
				pos: position{line: 461, col: 22, offset: 14426},
				run: (*parser).callonSingleMonospaceText1,
				expr: &seqExpr{
					pos: position{line: 461, col: 22, offset: 14426},
					exprs: []any{
						&notExpr{
							pos: position{line: 461, col: 22, offset: 14426},
							expr: &ruleRefExpr{
								pos:  position{line: 461, col: 23, offset: 14427},
								name: "Escape",
							},
						},
						&litMatcher{
							pos:        position{line: 461, col: 30, offset: 14434},
							val:        "`",
							ignoreCase: false,
							want:       "\"`\"",
						},
						&andExpr{
							pos: position{line: 461, col: 34, offset: 14438},
							expr: &notExpr{
								pos: position{line: 461, col: 36, offset: 14440},
								expr: &litMatcher{
									pos:        position{line: 461, col: 37, offset: 14441},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 461, col: 42, offset: 14446},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 461, col: 49, offset: 14453},
								name: "SingleMonospaceTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 461, col: 75, offset: 14479},
							val:        "`",
							ignoreCase: false,
							want:       "\"`\"",
						},
						&notExpr{
							pos: position{line: 461, col: 79, offset: 14483},
							expr: &litMatcher{
								pos:        position{line: 461, col: 80, offset: 14484},
								val:        "`",
								ignoreCase: false,
								want:       "\"`\"",
							},
						},
						&andExpr{
							pos: position{line: 461, col: 84, offset: 14488},
							expr: &notExpr{
								pos: position{line: 461, col: 86, offset: 14490},
								expr: &ruleRefExpr{
									pos:  position{line: 461, col: 87, offset: 14491},
									name: "Alphanumeric",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMonospaceTextValue",
			pos:  position{line: 466, col: 1, offset: 14598},
			expr: &actionExpr{
				pos: position{line: 466, col: 28, offset: 14625},
				run: (*parser).callonSingleMonospaceTextValue1,
				expr: &seqExpr{
					pos: position{line: 466, col: 28, offset: 14625},
					exprs: []any{
						&notExpr{
							pos: position{line: 466, col: 28, offset: 14625},
							expr: &ruleRefExpr{
								pos:  position{line: 466, col: 29, offset: 14626},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 466, col: 31, offset: 14628},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 466, col: 37, offset: 14634},
								expr: &actionExpr{
									pos: position{line: 466, col: 38, offset: 14635},
									run: (*parser).callonSingleMonospaceTextValue7,
									expr: &seqExpr{
										pos: position{line: 466, col: 38, offset: 14635},
										exprs: []any{
											&notExpr{
												pos: position{line: 466, col: 38, offset: 14635},
												expr: &ruleRefExpr{
													pos:  position{line: 466, col: 39, offset: 14636},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 466, col: 41, offset: 14638},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 466, col: 47, offset: 14644},
													expr: &ruleRefExpr{
														pos:  position{line: 466, col: 48, offset: 14645},
														name: "SingleMonospaceTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMonospaceTextElement",
			pos:  position{line: 471, col: 1, offset: 14830},
			expr: &actionExpr{
				pos: position{line: 471, col: 30, offset: 14859},
				run: (*parser).callonSingleMonospaceTextElement1,
				expr: &seqExpr{
					pos: position{line: 471, col: 30, offset: 14859},
					exprs: []any{
						&notExpr{
							pos: position{line: 471, col: 30, offset: 14859},
							expr: &seqExpr{
								pos: position{line: 471, col: 32, offset: 14861},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 471, col: 32, offset: 14861},
										val:        "`",
										ignoreCase: false,
										want:       "\"`\"",
									},
									&notExpr{
										pos: position{line: 471, col: 36, offset: 14865},
										expr: &litMatcher{
											pos:        position{line: 471, col: 37, offset: 14866},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 471, col: 42, offset: 14871},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 471, col: 51, offset: 14880},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMonospaceText",
			pos:  position{line: 476, col: 1, offset: 15005},
			expr: &actionExpr{
				pos: position{line: 476, col: 22, offset: 15026},
				run: (*parser).callonDoubleMonospaceText1,
				expr: &seqExpr{
					pos: position{line: 476, col: 22, offset: 15026},
					exprs: []any{
						&notExpr{
							pos: position{line: 476, col: 22, offset: 15026},
							expr: &ruleRefExpr{
								pos:  position{line: 476, col: 23, offset: 15027},
								name: "DoubleEscape",
							},
						},
						&litMatcher{
							pos:        position{line: 476, col: 36, offset: 15040},
							val:        "``",
							ignoreCase: false,
							want:       "\"``\"",
						},
						&labeledExpr{
							pos:   position{line: 476, col: 41, offset: 15045},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 476, col: 48, offset: 15052},
								name: "DoubleMonospaceTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 476, col: 74, offset: 15078},
							val:        "``",
							ignoreCase: false,
							want:       "\"``\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleMonospaceTextValue",
			pos:  position{line: 481, col: 1, offset: 15184},
			expr: &actionExpr{
				pos: position{line: 481, col: 28, offset: 15211},
				run: (*parser).callonDoubleMonospaceTextValue1,
				expr: &seqExpr{
					pos: position{line: 481, col: 28, offset: 15211},
					exprs: []any{
						&notExpr{
							pos: position{line: 481, col: 28, offset: 15211},
							expr: &ruleRefExpr{
								pos:  position{line: 481, col: 29, offset: 15212},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 481, col: 31, offset: 15214},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 481, col: 37, offset: 15220},
								expr: &actionExpr{
									pos: position{line: 481, col: 38, offset: 15221},
									run: (*parser).callonDoubleMonospaceTextValue7,
									expr: &seqExpr{
										pos: position{line: 481, col: 38, offset: 15221},
										exprs: []any{
											&notExpr{
												pos: position{line: 481, col: 38, offset: 15221},
												expr: &ruleRefExpr{
													pos:  position{line: 481, col: 39, offset: 15222},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 481, col: 41, offset: 15224},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 481, col: 47, offset: 15230},
													expr: &ruleRefExpr{
														pos:  position{line: 481, col: 48, offset: 15231},
														name: "DoubleMonospaceTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMonospaceTextElement",
			pos:  position{line: 486, col: 1, offset: 15429},
			expr: &actionExpr{
				pos: position{line: 486, col: 30, offset: 15458},
				run: (*parser).callonDoubleMonospaceTextElement1,
				expr: &seqExpr{
					pos: position{line: 486, col: 30, offset: 15458},
					exprs: []any{
						&notExpr{
							pos: position{line: 486, col: 30, offset: 15458},
							expr: &litMatcher{
								pos:        position{line: 486, col: 32, offset: 15460},
								val:        "``",
								ignoreCase: false,
								want:       "\"``\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 486, col: 38, offset: 15466},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 486, col: 47, offset: 15475},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "Anchor",
			pos:  position{line: 493, col: 1, offset: 15609},
			expr: &actionExpr{
				pos: position{line: 493, col: 10, offset: 15618},
				run: (*parser).callonAnchor1,
				expr: &seqExpr{
					pos: position{line: 493, col: 10, offset: 15618},
					exprs: []any{
						&notExpr{
							pos: position{line: 493, col: 10, offset: 15618},
							expr: &litMatcher{
								pos:        position{line: 493, col: 11, offset: 15619},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 493, col: 16, offset: 15624},
							val:        "[[",
							ignoreCase: false,
							want:       "\"[[\"",
						},
						&labeledExpr{
							pos:   position{line: 493, col: 21, offset: 15629},
							label: "id",
							expr: &ruleRefExpr{
								pos:  position{line: 493, col: 25, offset: 15633},
								name: "CrossReferenceID",
							},
						},
						&labeledExpr{
							pos:   position{line: 493, col: 43, offset: 15651},
							label: "label",
							expr: &zeroOrOneExpr{
								pos: position{line: 493, col: 49, offset: 15657},
								expr: &actionExpr{
									pos: position{line: 493, col: 50, offset: 15658},
									run: (*parser).callonAnchor10,
									expr: &seqExpr{
										pos: position{line: 493, col: 50, offset: 15658},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 493, col: 50, offset: 15658},
												expr: &ruleRefExpr{
													pos:  position{line: 493, col: 50, offset: 15658},
													name: "_",
												},
											},
											&litMatcher{
												pos:        position{line: 493, col: 53, offset: 15661},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&labeledExpr{
												pos:   position{line: 493, col: 57, offset: 15665},
												label: "label",
												expr: &ruleRefExpr{
													pos:  position{line: 493, col: 64, offset: 15672},
													name: "AnchorLabel",
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 493, col: 100, offset: 15708},
							val:        "]]",
							ignoreCase: false,
							want:       "\"]]\"",
						},
					},
				},
			},
		},
		{
			name: "AnchorAttribute",
			pos:  position{line: 502, col: 1, offset: 15926},
			expr: &actionExpr{
				pos: position{line: 502, col: 19, offset: 15944},
				run: (*parser).callonAnchorAttribute1,
				expr: &seqExpr{
					pos: position{line: 502, col: 19, offset: 15944},
					exprs: []any{
						&notExpr{
							pos: position{line: 502, col: 19, offset: 15944},
							expr: &litMatcher{
								pos:        position{line: 502, col: 20, offset: 15945},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 502, col: 25, offset: 15950},
							val:        "[[",
							ignoreCase: false,
							want:       "\"[[\"",
						},
						&labeledExpr{
							pos:   position{line: 502, col: 30, offset: 15955},
							label: "id",
							expr: &ruleRefExpr{
								pos:  position{line: 502, col: 34, offset: 15959},
								name: "CrossReferenceID",
							},
						},
						&labeledExpr{
							pos:   position{line: 502, col: 52, offset: 15977},
							label: "label",
							expr: &zeroOrOneExpr{
								pos: position{line: 502, col: 58, offset: 15983},
								expr: &actionExpr{
									pos: position{line: 502, col: 59, offset: 15984},
									run: (*parser).callonAnchorAttribute10,
									expr: &seqExpr{
										pos: position{line: 502, col: 59, offset: 15984},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 502, col: 59, offset: 15984},
												expr: &ruleRefExpr{
													pos:  position{line: 502, col: 59, offset: 15984},
													name: "_",
												},
											},
											&litMatcher{
												pos:        position{line: 502, col: 62, offset: 15987},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&labeledExpr{
												pos:   position{line: 502, col: 66, offset: 15991},
												label: "label",
												expr: &ruleRefExpr{
													pos:  position{line: 502, col: 73, offset: 15998},
													name: "AnchorLabel",
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 502, col: 109, offset: 16034},
							val:        "]]",
							ignoreCase: false,
							want:       "\"]]\"",
						},
					},
				},
			},
		},
		{
			name: "AnchorLabel",
			pos:  position{line: 511, col: 1, offset: 16305},
			expr: &oneOrMoreExpr{
				pos: position{line: 511, col: 15, offset: 16319},
				expr: &choiceExpr{
					pos: position{line: 511, col: 17, offset: 16321},
					alternatives: []any{
						&seqExpr{
							pos: position{line: 511, col: 17, offset: 16321},
							exprs: []any{
								&notExpr{
									pos: position{line: 511, col: 17, offset: 16321},
									expr: &litMatcher{
										pos:        position{line: 511, col: 18, offset: 16322},
										val:        "]]",
										ignoreCase: false,
										want:       "\"]]\"",
									},
								},
								&actionExpr{
									pos: position{line: 512, col: 6, offset: 16332},
									run: (*parser).callonAnchorLabel6,
									expr: &oneOrMoreExpr{
										pos: position{line: 512, col: 6, offset: 16332},
										expr: &charClassMatcher{
											pos:             position{line: 512, col: 6, offset: 16332},
											val:             "[^\\r\\n{[\\]]",
											chars:           []rune{'\r', '\n', '{', '[', ']'},
											basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false},
											ignoreCase:      false,
											inverted:        true,
										},
									},
								},
							},
						},
						&actionExpr{
							pos: position{line: 515, col: 7, offset: 16415},
							run: (*parser).callonAnchorLabel9,
							expr: &labeledExpr{
								pos:   position{line: 515, col: 7, offset: 16415},
								label: "arv",
								expr: &ruleRefExpr{
									pos:  position{line: 515, col: 11, offset: 16419},
									name: "AttributeReference",
								},
							},
						},
						&actionExpr{
							pos: position{line: 518, col: 8, offset: 16477},
							run: (*parser).callonAnchorLabel12,
							expr: &litMatcher{
								pos:        position{line: 518, col: 8, offset: 16477},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
						},
					},
				},
			},
		},
		{
			name: "Admonition",
			pos:  position{line: 524, col: 1, offset: 16539},
			expr: &actionExpr{
				pos: position{line: 524, col: 14, offset: 16552},
				run: (*parser).callonAdmonition1,
				expr: &seqExpr{
					pos: position{line: 524, col: 14, offset: 16552},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 524, col: 14, offset: 16552},
							name: "BeginningOfLine",
						},
						&labeledExpr{
							pos:   position{line: 524, col: 30, offset: 16568},
							label: "admonition",
							expr: &choiceExpr{
								pos: position{line: 525, col: 5, offset: 16585},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 525, col: 5, offset: 16585},
										run: (*parser).callonAdmonition6,
										expr: &litMatcher{
											pos:        position{line: 525, col: 5, offset: 16585},
											val:        "NOTE: ",
											ignoreCase: false,
											want:       "\"NOTE: \"",
										},
									},
									&actionExpr{
										pos: position{line: 526, col: 7, offset: 16668},
										run: (*parser).callonAdmonition8,
										expr: &litMatcher{
											pos:        position{line: 526, col: 7, offset: 16668},
											val:        "TIP: ",
											ignoreCase: false,
											want:       "\"TIP: \"",
										},
									},
									&actionExpr{
										pos: position{line: 527, col: 7, offset: 16749},
										run: (*parser).callonAdmonition10,
										expr: &litMatcher{
											pos:        position{line: 527, col: 7, offset: 16749},
											val:        "IMPORTANT: ",
											ignoreCase: false,
											want:       "\"IMPORTANT: \"",
										},
									},
									&actionExpr{
										pos: position{line: 528, col: 7, offset: 16842},
										run: (*parser).callonAdmonition12,
										expr: &litMatcher{
											pos:        position{line: 528, col: 7, offset: 16842},
											val:        "CAUTON: ",
											ignoreCase: false,
											want:       "\"CAUTON: \"",
										},
									},
									&actionExpr{
										pos: position{line: 529, col: 7, offset: 16930},
										run: (*parser).callonAdmonition14,
										expr: &litMatcher{
											pos:        position{line: 529, col: 7, offset: 16930},
											val:        "WARNING: ",
											ignoreCase: false,
											want:       "\"WARNING: \"",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineElements",
			pos:  position{line: 537, col: 1, offset: 17117},
			expr: &actionExpr{
				pos: position{line: 537, col: 18, offset: 17134},
				run: (*parser).callonInlineElements1,
				expr: &seqExpr{
					pos: position{line: 537, col: 18, offset: 17134},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 537, col: 18, offset: 17134},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 537, col: 26, offset: 17142},
								expr: &ruleRefExpr{
									pos:  position{line: 537, col: 27, offset: 17143},
									name: "InlineElement",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 537, col: 43, offset: 17159},
							label: "eol",
							expr: &ruleRefExpr{
								pos:  position{line: 537, col: 47, offset: 17163},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineElement",
			pos:  position{line: 546, col: 1, offset: 17378},
			expr: &actionExpr{
				pos: position{line: 546, col: 17, offset: 17394},
				run: (*parser).callonInlineElement1,
				expr: &labeledExpr{
					pos:   position{line: 546, col: 17, offset: 17394},
					label: "element",
					expr: &choiceExpr{
						pos: position{line: 547, col: 5, offset: 17408},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 547, col: 5, offset: 17408},
								name: "Admonition",
							},
							&ruleRefExpr{
								pos:  position{line: 548, col: 5, offset: 17425},
								name: "InlinePassthrough",
							},
							&ruleRefExpr{
								pos:  position{line: 549, col: 5, offset: 17449},
								name: "FormattedText",
							},
							&ruleRefExpr{
								pos:  position{line: 550, col: 5, offset: 17469},
								name: "Icon",
							},
							&ruleRefExpr{
								pos:  position{line: 551, col: 5, offset: 17481},
								name: "InlineImage",
							},
							&ruleRefExpr{
								pos:  position{line: 552, col: 5, offset: 17500},
								name: "Link",
							},
							&ruleRefExpr{
								pos:  position{line: 553, col: 5, offset: 17511},
								name: "Anchor",
							},
							&ruleRefExpr{
								pos:  position{line: 554, col: 5, offset: 17525},
								name: "CrossReference",
							},
							&ruleRefExpr{
								pos:  position{line: 555, col: 5, offset: 17547},
								name: "AttributeReference",
							},
							&ruleRefExpr{
								pos:  position{line: 556, col: 5, offset: 17572},
								name: "LineBreak",
							},
							&ruleRefExpr{
								pos:  position{line: 557, col: 5, offset: 17588},
								name: "NakedInlineText",
							},
							&ruleRefExpr{
								pos:  position{line: 558, col: 5, offset: 17610},
								name: "CharacterClassInline",
							},
						},
					},
				},
			},
		},
		{
			name: "NakedInlineText",
			pos:  position{line: 564, col: 1, offset: 17747},
			expr: &actionExpr{
				pos: position{line: 564, col: 19, offset: 17765},
				run: (*parser).callonNakedInlineText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 564, col: 19, offset: 17765},
					expr: &seqExpr{
						pos: position{line: 564, col: 20, offset: 17766},
						exprs: []any{
							&notExpr{
								pos: position{line: 564, col: 20, offset: 17766},
								expr: &ruleRefExpr{
									pos:  position{line: 564, col: 21, offset: 17767},
									name: "URLScheme",
								},
							},
							&notExpr{
								pos: position{line: 564, col: 31, offset: 17777},
								expr: &ruleRefExpr{
									pos:  position{line: 564, col: 32, offset: 17778},
									name: "InlineImageDelimiter",
								},
							},
							&charClassMatcher{
								pos:             position{line: 564, col: 53, offset: 17799},
								val:             "[A-Za-z ]",
								chars:           []rune{' '},
								ranges:          []rune{'A', 'Z', 'a', 'z'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
						},
					},
				},
			},
		},
		{
			name: "Footnote",
			pos:  position{line: 570, col: 1, offset: 17941},
			expr: &actionExpr{
				pos: position{line: 570, col: 12, offset: 17952},
				run: (*parser).callonFootnote1,
				expr: &seqExpr{
					pos: position{line: 570, col: 12, offset: 17952},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 570, col: 12, offset: 17952},
							val:        "footnote:",
							ignoreCase: false,
							want:       "\"footnote:\"",
						},
						&labeledExpr{
							pos:   position{line: 570, col: 24, offset: 17964},
							label: "id",
							expr: &zeroOrOneExpr{
								pos: position{line: 570, col: 27, offset: 17967},
								expr: &ruleRefExpr{
									pos:  position{line: 570, col: 28, offset: 17968},
									name: "FootnoteId",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 570, col: 41, offset: 17981},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 570, col: 45, offset: 17985},
							label: "value",
							expr: &zeroOrMoreExpr{
								pos: position{line: 570, col: 51, offset: 17991},
								expr: &ruleRefExpr{
									pos:  position{line: 570, col: 52, offset: 17992},
									name: "FootnoteValue",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 570, col: 68, offset: 18008},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "FootnoteId",
			pos:  position{line: 574, col: 1, offset: 18082},
			expr: &actionExpr{
				pos: position{line: 574, col: 14, offset: 18095},
				run: (*parser).callonFootnoteId1,
				expr: &oneOrMoreExpr{
					pos: position{line: 574, col: 14, offset: 18095},
					expr: &ruleRefExpr{
						pos:  position{line: 574, col: 14, offset: 18095},
						name: "Alphanumeric",
					},
				},
			},
		},
		{
			name: "FootnoteValue",
			pos:  position{line: 578, col: 1, offset: 18145},
			expr: &actionExpr{
				pos: position{line: 578, col: 17, offset: 18161},
				run: (*parser).callonFootnoteValue1,
				expr: &seqExpr{
					pos: position{line: 578, col: 17, offset: 18161},
					exprs: []any{
						&notExpr{
							pos: position{line: 578, col: 17, offset: 18161},
							expr: &litMatcher{
								pos:        position{line: 578, col: 18, offset: 18162},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 578, col: 22, offset: 18166},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 578, col: 32, offset: 18176},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 578, col: 32, offset: 18176},
										name: "InlineText",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 45, offset: 18189},
										name: "__",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 50, offset: 18194},
										name: "Apostrophe",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 63, offset: 18207},
										name: "Quote",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 71, offset: 18215},
										name: "Punctuation",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 85, offset: 18229},
										name: "Macro",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 93, offset: 18237},
										name: "LineBreak",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 105, offset: 18249},
										name: "AttributeReference",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 126, offset: 18270},
										name: "SpecialCharacter",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 145, offset: 18289},
										name: "EmptyLine",
									},
									&ruleRefExpr{
										pos:  position{line: 578, col: 157, offset: 18301},
										name: "CharacterClassInline",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "FormattedText",
			pos:  position{line: 583, col: 1, offset: 18353},
			expr: &actionExpr{
				pos: position{line: 583, col: 17, offset: 18369},
				run: (*parser).callonFormattedText1,
				expr: &seqExpr{
					pos: position{line: 583, col: 17, offset: 18369},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 583, col: 17, offset: 18369},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 583, col: 28, offset: 18380},
								expr: &ruleRefExpr{
									pos:  position{line: 583, col: 29, offset: 18381},
									name: "ShorthandAttributes",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 583, col: 52, offset: 18404},
							label: "text",
							expr: &choiceExpr{
								pos: position{line: 584, col: 5, offset: 18415},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 584, col: 5, offset: 18415},
										name: "BoldText",
									},
									&ruleRefExpr{
										pos:  position{line: 585, col: 7, offset: 18431},
										name: "ItalicText",
									},
									&ruleRefExpr{
										pos:  position{line: 586, col: 7, offset: 18449},
										name: "MonospaceText",
									},
									&ruleRefExpr{
										pos:  position{line: 587, col: 7, offset: 18470},
										name: "MarkedText",
									},
									&ruleRefExpr{
										pos:  position{line: 588, col: 7, offset: 18487},
										name: "SuperscriptText",
									},
									&ruleRefExpr{
										pos:  position{line: 589, col: 7, offset: 18509},
										name: "SubscriptText",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "FormattedTextElement",
			pos:  position{line: 594, col: 1, offset: 18658},
			expr: &choiceExpr{
				pos: position{line: 595, col: 5, offset: 18687},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 595, col: 5, offset: 18687},
						name: "InlineText",
					},
					&ruleRefExpr{
						pos:  position{line: 596, col: 5, offset: 18705},
						name: "__",
					},
					&ruleRefExpr{
						pos:  position{line: 597, col: 5, offset: 18715},
						name: "Apostrophe",
					},
					&ruleRefExpr{
						pos:  position{line: 598, col: 5, offset: 18733},
						name: "Punctuation",
					},
					&ruleRefExpr{
						pos:  position{line: 599, col: 5, offset: 18752},
						name: "AttributeReference",
					},
					&ruleRefExpr{
						pos:  position{line: 600, col: 5, offset: 18778},
						name: "FormattedText",
					},
					&ruleRefExpr{
						pos:  position{line: 601, col: 5, offset: 18799},
						name: "Icon",
					},
					&ruleRefExpr{
						pos:  position{line: 602, col: 5, offset: 18811},
						name: "InlineImage",
					},
					&ruleRefExpr{
						pos:  position{line: 603, col: 5, offset: 18830},
						name: "Link",
					},
					&ruleRefExpr{
						pos:  position{line: 604, col: 5, offset: 18841},
						name: "Anchor",
					},
					&ruleRefExpr{
						pos:  position{line: 605, col: 5, offset: 18855},
						name: "SpecialCharacter",
					},
					&ruleRefExpr{
						pos:  position{line: 606, col: 5, offset: 18879},
						name: "CharacterClassInline",
					},
				},
			},
		},
		{
			name: "FormatAttributes",
			pos:  position{line: 609, col: 1, offset: 18903},
			expr: &actionExpr{
				pos: position{line: 609, col: 20, offset: 18922},
				run: (*parser).callonFormatAttributes1,
				expr: &seqExpr{
					pos: position{line: 609, col: 20, offset: 18922},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 609, col: 20, offset: 18922},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 609, col: 24, offset: 18926},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 609, col: 36, offset: 18938},
								name: "ShorthandAttribute",
							},
						},
						&litMatcher{
							pos:        position{line: 609, col: 56, offset: 18958},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "BlockImage",
			pos:  position{line: 615, col: 1, offset: 19070},
			expr: &actionExpr{
				pos: position{line: 615, col: 14, offset: 19083},
				run: (*parser).callonBlockImage1,
				expr: &seqExpr{
					pos: position{line: 615, col: 14, offset: 19083},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 615, col: 14, offset: 19083},
							val:        "image::",
							ignoreCase: false,
							want:       "\"image::\"",
						},
						&labeledExpr{
							pos:   position{line: 615, col: 24, offset: 19093},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 615, col: 30, offset: 19099},
								name: "Path",
							},
						},
						&labeledExpr{
							pos:   position{line: 615, col: 36, offset: 19105},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 615, col: 48, offset: 19117},
								name: "InlineAttributes",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 615, col: 66, offset: 19135},
							expr: &ruleRefExpr{
								pos:  position{line: 615, col: 66, offset: 19135},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineImage",
			pos:  position{line: 619, col: 1, offset: 19260},
			expr: &actionExpr{
				pos: position{line: 619, col: 15, offset: 19274},
				run: (*parser).callonInlineImage1,
				expr: &seqExpr{
					pos: position{line: 619, col: 15, offset: 19274},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 619, col: 15, offset: 19274},
							name: "InlineImageDelimiter",
						},
						&notExpr{
							pos: position{line: 619, col: 36, offset: 19295},
							expr: &litMatcher{
								pos:        position{line: 619, col: 37, offset: 19296},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 619, col: 41, offset: 19300},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 619, col: 47, offset: 19306},
								name: "Path",
							},
						},
						&labeledExpr{
							pos:   position{line: 619, col: 53, offset: 19312},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 619, col: 65, offset: 19324},
								name: "InlineAttributes",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineImageDelimiter",
			pos:  position{line: 623, col: 1, offset: 19466},
			expr: &litMatcher{
				pos:        position{line: 623, col: 24, offset: 19489},
				val:        "image:",
				ignoreCase: false,
				want:       "\"image:\"",
			},
		},
		{
			name: "Icon",
			pos:  position{line: 627, col: 1, offset: 19501},
			expr: &actionExpr{
				pos: position{line: 627, col: 8, offset: 19508},
				run: (*parser).callonIcon1,
				expr: &seqExpr{
					pos: position{line: 627, col: 8, offset: 19508},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 627, col: 8, offset: 19508},
							val:        "icon:",
							ignoreCase: false,
							want:       "\"icon:\"",
						},
						&labeledExpr{
							pos:   position{line: 627, col: 16, offset: 19516},
							label: "path",
							expr: &actionExpr{
								pos: position{line: 627, col: 22, offset: 19522},
								run: (*parser).callonIcon5,
								expr: &oneOrMoreExpr{
									pos: position{line: 627, col: 22, offset: 19522},
									expr: &choiceExpr{
										pos: position{line: 627, col: 23, offset: 19523},
										alternatives: []any{
											&ruleRefExpr{
												pos:  position{line: 627, col: 23, offset: 19523},
												name: "Alphanumeric",
											},
											&litMatcher{
												pos:        position{line: 627, col: 38, offset: 19538},
												val:        "_",
												ignoreCase: false,
												want:       "\"_\"",
											},
											&litMatcher{
												pos:        position{line: 627, col: 44, offset: 19544},
												val:        "-",
												ignoreCase: false,
												want:       "\"-\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 627, col: 81, offset: 19581},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 627, col: 93, offset: 19593},
								name: "InlineAttributes",
							},
						},
					},
				},
			},
		},
		{
			name: "FileInclude",
			pos:  position{line: 632, col: 1, offset: 19715},
			expr: &actionExpr{
				pos: position{line: 632, col: 15, offset: 19729},
				run: (*parser).callonFileInclude1,
				expr: &seqExpr{
					pos: position{line: 632, col: 15, offset: 19729},
					exprs: []any{
						&notExpr{
							pos: position{line: 632, col: 15, offset: 19729},
							expr: &litMatcher{
								pos:        position{line: 632, col: 16, offset: 19730},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 632, col: 21, offset: 19735},
							val:        "include::",
							ignoreCase: false,
							want:       "\"include::\"",
						},
						&labeledExpr{
							pos:   position{line: 632, col: 33, offset: 19747},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 632, col: 39, offset: 19753},
								name: "FileIncludePath",
							},
						},
						&labeledExpr{
							pos:   position{line: 632, col: 56, offset: 19770},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 632, col: 68, offset: 19782},
								name: "InlineAttributes",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 632, col: 86, offset: 19800},
							expr: &ruleRefExpr{
								pos:  position{line: 632, col: 86, offset: 19800},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 632, col: 89, offset: 19803},
							expr: &ruleRefExpr{
								pos:  position{line: 632, col: 90, offset: 19804},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "FileIncludePath",
			pos:  position{line: 637, col: 1, offset: 19961},
			expr: &actionExpr{
				pos: position{line: 637, col: 19, offset: 19979},
				run: (*parser).callonFileIncludePath1,
				expr: &seqExpr{
					pos: position{line: 637, col: 19, offset: 19979},
					exprs: []any{
						&notExpr{
							pos: position{line: 637, col: 19, offset: 19979},
							expr: &ruleRefExpr{
								pos:  position{line: 637, col: 20, offset: 19980},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 637, col: 22, offset: 19982},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 637, col: 27, offset: 19987},
								name: "Path",
							},
						},
					},
				},
			},
		},
		{
			name: "Link",
			pos:  position{line: 644, col: 1, offset: 20021},
			expr: &actionExpr{
				pos: position{line: 644, col: 8, offset: 20028},
				run: (*parser).callonLink1,
				expr: &labeledExpr{
					pos:   position{line: 644, col: 8, offset: 20028},
					label: "link",
					expr: &choiceExpr{
						pos: position{line: 644, col: 14, offset: 20034},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 644, col: 14, offset: 20034},
								name: "HTMLLink",
							},
							&ruleRefExpr{
								pos:  position{line: 644, col: 25, offset: 20045},
								name: "PrefixedLink",
							},
							&ruleRefExpr{
								pos:  position{line: 644, col: 40, offset: 20060},
								name: "ExternalLink",
							},
							&ruleRefExpr{
								pos:  position{line: 644, col: 55, offset: 20075},
								name: "Email",
							},
						},
					},
				},
			},
		},
		{
			name: "HTMLLink",
			pos:  position{line: 649, col: 1, offset: 20151},
			expr: &actionExpr{
				pos: position{line: 649, col: 12, offset: 20162},
				run: (*parser).callonHTMLLink1,
				expr: &seqExpr{
					pos: position{line: 649, col: 12, offset: 20162},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 649, col: 12, offset: 20162},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
						&labeledExpr{
							pos:   position{line: 649, col: 16, offset: 20166},
							label: "url",
							expr: &ruleRefExpr{
								pos:  position{line: 649, col: 21, offset: 20171},
								name: "FullURL",
							},
						},
						&litMatcher{
							pos:        position{line: 649, col: 30, offset: 20180},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
					},
				},
			},
		},
		{
			name: "PrefixedLink",
			pos:  position{line: 654, col: 1, offset: 20286},
			expr: &actionExpr{
				pos: position{line: 654, col: 16, offset: 20301},
				run: (*parser).callonPrefixedLink1,
				expr: &seqExpr{
					pos: position{line: 654, col: 16, offset: 20301},
					exprs: []any{
						&notExpr{
							pos: position{line: 654, col: 16, offset: 20301},
							expr: &litMatcher{
								pos:        position{line: 654, col: 17, offset: 20302},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 654, col: 22, offset: 20307},
							val:        "link:",
							ignoreCase: false,
							want:       "\"link:\"",
						},
						&labeledExpr{
							pos:   position{line: 654, col: 30, offset: 20315},
							label: "url",
							expr: &ruleRefExpr{
								pos:  position{line: 654, col: 34, offset: 20319},
								name: "URL",
							},
						},
						&labeledExpr{
							pos:   position{line: 654, col: 38, offset: 20323},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 654, col: 50, offset: 20335},
								name: "InlineAttributes",
							},
						},
					},
				},
			},
		},
		{
			name: "ExternalLink",
			pos:  position{line: 660, col: 1, offset: 20502},
			expr: &actionExpr{
				pos: position{line: 660, col: 16, offset: 20517},
				run: (*parser).callonExternalLink1,
				expr: &seqExpr{
					pos: position{line: 660, col: 16, offset: 20517},
					exprs: []any{
						&notExpr{
							pos: position{line: 660, col: 16, offset: 20517},
							expr: &litMatcher{
								pos:        position{line: 660, col: 17, offset: 20518},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 660, col: 22, offset: 20523},
							label: "url",
							expr: &ruleRefExpr{
								pos:  position{line: 660, col: 27, offset: 20528},
								name: "FullURL",
							},
						},
						&labeledExpr{
							pos:   position{line: 660, col: 36, offset: 20537},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 660, col: 47, offset: 20548},
								expr: &ruleRefExpr{
									pos:  position{line: 660, col: 48, offset: 20549},
									name: "InlineAttributes",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Table",
			pos:  position{line: 667, col: 1, offset: 20726},
			expr: &actionExpr{
				pos: position{line: 667, col: 9, offset: 20734},
				run: (*parser).callonTable1,
				expr: &seqExpr{
					pos: position{line: 667, col: 9, offset: 20734},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 667, col: 9, offset: 20734},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 667, col: 20, offset: 20745},
								expr: &ruleRefExpr{
									pos:  position{line: 667, col: 21, offset: 20746},
									name: "BlockElementAttributes",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 667, col: 46, offset: 20771},
							name: "TableStart",
						},
						&labeledExpr{
							pos:   position{line: 667, col: 57, offset: 20782},
							label: "cells",
							expr: &ruleRefExpr{
								pos:  position{line: 667, col: 64, offset: 20789},
								name: "TableElements",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 667, col: 79, offset: 20804},
							name: "TableEnd",
						},
					},
				},
			},
		},
		{
			name: "TableElements",
			pos:  position{line: 677, col: 1, offset: 21115},
			expr: &actionExpr{
				pos: position{line: 677, col: 17, offset: 21131},
				run: (*parser).callonTableElements1,
				expr: &labeledExpr{
					pos:   position{line: 677, col: 17, offset: 21131},
					label: "te",
					expr: &zeroOrMoreExpr{
						pos: position{line: 677, col: 20, offset: 21134},
						expr: &ruleRefExpr{
							pos:  position{line: 677, col: 21, offset: 21135},
							name: "TableElement",
						},
					},
				},
			},
		},
		{
			name: "TableElement",
			pos:  position{line: 682, col: 1, offset: 21262},
			expr: &actionExpr{
				pos: position{line: 682, col: 16, offset: 21277},
				run: (*parser).callonTableElement1,
				expr: &labeledExpr{
					pos:   position{line: 682, col: 16, offset: 21277},
					label: "element",
					expr: &choiceExpr{
						pos: position{line: 683, col: 9, offset: 21295},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 683, col: 9, offset: 21295},
								name: "TableEmptyLine",
							},
							&ruleRefExpr{
								pos:  position{line: 684, col: 11, offset: 21321},
								name: "TableMacros",
							},
							&ruleRefExpr{
								pos:  position{line: 685, col: 11, offset: 21343},
								name: "TableRow",
							},
						},
					},
				},
			},
		},
		{
			name: "TableStart",
			pos:  position{line: 691, col: 1, offset: 21484},
			expr: &actionExpr{
				pos: position{line: 691, col: 14, offset: 21497},
				run: (*parser).callonTableStart1,
				expr: &seqExpr{
					pos: position{line: 691, col: 14, offset: 21497},
					exprs: []any{
						&notExpr{
							pos: position{line: 691, col: 14, offset: 21497},
							expr: &litMatcher{
								pos:        position{line: 691, col: 15, offset: 21498},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 691, col: 20, offset: 21503},
							val:        "|===",
							ignoreCase: false,
							want:       "\"|===\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 691, col: 27, offset: 21510},
							expr: &litMatcher{
								pos:        position{line: 691, col: 27, offset: 21510},
								val:        "=",
								ignoreCase: false,
								want:       "\"=\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 691, col: 32, offset: 21515},
							expr: &ruleRefExpr{
								pos:  position{line: 691, col: 32, offset: 21515},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 691, col: 35, offset: 21518},
							expr: &ruleRefExpr{
								pos:  position{line: 691, col: 36, offset: 21519},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "TableEmptyLine",
			pos:  position{line: 696, col: 1, offset: 21658},
			expr: &actionExpr{
				pos: position{line: 696, col: 18, offset: 21675},
				run: (*parser).callonTableEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 696, col: 18, offset: 21675},
					exprs: []any{
						&notExpr{
							pos: position{line: 696, col: 18, offset: 21675},
							expr: &ruleRefExpr{
								pos:  position{line: 696, col: 19, offset: 21676},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 696, col: 28, offset: 21685},
							name: "NewLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 696, col: 36, offset: 21693},
							expr: &ruleRefExpr{
								pos:  position{line: 696, col: 36, offset: 21693},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 696, col: 39, offset: 21696},
							expr: &ruleRefExpr{
								pos:  position{line: 696, col: 41, offset: 21698},
								name: "NewLine",
							},
						},
					},
				},
			},
		},
		{
			name: "TableMacros",
			pos:  position{line: 701, col: 1, offset: 21852},
			expr: &choiceExpr{
				pos: position{line: 701, col: 16, offset: 21867},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 701, col: 16, offset: 21867},
						name: "TableIfDef",
					},
					&ruleRefExpr{
						pos:  position{line: 701, col: 29, offset: 21880},
						name: "TableIfNDef",
					},
					&ruleRefExpr{
						pos:  position{line: 701, col: 43, offset: 21894},
						name: "TableEndIfDef",
					},
					&ruleRefExpr{
						pos:  position{line: 701, col: 59, offset: 21910},
						name: "TableComment",
					},
					&ruleRefExpr{
						pos:  position{line: 701, col: 74, offset: 21925},
						name: "TableMultiLineComment",
					},
				},
			},
		},
		{
			name: "TableIfDef",
			pos:  position{line: 703, col: 1, offset: 21949},
			expr: &actionExpr{
				pos: position{line: 703, col: 14, offset: 21962},
				run: (*parser).callonTableIfDef1,
				expr: &seqExpr{
					pos: position{line: 703, col: 14, offset: 21962},
					exprs: []any{
						&notExpr{
							pos: position{line: 703, col: 14, offset: 21962},
							expr: &ruleRefExpr{
								pos:  position{line: 703, col: 15, offset: 21963},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 703, col: 24, offset: 21972},
							name: "NewLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 703, col: 32, offset: 21980},
							expr: &ruleRefExpr{
								pos:  position{line: 703, col: 32, offset: 21980},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 703, col: 35, offset: 21983},
							label: "ifdef",
							expr: &ruleRefExpr{
								pos:  position{line: 703, col: 41, offset: 21989},
								name: "IfDef",
							},
						},
					},
				},
			},
		},
		{
			name: "TableIfNDef",
			pos:  position{line: 708, col: 1, offset: 22120},
			expr: &actionExpr{
				pos: position{line: 708, col: 15, offset: 22134},
				run: (*parser).callonTableIfNDef1,
				expr: &seqExpr{
					pos: position{line: 708, col: 15, offset: 22134},
					exprs: []any{
						&notExpr{
							pos: position{line: 708, col: 15, offset: 22134},
							expr: &ruleRefExpr{
								pos:  position{line: 708, col: 16, offset: 22135},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 708, col: 25, offset: 22144},
							name: "NewLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 708, col: 33, offset: 22152},
							expr: &ruleRefExpr{
								pos:  position{line: 708, col: 33, offset: 22152},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 708, col: 36, offset: 22155},
							label: "ifndef",
							expr: &ruleRefExpr{
								pos:  position{line: 708, col: 43, offset: 22162},
								name: "IfNDef",
							},
						},
					},
				},
			},
		},
		{
			name: "TableEndIfDef",
			pos:  position{line: 713, col: 1, offset: 22298},
			expr: &actionExpr{
				pos: position{line: 713, col: 17, offset: 22314},
				run: (*parser).callonTableEndIfDef1,
				expr: &seqExpr{
					pos: position{line: 713, col: 17, offset: 22314},
					exprs: []any{
						&notExpr{
							pos: position{line: 713, col: 17, offset: 22314},
							expr: &ruleRefExpr{
								pos:  position{line: 713, col: 18, offset: 22315},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 713, col: 27, offset: 22324},
							name: "NewLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 713, col: 35, offset: 22332},
							expr: &ruleRefExpr{
								pos:  position{line: 713, col: 35, offset: 22332},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 713, col: 38, offset: 22335},
							label: "endifdef",
							expr: &ruleRefExpr{
								pos:  position{line: 713, col: 47, offset: 22344},
								name: "EndIfDef",
							},
						},
					},
				},
			},
		},
		{
			name: "TableComment",
			pos:  position{line: 718, col: 1, offset: 22483},
			expr: &actionExpr{
				pos: position{line: 718, col: 16, offset: 22498},
				run: (*parser).callonTableComment1,
				expr: &seqExpr{
					pos: position{line: 718, col: 16, offset: 22498},
					exprs: []any{
						&notExpr{
							pos: position{line: 718, col: 16, offset: 22498},
							expr: &ruleRefExpr{
								pos:  position{line: 718, col: 17, offset: 22499},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 718, col: 26, offset: 22508},
							name: "NewLine",
						},
						&labeledExpr{
							pos:   position{line: 718, col: 34, offset: 22516},
							label: "comment",
							expr: &ruleRefExpr{
								pos:  position{line: 718, col: 43, offset: 22525},
								name: "SingleLineComment",
							},
						},
					},
				},
			},
		},
		{
			name: "TableMultiLineComment",
			pos:  position{line: 723, col: 1, offset: 22686},
			expr: &actionExpr{
				pos: position{line: 723, col: 25, offset: 22710},
				run: (*parser).callonTableMultiLineComment1,
				expr: &seqExpr{
					pos: position{line: 723, col: 25, offset: 22710},
					exprs: []any{
						&notExpr{
							pos: position{line: 723, col: 25, offset: 22710},
							expr: &ruleRefExpr{
								pos:  position{line: 723, col: 26, offset: 22711},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 723, col: 35, offset: 22720},
							name: "NewLine",
						},
						&labeledExpr{
							pos:   position{line: 723, col: 43, offset: 22728},
							label: "comment",
							expr: &ruleRefExpr{
								pos:  position{line: 723, col: 52, offset: 22737},
								name: "MultiLineComment",
							},
						},
					},
				},
			},
		},
		{
			name: "TableEmptyLines",
			pos:  position{line: 728, col: 1, offset: 22906},
			expr: &oneOrMoreExpr{
				pos: position{line: 728, col: 19, offset: 22924},
				expr: &ruleRefExpr{
					pos:  position{line: 728, col: 19, offset: 22924},
					name: "TableEmptyLine",
				},
			},
		},
		{
			name: "TableCellInlineContent",
			pos:  position{line: 730, col: 1, offset: 22941},
			expr: &actionExpr{
				pos: position{line: 730, col: 26, offset: 22966},
				run: (*parser).callonTableCellInlineContent1,
				expr: &seqExpr{
					pos: position{line: 730, col: 26, offset: 22966},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 730, col: 26, offset: 22966},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 730, col: 34, offset: 22974},
								expr: &ruleRefExpr{
									pos:  position{line: 730, col: 35, offset: 22975},
									name: "TableCellInlineContentElement",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 730, col: 67, offset: 23007},
							name: "EndOfFile",
						},
					},
				},
			},
		},
		{
			name: "TableCellInlineContentElement",
			pos:  position{line: 735, col: 1, offset: 23168},
			expr: &actionExpr{
				pos: position{line: 735, col: 33, offset: 23200},
				run: (*parser).callonTableCellInlineContentElement1,
				expr: &labeledExpr{
					pos:   position{line: 735, col: 33, offset: 23200},
					label: "element",
					expr: &choiceExpr{
						pos: position{line: 736, col: 5, offset: 23214},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 736, col: 5, offset: 23214},
								name: "FormattedText",
							},
							&ruleRefExpr{
								pos:  position{line: 737, col: 5, offset: 23234},
								name: "Icon",
							},
							&ruleRefExpr{
								pos:  position{line: 738, col: 5, offset: 23246},
								name: "InlineImage",
							},
							&ruleRefExpr{
								pos:  position{line: 739, col: 5, offset: 23265},
								name: "Link",
							},
							&ruleRefExpr{
								pos:  position{line: 740, col: 5, offset: 23276},
								name: "Anchor",
							},
							&ruleRefExpr{
								pos:  position{line: 741, col: 5, offset: 23291},
								name: "CrossReference",
							},
							&ruleRefExpr{
								pos:  position{line: 742, col: 5, offset: 23312},
								name: "AttributeReference",
							},
							&ruleRefExpr{
								pos:  position{line: 743, col: 5, offset: 23337},
								name: "LineBreak",
							},
							&ruleRefExpr{
								pos:  position{line: 744, col: 5, offset: 23353},
								name: "NakedInlineTableCellText",
							},
							&ruleRefExpr{
								pos:  position{line: 745, col: 5, offset: 23384},
								name: "CharacterClassInline",
							},
							&ruleRefExpr{
								pos:  position{line: 746, col: 5, offset: 23411},
								name: "NewLine",
							},
						},
					},
				},
			},
		},
		{
			name: "TableEnd",
			pos:  position{line: 752, col: 1, offset: 23534},
			expr: &actionExpr{
				pos: position{line: 752, col: 12, offset: 23545},
				run: (*parser).callonTableEnd1,
				expr: &seqExpr{
					pos: position{line: 752, col: 12, offset: 23545},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 752, col: 12, offset: 23545},
							name: "NewLine",
						},
						&notExpr{
							pos: position{line: 752, col: 20, offset: 23553},
							expr: &litMatcher{
								pos:        position{line: 752, col: 21, offset: 23554},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 752, col: 26, offset: 23559},
							val:        "|===",
							ignoreCase: false,
							want:       "\"|===\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 752, col: 33, offset: 23566},
							expr: &litMatcher{
								pos:        position{line: 752, col: 33, offset: 23566},
								val:        "=",
								ignoreCase: false,
								want:       "\"=\"",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 752, col: 38, offset: 23571},
							expr: &ruleRefExpr{
								pos:  position{line: 752, col: 38, offset: 23571},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 752, col: 41, offset: 23574},
							expr: &ruleRefExpr{
								pos:  position{line: 752, col: 42, offset: 23575},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "TableRow",
			pos:  position{line: 757, col: 1, offset: 23713},
			expr: &actionExpr{
				pos: position{line: 757, col: 12, offset: 23724},
				run: (*parser).callonTableRow1,
				expr: &seqExpr{
					pos: position{line: 757, col: 12, offset: 23724},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 757, col: 12, offset: 23724},
							label: "initial",
							expr: &ruleRefExpr{
								pos:  position{line: 757, col: 21, offset: 23733},
								name: "InitialInlineTableCell",
							},
						},
						&labeledExpr{
							pos:   position{line: 757, col: 46, offset: 23758},
							label: "additional",
							expr: &zeroOrMoreExpr{
								pos: position{line: 757, col: 57, offset: 23769},
								expr: &ruleRefExpr{
									pos:  position{line: 757, col: 58, offset: 23770},
									name: "AdditionalInlineTableCell",
								},
							},
						},
						&andExpr{
							pos: position{line: 757, col: 86, offset: 23798},
							expr: &choiceExpr{
								pos: position{line: 757, col: 88, offset: 23800},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 757, col: 88, offset: 23800},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 757, col: 99, offset: 23811},
										name: "TableCellDelimiter",
									},
									&ruleRefExpr{
										pos:  position{line: 757, col: 121, offset: 23833},
										name: "NewLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TableCellDelimiter",
			pos:  position{line: 767, col: 1, offset: 24147},
			expr: &choiceExpr{
				pos: position{line: 767, col: 23, offset: 24169},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 767, col: 23, offset: 24169},
						name: "AdditionalTableCellDelimiter",
					},
					&ruleRefExpr{
						pos:  position{line: 767, col: 54, offset: 24200},
						name: "InitialTableCellDelimiter",
					},
				},
			},
		},
		{
			name: "InitialInlineTableCell",
			pos:  position{line: 769, col: 1, offset: 24228},
			expr: &actionExpr{
				pos: position{line: 769, col: 26, offset: 24253},
				run: (*parser).callonInitialInlineTableCell1,
				expr: &seqExpr{
					pos: position{line: 769, col: 26, offset: 24253},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 769, col: 26, offset: 24253},
							label: "format",
							expr: &ruleRefExpr{
								pos:  position{line: 769, col: 34, offset: 24261},
								name: "InitialTableCellDelimiter",
							},
						},
						&labeledExpr{
							pos:   position{line: 769, col: 61, offset: 24288},
							label: "content",
							expr: &ruleRefExpr{
								pos:  position{line: 769, col: 70, offset: 24297},
								name: "InlineTableLines",
							},
						},
						&andExpr{
							pos: position{line: 769, col: 88, offset: 24315},
							expr: &choiceExpr{
								pos: position{line: 769, col: 90, offset: 24317},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 769, col: 90, offset: 24317},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 769, col: 101, offset: 24328},
										name: "TableEmptyLines",
									},
									&ruleRefExpr{
										pos:  position{line: 769, col: 119, offset: 24346},
										name: "TableMacros",
									},
									&ruleRefExpr{
										pos:  position{line: 769, col: 133, offset: 24360},
										name: "TableCellDelimiter",
									},
									&ruleRefExpr{
										pos:  position{line: 769, col: 155, offset: 24382},
										name: "NewLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AdditionalInlineTableCell",
			pos:  position{line: 775, col: 1, offset: 24615},
			expr: &actionExpr{
				pos: position{line: 775, col: 30, offset: 24644},
				run: (*parser).callonAdditionalInlineTableCell1,
				expr: &seqExpr{
					pos: position{line: 775, col: 30, offset: 24644},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 775, col: 30, offset: 24644},
							label: "format",
							expr: &ruleRefExpr{
								pos:  position{line: 775, col: 38, offset: 24652},
								name: "AdditionalTableCellDelimiter",
							},
						},
						&labeledExpr{
							pos:   position{line: 775, col: 68, offset: 24682},
							label: "content",
							expr: &ruleRefExpr{
								pos:  position{line: 775, col: 77, offset: 24691},
								name: "InlineTableLines",
							},
						},
						&andExpr{
							pos: position{line: 775, col: 95, offset: 24709},
							expr: &choiceExpr{
								pos: position{line: 775, col: 97, offset: 24711},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 775, col: 97, offset: 24711},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 775, col: 108, offset: 24722},
										name: "TableEmptyLines",
									},
									&ruleRefExpr{
										pos:  position{line: 775, col: 126, offset: 24740},
										name: "TableMacros",
									},
									&ruleRefExpr{
										pos:  position{line: 775, col: 140, offset: 24754},
										name: "TableCellDelimiter",
									},
									&ruleRefExpr{
										pos:  position{line: 775, col: 162, offset: 24776},
										name: "NewLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InitialBlockTableCell",
			pos:  position{line: 780, col: 1, offset: 25007},
			expr: &actionExpr{
				pos: position{line: 780, col: 25, offset: 25031},
				run: (*parser).callonInitialBlockTableCell1,
				expr: &seqExpr{
					pos: position{line: 780, col: 25, offset: 25031},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 780, col: 25, offset: 25031},
							label: "format",
							expr: &ruleRefExpr{
								pos:  position{line: 780, col: 33, offset: 25039},
								name: "InitialTableCellDelimiter",
							},
						},
						&labeledExpr{
							pos:   position{line: 780, col: 60, offset: 25066},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 780, col: 68, offset: 25074},
								expr: &choiceExpr{
									pos: position{line: 780, col: 69, offset: 25075},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 780, col: 69, offset: 25075},
											name: "BlockTableElement",
										},
										&ruleRefExpr{
											pos:  position{line: 780, col: 89, offset: 25095},
											name: "InlineTableElements",
										},
									},
								},
							},
						},
						&andExpr{
							pos: position{line: 780, col: 111, offset: 25117},
							expr: &choiceExpr{
								pos: position{line: 780, col: 113, offset: 25119},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 780, col: 113, offset: 25119},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 780, col: 124, offset: 25130},
										name: "TableEmptyLines",
									},
									&ruleRefExpr{
										pos:  position{line: 780, col: 142, offset: 25148},
										name: "TableMacros",
									},
									&ruleRefExpr{
										pos:  position{line: 780, col: 156, offset: 25162},
										name: "TableCellDelimiter",
									},
									&ruleRefExpr{
										pos:  position{line: 780, col: 178, offset: 25184},
										name: "NewLine",
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 780, col: 189, offset: 25195},
							run: (*parser).callonInitialBlockTableCell17,
						},
					},
				},
			},
		},
		{
			name: "AdditionalBlockTableCell",
			pos:  position{line: 789, col: 1, offset: 25643},
			expr: &actionExpr{
				pos: position{line: 789, col: 28, offset: 25670},
				run: (*parser).callonAdditionalBlockTableCell1,
				expr: &seqExpr{
					pos: position{line: 789, col: 28, offset: 25670},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 789, col: 28, offset: 25670},
							label: "format",
							expr: &ruleRefExpr{
								pos:  position{line: 789, col: 36, offset: 25678},
								name: "AdditionalTableCellDelimiter",
							},
						},
						&labeledExpr{
							pos:   position{line: 789, col: 66, offset: 25708},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 789, col: 74, offset: 25716},
								expr: &choiceExpr{
									pos: position{line: 789, col: 75, offset: 25717},
									alternatives: []any{
										&ruleRefExpr{
											pos:  position{line: 789, col: 75, offset: 25717},
											name: "BlockTableElement",
										},
										&ruleRefExpr{
											pos:  position{line: 789, col: 95, offset: 25737},
											name: "InlineTableElements",
										},
									},
								},
							},
						},
						&andExpr{
							pos: position{line: 789, col: 117, offset: 25759},
							expr: &choiceExpr{
								pos: position{line: 789, col: 119, offset: 25761},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 789, col: 119, offset: 25761},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 789, col: 130, offset: 25772},
										name: "TableEmptyLines",
									},
									&ruleRefExpr{
										pos:  position{line: 789, col: 148, offset: 25790},
										name: "TableMacros",
									},
									&ruleRefExpr{
										pos:  position{line: 789, col: 162, offset: 25804},
										name: "TableCellDelimiter",
									},
									&ruleRefExpr{
										pos:  position{line: 789, col: 184, offset: 25826},
										name: "NewLine",
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 789, col: 195, offset: 25837},
							run: (*parser).callonAdditionalBlockTableCell17,
						},
					},
				},
			},
		},
		{
			name: "InlineTableLines",
			pos:  position{line: 798, col: 1, offset: 26305},
			expr: &actionExpr{
				pos: position{line: 798, col: 20, offset: 26324},
				run: (*parser).callonInlineTableLines1,
				expr: &labeledExpr{
					pos:   position{line: 798, col: 20, offset: 26324},
					label: "content",
					expr: &choiceExpr{
						pos: position{line: 798, col: 29, offset: 26333},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 798, col: 29, offset: 26333},
								name: "MultiLineTableCell",
							},
							&ruleRefExpr{
								pos:  position{line: 798, col: 50, offset: 26354},
								name: "InlineTableElements",
							},
							&ruleRefExpr{
								pos:  position{line: 798, col: 72, offset: 26376},
								name: "EmptyCell",
							},
						},
					},
				},
			},
		},
		{
			name: "EmptyCell",
			pos:  position{line: 803, col: 1, offset: 26513},
			expr: &actionExpr{
				pos: position{line: 803, col: 13, offset: 26525},
				run: (*parser).callonEmptyCell1,
				expr: &andExpr{
					pos: position{line: 803, col: 13, offset: 26525},
					expr: &choiceExpr{
						pos: position{line: 803, col: 15, offset: 26527},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 803, col: 15, offset: 26527},
								name: "TableEnd",
							},
							&ruleRefExpr{
								pos:  position{line: 803, col: 26, offset: 26538},
								name: "TableCellDelimiter",
							},
							&ruleRefExpr{
								pos:  position{line: 803, col: 48, offset: 26560},
								name: "NewLine",
							},
						},
					},
				},
			},
		},
		{
			name: "ValidTableCellPrefix",
			pos:  position{line: 808, col: 1, offset: 26707},
			expr: &seqExpr{
				pos: position{line: 808, col: 24, offset: 26730},
				exprs: []any{
					&notExpr{
						pos: position{line: 808, col: 24, offset: 26730},
						expr: &ruleRefExpr{
							pos:  position{line: 808, col: 25, offset: 26731},
							name: "TableEnd",
						},
					},
					&notExpr{
						pos: position{line: 808, col: 34, offset: 26740},
						expr: &ruleRefExpr{
							pos:  position{line: 808, col: 35, offset: 26741},
							name: "TableCellDelimiter",
						},
					},
				},
			},
		},
		{
			name: "ValidMultilineTableCellPrefix",
			pos:  position{line: 810, col: 1, offset: 26762},
			expr: &seqExpr{
				pos: position{line: 810, col: 33, offset: 26794},
				exprs: []any{
					&notExpr{
						pos: position{line: 810, col: 33, offset: 26794},
						expr: &ruleRefExpr{
							pos:  position{line: 810, col: 34, offset: 26795},
							name: "MultiLineComment",
						},
					},
					&notExpr{
						pos: position{line: 810, col: 51, offset: 26812},
						expr: &ruleRefExpr{
							pos:  position{line: 810, col: 52, offset: 26813},
							name: "SingleLineComment",
						},
					},
				},
			},
		},
		{
			name: "MultiLineTableCell",
			pos:  position{line: 812, col: 1, offset: 26832},
			expr: &actionExpr{
				pos: position{line: 812, col: 22, offset: 26853},
				run: (*parser).callonMultiLineTableCell1,
				expr: &seqExpr{
					pos: position{line: 812, col: 22, offset: 26853},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 812, col: 22, offset: 26853},
							label: "lines",
							expr: &oneOrMoreExpr{
								pos: position{line: 812, col: 28, offset: 26859},
								expr: &ruleRefExpr{
									pos:  position{line: 812, col: 29, offset: 26860},
									name: "InlineTableCellLine",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 812, col: 51, offset: 26882},
							label: "content",
							expr: &ruleRefExpr{
								pos:  position{line: 812, col: 60, offset: 26891},
								name: "InlineTableCellLastLine",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellLine",
			pos:  position{line: 824, col: 1, offset: 27419},
			expr: &choiceExpr{
				pos: position{line: 824, col: 23, offset: 27441},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 824, col: 23, offset: 27441},
						name: "InlineTableCellEmptyLine",
					},
					&ruleRefExpr{
						pos:  position{line: 824, col: 50, offset: 27468},
						name: "InlineTableCellIntermediateLine",
					},
				},
			},
		},
		{
			name: "InlineTableCellIntermediateLine",
			pos:  position{line: 826, col: 1, offset: 27502},
			expr: &actionExpr{
				pos: position{line: 826, col: 35, offset: 27536},
				run: (*parser).callonInlineTableCellIntermediateLine1,
				expr: &seqExpr{
					pos: position{line: 826, col: 35, offset: 27536},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 826, col: 35, offset: 27536},
							name: "ValidTableCellPrefix",
						},
						&labeledExpr{
							pos:   position{line: 826, col: 56, offset: 27557},
							label: "newline",
							expr: &zeroOrOneExpr{
								pos: position{line: 826, col: 64, offset: 27565},
								expr: &ruleRefExpr{
									pos:  position{line: 826, col: 64, offset: 27565},
									name: "NewLine",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 826, col: 73, offset: 27574},
							name: "ValidMultilineTableCellPrefix",
						},
						&labeledExpr{
							pos:   position{line: 826, col: 103, offset: 27604},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 826, col: 111, offset: 27612},
								expr: &ruleRefExpr{
									pos:  position{line: 826, col: 112, offset: 27613},
									name: "InlineTableElement",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 826, col: 133, offset: 27634},
							label: "newlineBeforeEmptyLine",
							expr: &zeroOrOneExpr{
								pos: position{line: 826, col: 156, offset: 27657},
								expr: &actionExpr{
									pos: position{line: 826, col: 157, offset: 27658},
									run: (*parser).callonInlineTableCellIntermediateLine13,
									expr: &seqExpr{
										pos: position{line: 826, col: 157, offset: 27658},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 826, col: 157, offset: 27658},
												label: "nl",
												expr: &ruleRefExpr{
													pos:  position{line: 826, col: 160, offset: 27661},
													name: "NewLine",
												},
											},
											&zeroOrMoreExpr{
												pos: position{line: 826, col: 168, offset: 27669},
												expr: &ruleRefExpr{
													pos:  position{line: 826, col: 168, offset: 27669},
													name: "_",
												},
											},
											&andExpr{
												pos: position{line: 826, col: 171, offset: 27672},
												expr: &ruleRefExpr{
													pos:  position{line: 826, col: 173, offset: 27674},
													name: "NewLine",
												},
											},
										},
									},
								},
							},
						},
						&andExpr{
							pos: position{line: 826, col: 202, offset: 27703},
							expr: &ruleRefExpr{
								pos:  position{line: 826, col: 203, offset: 27704},
								name: "NewLine",
							},
						},
						&notExpr{
							pos: position{line: 826, col: 211, offset: 27712},
							expr: &choiceExpr{
								pos: position{line: 826, col: 213, offset: 27714},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 826, col: 213, offset: 27714},
										name: "TableMacros",
									},
									&ruleRefExpr{
										pos:  position{line: 826, col: 227, offset: 27728},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 826, col: 238, offset: 27739},
										name: "TableCellDelimiter",
									},
								},
							},
						},
						&andExpr{
							pos: position{line: 826, col: 260, offset: 27761},
							expr: &choiceExpr{
								pos: position{line: 826, col: 262, offset: 27763},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 826, col: 262, offset: 27763},
										name: "InlineTableCellLine",
									},
									&ruleRefExpr{
										pos:  position{line: 826, col: 284, offset: 27785},
										name: "InlineTableCellLastLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellEmptyLine",
			pos:  position{line: 840, col: 1, offset: 28263},
			expr: &actionExpr{
				pos: position{line: 840, col: 28, offset: 28290},
				run: (*parser).callonInlineTableCellEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 840, col: 28, offset: 28290},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 840, col: 28, offset: 28290},
							name: "ValidTableCellPrefix",
						},
						&ruleRefExpr{
							pos:  position{line: 840, col: 49, offset: 28311},
							name: "NewLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 840, col: 57, offset: 28319},
							expr: &ruleRefExpr{
								pos:  position{line: 840, col: 57, offset: 28319},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 840, col: 60, offset: 28322},
							expr: &ruleRefExpr{
								pos:  position{line: 840, col: 62, offset: 28324},
								name: "NewLine",
							},
						},
						&notExpr{
							pos: position{line: 840, col: 71, offset: 28333},
							expr: &ruleRefExpr{
								pos:  position{line: 840, col: 72, offset: 28334},
								name: "TableEnd",
							},
						},
						&notExpr{
							pos: position{line: 840, col: 81, offset: 28343},
							expr: &ruleRefExpr{
								pos:  position{line: 840, col: 82, offset: 28344},
								name: "TableCellDelimiter",
							},
						},
						&notExpr{
							pos: position{line: 840, col: 101, offset: 28363},
							expr: &ruleRefExpr{
								pos:  position{line: 840, col: 102, offset: 28364},
								name: "TableMacros",
							},
						},
						&andExpr{
							pos: position{line: 840, col: 114, offset: 28376},
							expr: &choiceExpr{
								pos: position{line: 840, col: 116, offset: 28378},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 840, col: 116, offset: 28378},
										name: "InlineTableCellLine",
									},
									&ruleRefExpr{
										pos:  position{line: 840, col: 138, offset: 28400},
										name: "InlineTableCellLastLine",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellLastLine",
			pos:  position{line: 846, col: 1, offset: 28586},
			expr: &actionExpr{
				pos: position{line: 846, col: 27, offset: 28612},
				run: (*parser).callonInlineTableCellLastLine1,
				expr: &seqExpr{
					pos: position{line: 846, col: 27, offset: 28612},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 846, col: 27, offset: 28612},
							name: "ValidTableCellPrefix",
						},
						&labeledExpr{
							pos:   position{line: 846, col: 48, offset: 28633},
							label: "nl",
							expr: &ruleRefExpr{
								pos:  position{line: 846, col: 51, offset: 28636},
								name: "NewLine",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 846, col: 59, offset: 28644},
							name: "ValidMultilineTableCellPrefix",
						},
						&labeledExpr{
							pos:   position{line: 846, col: 89, offset: 28674},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 846, col: 97, offset: 28682},
								expr: &ruleRefExpr{
									pos:  position{line: 846, col: 98, offset: 28683},
									name: "InlineTableElement",
								},
							},
						},
						&andExpr{
							pos: position{line: 846, col: 119, offset: 28704},
							expr: &choiceExpr{
								pos: position{line: 846, col: 121, offset: 28706},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 846, col: 121, offset: 28706},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 846, col: 132, offset: 28717},
										name: "TableEmptyLines",
									},
									&ruleRefExpr{
										pos:  position{line: 846, col: 150, offset: 28735},
										name: "TableMacros",
									},
									&ruleRefExpr{
										pos:  position{line: 846, col: 164, offset: 28749},
										name: "TableCellDelimiter",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTableCellLine",
			pos:  position{line: 854, col: 1, offset: 29032},
			expr: &actionExpr{
				pos: position{line: 854, col: 22, offset: 29053},
				run: (*parser).callonBlockTableCellLine1,
				expr: &labeledExpr{
					pos:   position{line: 854, col: 22, offset: 29053},
					label: "content",
					expr: &choiceExpr{
						pos: position{line: 854, col: 31, offset: 29062},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 854, col: 31, offset: 29062},
								name: "BlockTableElement",
							},
							&ruleRefExpr{
								pos:  position{line: 854, col: 51, offset: 29082},
								name: "InlineTableCellIntermediateLine",
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTableCellLastLine",
			pos:  position{line: 859, col: 1, offset: 29223},
			expr: &actionExpr{
				pos: position{line: 859, col: 26, offset: 29248},
				run: (*parser).callonBlockTableCellLastLine1,
				expr: &seqExpr{
					pos: position{line: 859, col: 26, offset: 29248},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 859, col: 26, offset: 29248},
							name: "ValidTableCellPrefix",
						},
						&ruleRefExpr{
							pos:  position{line: 859, col: 47, offset: 29269},
							name: "NewLine",
						},
						&labeledExpr{
							pos:   position{line: 859, col: 55, offset: 29277},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 859, col: 63, offset: 29285},
								expr: &ruleRefExpr{
									pos:  position{line: 859, col: 64, offset: 29286},
									name: "InlineTableElement",
								},
							},
						},
						&andExpr{
							pos: position{line: 859, col: 85, offset: 29307},
							expr: &choiceExpr{
								pos: position{line: 859, col: 87, offset: 29309},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 859, col: 87, offset: 29309},
										name: "TableEnd",
									},
									&ruleRefExpr{
										pos:  position{line: 859, col: 98, offset: 29320},
										name: "TableCellDelimiter",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableElements",
			pos:  position{line: 865, col: 1, offset: 29516},
			expr: &actionExpr{
				pos: position{line: 865, col: 23, offset: 29538},
				run: (*parser).callonInlineTableElements1,
				expr: &seqExpr{
					pos: position{line: 865, col: 23, offset: 29538},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 865, col: 23, offset: 29538},
							name: "ValidTableCellPrefix",
						},
						&labeledExpr{
							pos:   position{line: 865, col: 44, offset: 29559},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 865, col: 52, offset: 29567},
								expr: &ruleRefExpr{
									pos:  position{line: 865, col: 53, offset: 29568},
									name: "InlineTableElement",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableElement",
			pos:  position{line: 871, col: 1, offset: 29759},
			expr: &actionExpr{
				pos: position{line: 871, col: 22, offset: 29780},
				run: (*parser).callonInlineTableElement1,
				expr: &seqExpr{
					pos: position{line: 871, col: 22, offset: 29780},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 871, col: 22, offset: 29780},
							name: "ValidTableCellPrefix",
						},
						&labeledExpr{
							pos:   position{line: 871, col: 44, offset: 29802},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 872, col: 5, offset: 29816},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 872, col: 5, offset: 29816},
										name: "NakedInlineTableCellText",
									},
									&ruleRefExpr{
										pos:  position{line: 873, col: 5, offset: 29847},
										name: "CharacterClassTableCell",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTableElement",
			pos:  position{line: 879, col: 1, offset: 29986},
			expr: &actionExpr{
				pos: position{line: 879, col: 21, offset: 30006},
				run: (*parser).callonBlockTableElement1,
				expr: &seqExpr{
					pos: position{line: 879, col: 21, offset: 30006},
					exprs: []any{
						&notExpr{
							pos: position{line: 879, col: 21, offset: 30006},
							expr: &ruleRefExpr{
								pos:  position{line: 879, col: 22, offset: 30007},
								name: "InitialTableCellDelimiter",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 879, col: 48, offset: 30033},
							expr: &ruleRefExpr{
								pos:  position{line: 879, col: 48, offset: 30033},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 879, col: 52, offset: 30037},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 879, col: 61, offset: 30046},
								name: "BlockElement",
							},
						},
						&notExpr{
							pos: position{line: 879, col: 75, offset: 30060},
							expr: &ruleRefExpr{
								pos:  position{line: 879, col: 76, offset: 30061},
								name: "TableCellDelimiter",
							},
						},
						&notExpr{
							pos: position{line: 879, col: 96, offset: 30081},
							expr: &ruleRefExpr{
								pos:  position{line: 879, col: 97, offset: 30082},
								name: "TableEnd",
							},
						},
					},
				},
			},
		},
		{
			name: "NakedInlineTableCellText",
			pos:  position{line: 885, col: 1, offset: 30208},
			expr: &actionExpr{
				pos: position{line: 885, col: 28, offset: 30235},
				run: (*parser).callonNakedInlineTableCellText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 885, col: 28, offset: 30235},
					expr: &seqExpr{
						pos: position{line: 885, col: 29, offset: 30236},
						exprs: []any{
							&charClassMatcher{
								pos:             position{line: 885, col: 29, offset: 30236},
								val:             "[A-Za-z ]",
								chars:           []rune{' '},
								ranges:          []rune{'A', 'Z', 'a', 'z'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
							&notExpr{
								pos: position{line: 885, col: 39, offset: 30246},
								expr: &ruleRefExpr{
									pos:  position{line: 885, col: 40, offset: 30247},
									name: "TableCellDelimiter",
								},
							},
							&notExpr{
								pos: position{line: 885, col: 59, offset: 30266},
								expr: &ruleRefExpr{
									pos:  position{line: 885, col: 60, offset: 30267},
									name: "TableEnd",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CharacterClassTableCell",
			pos:  position{line: 890, col: 1, offset: 30425},
			expr: &actionExpr{
				pos: position{line: 890, col: 27, offset: 30451},
				run: (*parser).callonCharacterClassTableCell1,
				expr: &choiceExpr{
					pos: position{line: 890, col: 28, offset: 30452},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 890, col: 28, offset: 30452},
							val:        "\\|",
							ignoreCase: false,
							want:       "\"\\\\|\"",
						},
						&charClassMatcher{
							pos:             position{line: 890, col: 36, offset: 30460},
							val:             "[^|\\r\\n]",
							chars:           []rune{'|', '\r', '\n'},
							basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false},
							ignoreCase:      false,
							inverted:        true,
						},
					},
				},
			},
		},
		{
			name: "InitialTableCellDelimiter",
			pos:  position{line: 896, col: 1, offset: 30661},
			expr: &actionExpr{
				pos: position{line: 896, col: 29, offset: 30689},
				run: (*parser).callonInitialTableCellDelimiter1,
				expr: &seqExpr{
					pos: position{line: 896, col: 29, offset: 30689},
					exprs: []any{
						&notExpr{
							pos: position{line: 896, col: 29, offset: 30689},
							expr: &ruleRefExpr{
								pos:  position{line: 896, col: 30, offset: 30690},
								name: "TableEnd",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 896, col: 39, offset: 30699},
							name: "NewLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 896, col: 47, offset: 30707},
							expr: &ruleRefExpr{
								pos:  position{line: 896, col: 47, offset: 30707},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 896, col: 50, offset: 30710},
							label: "format",
							expr: &zeroOrOneExpr{
								pos: position{line: 896, col: 57, offset: 30717},
								expr: &ruleRefExpr{
									pos:  position{line: 896, col: 58, offset: 30718},
									name: "TableCellFormat",
								},
							},
						},
						&notExpr{
							pos: position{line: 896, col: 76, offset: 30736},
							expr: &litMatcher{
								pos:        position{line: 896, col: 77, offset: 30737},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 896, col: 82, offset: 30742},
							val:        "|",
							ignoreCase: false,
							want:       "\"|\"",
						},
					},
				},
			},
		},
		{
			name: "AdditionalTableCellDelimiter",
			pos:  position{line: 904, col: 1, offset: 30943},
			expr: &actionExpr{
				pos: position{line: 904, col: 32, offset: 30974},
				run: (*parser).callonAdditionalTableCellDelimiter1,
				expr: &seqExpr{
					pos: position{line: 904, col: 32, offset: 30974},
					exprs: []any{
						&notExpr{
							pos: position{line: 904, col: 32, offset: 30974},
							expr: &ruleRefExpr{
								pos:  position{line: 904, col: 33, offset: 30975},
								name: "TableEnd",
							},
						},
						&labeledExpr{
							pos:   position{line: 904, col: 42, offset: 30984},
							label: "format",
							expr: &zeroOrOneExpr{
								pos: position{line: 904, col: 49, offset: 30991},
								expr: &ruleRefExpr{
									pos:  position{line: 904, col: 50, offset: 30992},
									name: "AdditionalTableCellFormat",
								},
							},
						},
						&notExpr{
							pos: position{line: 904, col: 78, offset: 31020},
							expr: &litMatcher{
								pos:        position{line: 904, col: 79, offset: 31021},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 904, col: 84, offset: 31026},
							val:        "|",
							ignoreCase: false,
							want:       "\"|\"",
						},
					},
				},
			},
		},
		{
			name: "InitialTableCellFormat",
			pos:  position{line: 910, col: 1, offset: 31241},
			expr: &actionExpr{
				pos: position{line: 910, col: 26, offset: 31266},
				run: (*parser).callonInitialTableCellFormat1,
				expr: &seqExpr{
					pos: position{line: 910, col: 26, offset: 31266},
					exprs: []any{
						&zeroOrMoreExpr{
							pos: position{line: 910, col: 26, offset: 31266},
							expr: &ruleRefExpr{
								pos:  position{line: 910, col: 26, offset: 31266},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 910, col: 29, offset: 31269},
							label: "format",
							expr: &ruleRefExpr{
								pos:  position{line: 910, col: 37, offset: 31277},
								name: "TableCellFormat",
							},
						},
						&andCodeExpr{
							pos: position{line: 910, col: 54, offset: 31294},
							run: (*parser).callonInitialTableCellFormat7,
						},
					},
				},
			},
		},
		{
			name: "AdditionalTableCellFormat",
			pos:  position{line: 919, col: 1, offset: 31593},
			expr: &actionExpr{
				pos: position{line: 919, col: 29, offset: 31621},
				run: (*parser).callonAdditionalTableCellFormat1,
				expr: &seqExpr{
					pos: position{line: 919, col: 29, offset: 31621},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 919, col: 29, offset: 31621},
							label: "lead",
							expr: &oneOrMoreExpr{
								pos: position{line: 919, col: 35, offset: 31627},
								expr: &ruleRefExpr{
									pos:  position{line: 919, col: 35, offset: 31627},
									name: "_",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 919, col: 39, offset: 31631},
							label: "format",
							expr: &ruleRefExpr{
								pos:  position{line: 919, col: 47, offset: 31639},
								name: "TableCellFormat",
							},
						},
						&andCodeExpr{
							pos: position{line: 919, col: 64, offset: 31656},
							run: (*parser).callonAdditionalTableCellFormat8,
						},
					},
				},
			},
		},
		{
			name: "TableCellSpan",
			pos:  position{line: 927, col: 1, offset: 31899},
			expr: &actionExpr{
				pos: position{line: 927, col: 17, offset: 31915},
				run: (*parser).callonTableCellSpan1,
				expr: &seqExpr{
					pos: position{line: 927, col: 17, offset: 31915},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 927, col: 17, offset: 31915},
							label: "column",
							expr: &zeroOrOneExpr{
								pos: position{line: 927, col: 24, offset: 31922},
								expr: &actionExpr{
									pos: position{line: 927, col: 25, offset: 31923},
									run: (*parser).callonTableCellSpan5,
									expr: &labeledExpr{
										pos:   position{line: 927, col: 25, offset: 31923},
										label: "n",
										expr: &ruleRefExpr{
											pos:  position{line: 927, col: 27, offset: 31925},
											name: "PositiveInteger",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 930, col: 12, offset: 32061},
							label: "row",
							expr: &zeroOrOneExpr{
								pos: position{line: 930, col: 17, offset: 32066},
								expr: &actionExpr{
									pos: position{line: 930, col: 18, offset: 32067},
									run: (*parser).callonTableCellSpan10,
									expr: &seqExpr{
										pos: position{line: 930, col: 18, offset: 32067},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 930, col: 18, offset: 32067},
												val:        ".",
												ignoreCase: false,
												want:       "\".\"",
											},
											&labeledExpr{
												pos:   position{line: 930, col: 22, offset: 32071},
												label: "n",
												expr: &ruleRefExpr{
													pos:  position{line: 930, col: 24, offset: 32073},
													name: "PositiveInteger",
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 934, col: 11, offset: 32216},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
					},
				},
			},
		},
		{
			name: "TableCellFormat",
			pos:  position{line: 942, col: 1, offset: 32454},
			expr: &actionExpr{
				pos: position{line: 943, col: 5, offset: 32478},
				run: (*parser).callonTableCellFormat1,
				expr: &seqExpr{
					pos: position{line: 943, col: 5, offset: 32478},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 943, col: 5, offset: 32478},
							label: "multiplier",
							expr: &zeroOrOneExpr{
								pos: position{line: 943, col: 16, offset: 32489},
								expr: &actionExpr{
									pos: position{line: 944, col: 9, offset: 32499},
									run: (*parser).callonTableCellFormat5,
									expr: &seqExpr{
										pos: position{line: 944, col: 9, offset: 32499},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 944, col: 9, offset: 32499},
												label: "multiplier",
												expr: &actionExpr{
													pos: position{line: 944, col: 21, offset: 32511},
													run: (*parser).callonTableCellFormat8,
													expr: &seqExpr{
														pos: position{line: 944, col: 21, offset: 32511},
														exprs: []any{
															&charClassMatcher{
																pos:             position{line: 944, col: 21, offset: 32511},
																val:             "[1-9]",
																ranges:          []rune{'1', '9'},
																basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
																ignoreCase:      false,
																inverted:        false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 944, col: 26, offset: 32516},
																expr: &charClassMatcher{
																	pos:             position{line: 944, col: 26, offset: 32516},
																	val:             "[0-9]",
																	ranges:          []rune{'0', '9'},
																	basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
																	ignoreCase:      false,
																	inverted:        false,
																},
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 944, col: 63, offset: 32553},
												val:        "*",
												ignoreCase: false,
												want:       "\"*\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 948, col: 5, offset: 32635},
							label: "span",
							expr: &zeroOrOneExpr{
								pos: position{line: 948, col: 10, offset: 32640},
								expr: &actionExpr{
									pos: position{line: 949, col: 9, offset: 32650},
									run: (*parser).callonTableCellFormat16,
									expr: &labeledExpr{
										pos:   position{line: 949, col: 9, offset: 32650},
										label: "span",
										expr: &ruleRefExpr{
											pos:  position{line: 949, col: 15, offset: 32656},
											name: "TableCellSpan",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 954, col: 5, offset: 32808},
							label: "horizontalAlign",
							expr: &zeroOrOneExpr{
								pos: position{line: 954, col: 21, offset: 32824},
								expr: &choiceExpr{
									pos: position{line: 955, col: 9, offset: 32834},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 955, col: 9, offset: 32834},
											run: (*parser).callonTableCellFormat22,
											expr: &litMatcher{
												pos:        position{line: 955, col: 9, offset: 32834},
												val:        "<",
												ignoreCase: false,
												want:       "\"<\"",
											},
										},
										&actionExpr{
											pos: position{line: 956, col: 11, offset: 32902},
											run: (*parser).callonTableCellFormat24,
											expr: &litMatcher{
												pos:        position{line: 956, col: 11, offset: 32902},
												val:        ">",
												ignoreCase: false,
												want:       "\">\"",
											},
										},
										&actionExpr{
											pos: position{line: 957, col: 11, offset: 32971},
											run: (*parser).callonTableCellFormat26,
											expr: &litMatcher{
												pos:        position{line: 957, col: 11, offset: 32971},
												val:        "^",
												ignoreCase: false,
												want:       "\"^\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 959, col: 5, offset: 33043},
							label: "verticalAlign",
							expr: &zeroOrOneExpr{
								pos: position{line: 959, col: 19, offset: 33057},
								expr: &choiceExpr{
									pos: position{line: 960, col: 9, offset: 33067},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 960, col: 9, offset: 33067},
											run: (*parser).callonTableCellFormat31,
											expr: &litMatcher{
												pos:        position{line: 960, col: 9, offset: 33067},
												val:        ".<",
												ignoreCase: false,
												want:       "\".<\"",
											},
										},
										&actionExpr{
											pos: position{line: 961, col: 11, offset: 33133},
											run: (*parser).callonTableCellFormat33,
											expr: &litMatcher{
												pos:        position{line: 961, col: 11, offset: 33133},
												val:        ".>",
												ignoreCase: false,
												want:       "\".>\"",
											},
										},
										&actionExpr{
											pos: position{line: 962, col: 11, offset: 33202},
											run: (*parser).callonTableCellFormat35,
											expr: &litMatcher{
												pos:        position{line: 962, col: 11, offset: 33202},
												val:        ".^",
												ignoreCase: false,
												want:       "\".^\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 964, col: 5, offset: 33272},
							label: "style",
							expr: &zeroOrOneExpr{
								pos: position{line: 964, col: 11, offset: 33278},
								expr: &choiceExpr{
									pos: position{line: 965, col: 9, offset: 33288},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 965, col: 9, offset: 33288},
											run: (*parser).callonTableCellFormat40,
											expr: &litMatcher{
												pos:        position{line: 965, col: 9, offset: 33288},
												val:        "a",
												ignoreCase: false,
												want:       "\"a\"",
											},
										},
										&actionExpr{
											pos: position{line: 966, col: 11, offset: 33350},
											run: (*parser).callonTableCellFormat42,
											expr: &litMatcher{
												pos:        position{line: 966, col: 11, offset: 33350},
												val:        "d",
												ignoreCase: false,
												want:       "\"d\"",
											},
										},
										&actionExpr{
											pos: position{line: 967, col: 11, offset: 33411},
											run: (*parser).callonTableCellFormat44,
											expr: &litMatcher{
												pos:        position{line: 967, col: 11, offset: 33411},
												val:        "e",
												ignoreCase: false,
												want:       "\"e\"",
											},
										},
										&actionExpr{
											pos: position{line: 968, col: 11, offset: 33474},
											run: (*parser).callonTableCellFormat46,
											expr: &litMatcher{
												pos:        position{line: 968, col: 11, offset: 33474},
												val:        "h",
												ignoreCase: false,
												want:       "\"h\"",
											},
										},
										&actionExpr{
											pos: position{line: 969, col: 11, offset: 33535},
											run: (*parser).callonTableCellFormat48,
											expr: &litMatcher{
												pos:        position{line: 969, col: 11, offset: 33535},
												val:        "l",
												ignoreCase: false,
												want:       "\"l\"",
											},
										},
										&actionExpr{
											pos: position{line: 970, col: 11, offset: 33597},
											run: (*parser).callonTableCellFormat50,
											expr: &litMatcher{
												pos:        position{line: 970, col: 11, offset: 33597},
												val:        "m",
												ignoreCase: false,
												want:       "\"m\"",
											},
										},
										&actionExpr{
											pos: position{line: 971, col: 11, offset: 33661},
											run: (*parser).callonTableCellFormat52,
											expr: &litMatcher{
												pos:        position{line: 971, col: 11, offset: 33661},
												val:        "s",
												ignoreCase: false,
												want:       "\"s\"",
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 973, col: 6, offset: 33724},
							run: (*parser).callonTableCellFormat54,
						},
					},
				},
			},
		},
		{
			name: "URLScheme",
			pos:  position{line: 991, col: 1, offset: 34502},
			expr: &actionExpr{
				pos: position{line: 991, col: 13, offset: 34514},
				run: (*parser).callonURLScheme1,
				expr: &choiceExpr{
					pos: position{line: 991, col: 14, offset: 34515},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 991, col: 14, offset: 34515},
							val:        "https://",
							ignoreCase: false,
							want:       "\"https://\"",
						},
						&litMatcher{
							pos:        position{line: 991, col: 27, offset: 34528},
							val:        "http://",
							ignoreCase: false,
							want:       "\"http://\"",
						},
						&litMatcher{
							pos:        position{line: 991, col: 39, offset: 34540},
							val:        "ftp://",
							ignoreCase: false,
							want:       "\"ftp://\"",
						},
						&litMatcher{
							pos:        position{line: 991, col: 50, offset: 34551},
							val:        "irc://",
							ignoreCase: false,
							want:       "\"irc://\"",
						},
						&litMatcher{
							pos:        position{line: 991, col: 61, offset: 34562},
							val:        "mailto:",
							ignoreCase: false,
							want:       "\"mailto:\"",
						},
					},
				},
			},
		},
		{
			name: "URL",
			pos:  position{line: 996, col: 1, offset: 34654},
			expr: &actionExpr{
				pos: position{line: 996, col: 7, offset: 34660},
				run: (*parser).callonURL1,
				expr: &seqExpr{
					pos: position{line: 996, col: 7, offset: 34660},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 996, col: 7, offset: 34660},
							label: "scheme",
							expr: &zeroOrOneExpr{
								pos: position{line: 996, col: 14, offset: 34667},
								expr: &ruleRefExpr{
									pos:  position{line: 996, col: 15, offset: 34668},
									name: "URLScheme",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 996, col: 27, offset: 34680},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 996, col: 33, offset: 34686},
								name: "Path",
							},
						},
					},
				},
			},
		},
		{
			name: "FullURL",
			pos:  position{line: 1002, col: 1, offset: 34826},
			expr: &actionExpr{
				pos: position{line: 1002, col: 11, offset: 34836},
				run: (*parser).callonFullURL1,
				expr: &seqExpr{
					pos: position{line: 1002, col: 11, offset: 34836},
					exprs: []any{
						&notExpr{
							pos: position{line: 1002, col: 11, offset: 34836},
							expr: &litMatcher{
								pos:        position{line: 1002, col: 12, offset: 34837},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1002, col: 16, offset: 34841},
							label: "scheme",
							expr: &ruleRefExpr{
								pos:  position{line: 1002, col: 24, offset: 34849},
								name: "URLScheme",
							},
						},
						&labeledExpr{
							pos:   position{line: 1002, col: 35, offset: 34860},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 1002, col: 41, offset: 34866},
								name: "Path",
							},
						},
					},
				},
			},
		},
		{
			name: "Path",
			pos:  position{line: 1010, col: 1, offset: 35000},
			expr: &actionExpr{
				pos: position{line: 1010, col: 8, offset: 35007},
				run: (*parser).callonPath1,
				expr: &seqExpr{
					pos: position{line: 1010, col: 8, offset: 35007},
					exprs: []any{
						&notExpr{
							pos: position{line: 1010, col: 8, offset: 35007},
							expr: &litMatcher{
								pos:        position{line: 1010, col: 9, offset: 35008},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1010, col: 13, offset: 35012},
							label: "elements",
							expr: &oneOrMoreExpr{
								pos: position{line: 1010, col: 24, offset: 35023},
								expr: &ruleRefExpr{
									pos:  position{line: 1010, col: 24, offset: 35023},
									name: "PathElement",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "PathElement",
			pos:  position{line: 1015, col: 1, offset: 35152},
			expr: &choiceExpr{
				pos: position{line: 1015, col: 16, offset: 35167},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1015, col: 16, offset: 35167},
						run: (*parser).callonPathElement2,
						expr: &oneOrMoreExpr{
							pos: position{line: 1015, col: 16, offset: 35167},
							expr: &charClassMatcher{
								pos:             position{line: 1015, col: 17, offset: 35168},
								val:             "[^\\r\\n{.<>!?,;[\\] ]",
								chars:           []rune{'\r', '\n', '{', '.', '<', '>', '!', '?', ',', ';', '[', ']', ' '},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false},
								ignoreCase:      false,
								inverted:        true,
							},
						},
					},
					&actionExpr{
						pos: position{line: 1017, col: 5, offset: 35247},
						run: (*parser).callonPathElement5,
						expr: &seqExpr{
							pos: position{line: 1017, col: 6, offset: 35248},
							exprs: []any{
								&charClassMatcher{
									pos:             position{line: 1017, col: 6, offset: 35248},
									val:             "[.?!;,]",
									chars:           []rune{'.', '?', '!', ';', ','},
									basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
									ignoreCase:      false,
									inverted:        false,
								},
								&andExpr{
									pos: position{line: 1017, col: 14, offset: 35256},
									expr: &seqExpr{
										pos: position{line: 1017, col: 16, offset: 35258},
										exprs: []any{
											&notExpr{
												pos: position{line: 1017, col: 16, offset: 35258},
												expr: &ruleRefExpr{
													pos:  position{line: 1017, col: 17, offset: 35259},
													name: "_",
												},
											},
											&notExpr{
												pos: position{line: 1017, col: 19, offset: 35261},
												expr: &ruleRefExpr{
													pos:  position{line: 1017, col: 20, offset: 35262},
													name: "EndOfFile",
												},
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1019, col: 5, offset: 35331},
						name: "AttributeReference",
					},
				},
			},
		},
		{
			name: "Email",
			pos:  position{line: 1023, col: 1, offset: 35355},
			expr: &actionExpr{
				pos: position{line: 1023, col: 9, offset: 35363},
				run: (*parser).callonEmail1,
				expr: &seqExpr{
					pos: position{line: 1023, col: 9, offset: 35363},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1023, col: 9, offset: 35363},
							label: "name",
							expr: &ruleRefExpr{
								pos:  position{line: 1023, col: 15, offset: 35369},
								name: "EmailName",
							},
						},
						&litMatcher{
							pos:        position{line: 1023, col: 26, offset: 35380},
							val:        "@",
							ignoreCase: false,
							want:       "\"@\"",
						},
						&labeledExpr{
							pos:   position{line: 1023, col: 30, offset: 35384},
							label: "domain",
							expr: &ruleRefExpr{
								pos:  position{line: 1023, col: 38, offset: 35392},
								name: "EmailDomain",
							},
						},
					},
				},
			},
		},
		{
			name: "EmailName",
			pos:  position{line: 1027, col: 1, offset: 35490},
			expr: &actionExpr{
				pos: position{line: 1027, col: 13, offset: 35502},
				run: (*parser).callonEmailName1,
				expr: &seqExpr{
					pos: position{line: 1027, col: 13, offset: 35502},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1027, col: 13, offset: 35502},
							label: "name",
							expr: &actionExpr{
								pos: position{line: 1027, col: 19, offset: 35508},
								run: (*parser).callonEmailName4,
								expr: &oneOrMoreExpr{
									pos: position{line: 1027, col: 19, offset: 35508},
									expr: &choiceExpr{
										pos: position{line: 1027, col: 20, offset: 35509},
										alternatives: []any{
											&ruleRefExpr{
												pos:  position{line: 1027, col: 20, offset: 35509},
												name: "Alphanumeric",
											},
											&charClassMatcher{
												pos:             position{line: 1027, col: 35, offset: 35524},
												val:             "[!#$%&'*+-/=?^_`{|}~.]",
												chars:           []rune{'!', '#', '$', '%', '&', '\'', '*', '=', '?', '^', '_', '`', '{', '|', '}', '~', '.'},
												ranges:          []rune{'+', '/'},
												basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, true, true, true, true, false, false, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false},
												ignoreCase:      false,
												inverted:        false,
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1029, col: 4, offset: 35652},
							run: (*parser).callonEmailName9,
						},
					},
				},
			},
		},
		{
			name: "EmailDomain",
			pos:  position{line: 1036, col: 1, offset: 35818},
			expr: &actionExpr{
				pos: position{line: 1036, col: 15, offset: 35832},
				run: (*parser).callonEmailDomain1,
				expr: &seqExpr{
					pos: position{line: 1036, col: 15, offset: 35832},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1036, col: 15, offset: 35832},
							label: "domain",
							expr: &actionExpr{
								pos: position{line: 1036, col: 23, offset: 35840},
								run: (*parser).callonEmailDomain4,
								expr: &seqExpr{
									pos: position{line: 1036, col: 24, offset: 35841},
									exprs: []any{
										&oneOrMoreExpr{
											pos: position{line: 1036, col: 24, offset: 35841},
											expr: &ruleRefExpr{
												pos:  position{line: 1036, col: 25, offset: 35842},
												name: "Alphanumeric",
											},
										},
										&zeroOrMoreExpr{
											pos: position{line: 1036, col: 40, offset: 35857},
											expr: &seqExpr{
												pos: position{line: 1036, col: 41, offset: 35858},
												exprs: []any{
													&litMatcher{
														pos:        position{line: 1036, col: 41, offset: 35858},
														val:        ".",
														ignoreCase: false,
														want:       "\".\"",
													},
													&oneOrMoreExpr{
														pos: position{line: 1036, col: 45, offset: 35862},
														expr: &choiceExpr{
															pos: position{line: 1036, col: 46, offset: 35863},
															alternatives: []any{
																&ruleRefExpr{
																	pos:  position{line: 1036, col: 46, offset: 35863},
																	name: "Alphanumeric",
																},
																&litMatcher{
																	pos:        position{line: 1036, col: 61, offset: 35878},
																	val:        "-",
																	ignoreCase: false,
																	want:       "\"-\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1038, col: 4, offset: 35923},
							run: (*parser).callonEmailDomain15,
						},
					},
				},
			},
		},
		{
			name: "Listing",
			pos:  position{line: 1046, col: 1, offset: 36065},
			expr: &actionExpr{
				pos: position{line: 1047, col: 5, offset: 36079},
				run: (*parser).callonListing1,
				expr: &seqExpr{
					pos: position{line: 1047, col: 5, offset: 36079},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1047, col: 5, offset: 36079},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1047, col: 12, offset: 36086},
								name: "ListingStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1048, col: 5, offset: 36104},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1048, col: 11, offset: 36110},
								expr: &ruleRefExpr{
									pos:  position{line: 1048, col: 12, offset: 36111},
									name: "ListingLine",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1049, col: 5, offset: 36129},
							name: "ListingEnd",
						},
					},
				},
			},
		},
		{
			name: "ListingStart",
			pos:  position{line: 1053, col: 1, offset: 36287},
			expr: &actionExpr{
				pos: position{line: 1053, col: 16, offset: 36302},
				run: (*parser).callonListingStart1,
				expr: &seqExpr{
					pos: position{line: 1053, col: 16, offset: 36302},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1053, col: 16, offset: 36302},
							name: "BeginningOfLine",
						},
						&labeledExpr{
							pos:   position{line: 1053, col: 32, offset: 36318},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1053, col: 42, offset: 36328},
								name: "ListingDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1053, col: 59, offset: 36345},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1053, col: 69, offset: 36355},
							run: (*parser).callonListingStart7,
						},
					},
				},
			},
		},
		{
			name: "ListingEnd",
			pos:  position{line: 1060, col: 1, offset: 36532},
			expr: &seqExpr{
				pos: position{line: 1060, col: 14, offset: 36545},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 1060, col: 14, offset: 36545},
						name: "BeginningOfLine",
					},
					&labeledExpr{
						pos:   position{line: 1060, col: 30, offset: 36561},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1060, col: 40, offset: 36571},
							name: "ListingDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1060, col: 57, offset: 36588},
						expr: &ruleRefExpr{
							pos:  position{line: 1060, col: 58, offset: 36589},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1060, col: 68, offset: 36599},
						run: (*parser).callonListingEnd7,
					},
				},
			},
		},
		{
			name: "ListingHyphens",
			pos:  position{line: 1069, col: 1, offset: 36859},
			expr: &actionExpr{
				pos: position{line: 1069, col: 18, offset: 36876},
				run: (*parser).callonListingHyphens1,
				expr: &seqExpr{
					pos: position{line: 1069, col: 18, offset: 36876},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1069, col: 18, offset: 36876},
							label: "hyphens",
							expr: &seqExpr{
								pos: position{line: 1069, col: 27, offset: 36885},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1069, col: 27, offset: 36885},
										val:        "----",
										ignoreCase: false,
										want:       "\"----\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1069, col: 34, offset: 36892},
										expr: &litMatcher{
											pos:        position{line: 1069, col: 34, offset: 36892},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1069, col: 40, offset: 36898},
							run: (*parser).callonListingHyphens8,
						},
					},
				},
			},
		},
		{
			name: "ListingDelimiter",
			pos:  position{line: 1076, col: 1, offset: 37017},
			expr: &actionExpr{
				pos: position{line: 1076, col: 20, offset: 37036},
				run: (*parser).callonListingDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1076, col: 20, offset: 37036},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1076, col: 20, offset: 37036},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:  position{line: 1076, col: 29, offset: 37045},
								name: "ListingHyphens",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1077, col: 5, offset: 37066},
							expr: &ruleRefExpr{
								pos:  position{line: 1077, col: 5, offset: 37066},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "ListingLine",
			pos:  position{line: 1082, col: 1, offset: 37186},
			expr: &actionExpr{
				pos: position{line: 1082, col: 15, offset: 37200},
				run: (*parser).callonListingLine1,
				expr: &seqExpr{
					pos: position{line: 1082, col: 16, offset: 37201},
					exprs: []any{
						&notExpr{
							pos: position{line: 1082, col: 16, offset: 37201},
							expr: &ruleRefExpr{
								pos:  position{line: 1082, col: 17, offset: 37202},
								name: "ListingDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1082, col: 34, offset: 37219},
							name: "NotEndOfFile",
						},
						&labeledExpr{
							pos:   position{line: 1082, col: 47, offset: 37232},
							label: "line",
							expr: &ruleRefExpr{
								pos:  position{line: 1082, col: 52, offset: 37237},
								name: "AnyText",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1082, col: 60, offset: 37245},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "Open",
			pos:  position{line: 1087, col: 1, offset: 37385},
			expr: &actionExpr{
				pos: position{line: 1088, col: 5, offset: 37396},
				run: (*parser).callonOpen1,
				expr: &seqExpr{
					pos: position{line: 1088, col: 5, offset: 37396},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1088, col: 5, offset: 37396},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1088, col: 12, offset: 37403},
								name: "OpenStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1089, col: 5, offset: 37418},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1089, col: 11, offset: 37424},
								expr: &seqExpr{
									pos: position{line: 1089, col: 12, offset: 37425},
									exprs: []any{
										&notExpr{
											pos: position{line: 1089, col: 12, offset: 37425},
											expr: &ruleRefExpr{
												pos:  position{line: 1089, col: 13, offset: 37426},
												name: "OpenDelimiter",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1089, col: 27, offset: 37440},
											name: "Element",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1090, col: 5, offset: 37454},
							name: "OpenEnd",
						},
					},
				},
			},
		},
		{
			name: "OpenStart",
			pos:  position{line: 1094, col: 1, offset: 37603},
			expr: &actionExpr{
				pos: position{line: 1094, col: 13, offset: 37615},
				run: (*parser).callonOpenStart1,
				expr: &seqExpr{
					pos: position{line: 1094, col: 13, offset: 37615},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1094, col: 13, offset: 37615},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1094, col: 23, offset: 37625},
								name: "OpenDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1094, col: 37, offset: 37639},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1094, col: 47, offset: 37649},
							run: (*parser).callonOpenStart6,
						},
					},
				},
			},
		},
		{
			name: "OpenEnd",
			pos:  position{line: 1101, col: 1, offset: 37823},
			expr: &seqExpr{
				pos: position{line: 1101, col: 11, offset: 37833},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1101, col: 11, offset: 37833},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1101, col: 21, offset: 37843},
							name: "OpenDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1101, col: 35, offset: 37857},
						expr: &ruleRefExpr{
							pos:  position{line: 1101, col: 36, offset: 37858},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1101, col: 46, offset: 37868},
						run: (*parser).callonOpenEnd6,
					},
				},
			},
		},
		{
			name: "OpenEquals",
			pos:  position{line: 1110, col: 1, offset: 38122},
			expr: &actionExpr{
				pos: position{line: 1110, col: 14, offset: 38135},
				run: (*parser).callonOpenEquals1,
				expr: &labeledExpr{
					pos:   position{line: 1110, col: 14, offset: 38135},
					label: "hyphens",
					expr: &litMatcher{
						pos:        position{line: 1110, col: 23, offset: 38144},
						val:        "--",
						ignoreCase: false,
						want:       "\"--\"",
					},
				},
			},
		},
		{
			name: "OpenDelimiter",
			pos:  position{line: 1115, col: 1, offset: 38200},
			expr: &actionExpr{
				pos: position{line: 1115, col: 17, offset: 38216},
				run: (*parser).callonOpenDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1115, col: 17, offset: 38216},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1115, col: 17, offset: 38216},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:  position{line: 1115, col: 26, offset: 38225},
								name: "OpenEquals",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1116, col: 5, offset: 38242},
							expr: &ruleRefExpr{
								pos:  position{line: 1116, col: 5, offset: 38242},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "MarkedText",
			pos:  position{line: 1122, col: 1, offset: 38368},
			expr: &choiceExpr{
				pos: position{line: 1122, col: 15, offset: 38382},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1122, col: 15, offset: 38382},
						name: "SingleMarkedText",
					},
					&ruleRefExpr{
						pos:  position{line: 1122, col: 34, offset: 38401},
						name: "DoubleMarkedText",
					},
				},
			},
		},
		{
			name: "SingleMarkedText",
			pos:  position{line: 1124, col: 1, offset: 38420},
			expr: &actionExpr{
				pos: position{line: 1124, col: 20, offset: 38439},
				run: (*parser).callonSingleMarkedText1,
				expr: &seqExpr{
					pos: position{line: 1124, col: 20, offset: 38439},
					exprs: []any{
						&notExpr{
							pos: position{line: 1124, col: 20, offset: 38439},
							expr: &ruleRefExpr{
								pos:  position{line: 1124, col: 21, offset: 38440},
								name: "Escape",
							},
						},
						&litMatcher{
							pos:        position{line: 1124, col: 28, offset: 38447},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&andExpr{
							pos: position{line: 1124, col: 32, offset: 38451},
							expr: &notExpr{
								pos: position{line: 1124, col: 34, offset: 38453},
								expr: &litMatcher{
									pos:        position{line: 1124, col: 35, offset: 38454},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1124, col: 40, offset: 38459},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1124, col: 47, offset: 38466},
								name: "SingleMarkedTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 1124, col: 70, offset: 38489},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&notExpr{
							pos: position{line: 1124, col: 74, offset: 38493},
							expr: &litMatcher{
								pos:        position{line: 1124, col: 75, offset: 38494},
								val:        "#",
								ignoreCase: false,
								want:       "\"#\"",
							},
						},
						&andExpr{
							pos: position{line: 1124, col: 79, offset: 38498},
							expr: &notExpr{
								pos: position{line: 1124, col: 81, offset: 38500},
								expr: &ruleRefExpr{
									pos:  position{line: 1124, col: 82, offset: 38501},
									name: "Alphanumeric",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMarkedTextValue",
			pos:  position{line: 1129, col: 1, offset: 38605},
			expr: &actionExpr{
				pos: position{line: 1129, col: 25, offset: 38629},
				run: (*parser).callonSingleMarkedTextValue1,
				expr: &seqExpr{
					pos: position{line: 1129, col: 25, offset: 38629},
					exprs: []any{
						&notExpr{
							pos: position{line: 1129, col: 25, offset: 38629},
							expr: &ruleRefExpr{
								pos:  position{line: 1129, col: 26, offset: 38630},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1129, col: 28, offset: 38632},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1129, col: 34, offset: 38638},
								expr: &actionExpr{
									pos: position{line: 1129, col: 35, offset: 38639},
									run: (*parser).callonSingleMarkedTextValue7,
									expr: &seqExpr{
										pos: position{line: 1129, col: 35, offset: 38639},
										exprs: []any{
											&notExpr{
												pos: position{line: 1129, col: 35, offset: 38639},
												expr: &ruleRefExpr{
													pos:  position{line: 1129, col: 36, offset: 38640},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 1129, col: 38, offset: 38642},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1129, col: 44, offset: 38648},
													expr: &ruleRefExpr{
														pos:  position{line: 1129, col: 45, offset: 38649},
														name: "SingleMarkedTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMarkedTextElement",
			pos:  position{line: 1134, col: 1, offset: 38865},
			expr: &actionExpr{
				pos: position{line: 1134, col: 27, offset: 38891},
				run: (*parser).callonSingleMarkedTextElement1,
				expr: &seqExpr{
					pos: position{line: 1134, col: 27, offset: 38891},
					exprs: []any{
						&notExpr{
							pos: position{line: 1134, col: 27, offset: 38891},
							expr: &seqExpr{
								pos: position{line: 1134, col: 29, offset: 38893},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1134, col: 29, offset: 38893},
										val:        "#",
										ignoreCase: false,
										want:       "\"#\"",
									},
									&notExpr{
										pos: position{line: 1134, col: 33, offset: 38897},
										expr: &litMatcher{
											pos:        position{line: 1134, col: 34, offset: 38898},
											val:        "#",
											ignoreCase: false,
											want:       "\"#\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1134, col: 39, offset: 38903},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 1134, col: 48, offset: 38912},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMarkedText",
			pos:  position{line: 1139, col: 1, offset: 39034},
			expr: &actionExpr{
				pos: position{line: 1139, col: 20, offset: 39053},
				run: (*parser).callonDoubleMarkedText1,
				expr: &seqExpr{
					pos: position{line: 1139, col: 20, offset: 39053},
					exprs: []any{
						&notExpr{
							pos: position{line: 1139, col: 20, offset: 39053},
							expr: &ruleRefExpr{
								pos:  position{line: 1139, col: 21, offset: 39054},
								name: "DoubleEscape",
							},
						},
						&litMatcher{
							pos:        position{line: 1139, col: 34, offset: 39067},
							val:        "##",
							ignoreCase: false,
							want:       "\"##\"",
						},
						&labeledExpr{
							pos:   position{line: 1139, col: 39, offset: 39072},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1139, col: 46, offset: 39079},
								name: "DoubleMarkedTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 1139, col: 69, offset: 39102},
							val:        "##",
							ignoreCase: false,
							want:       "\"##\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleMarkedTextValue",
			pos:  position{line: 1144, col: 1, offset: 39205},
			expr: &actionExpr{
				pos: position{line: 1144, col: 25, offset: 39229},
				run: (*parser).callonDoubleMarkedTextValue1,
				expr: &seqExpr{
					pos: position{line: 1144, col: 25, offset: 39229},
					exprs: []any{
						&notExpr{
							pos: position{line: 1144, col: 25, offset: 39229},
							expr: &ruleRefExpr{
								pos:  position{line: 1144, col: 26, offset: 39230},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1144, col: 28, offset: 39232},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1144, col: 34, offset: 39238},
								expr: &actionExpr{
									pos: position{line: 1144, col: 35, offset: 39239},
									run: (*parser).callonDoubleMarkedTextValue7,
									expr: &seqExpr{
										pos: position{line: 1144, col: 35, offset: 39239},
										exprs: []any{
											&notExpr{
												pos: position{line: 1144, col: 35, offset: 39239},
												expr: &ruleRefExpr{
													pos:  position{line: 1144, col: 36, offset: 39240},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 1144, col: 38, offset: 39242},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1144, col: 44, offset: 39248},
													expr: &ruleRefExpr{
														pos:  position{line: 1144, col: 45, offset: 39249},
														name: "DoubleMarkedTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMarkedTextElement",
			pos:  position{line: 1149, col: 1, offset: 39484},
			expr: &actionExpr{
				pos: position{line: 1149, col: 27, offset: 39510},
				run: (*parser).callonDoubleMarkedTextElement1,
				expr: &seqExpr{
					pos: position{line: 1149, col: 27, offset: 39510},
					exprs: []any{
						&notExpr{
							pos: position{line: 1149, col: 27, offset: 39510},
							expr: &litMatcher{
								pos:        position{line: 1149, col: 29, offset: 39512},
								val:        "##",
								ignoreCase: false,
								want:       "\"##\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1149, col: 35, offset: 39518},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 1149, col: 44, offset: 39527},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "Example",
			pos:  position{line: 1156, col: 1, offset: 39658},
			expr: &actionExpr{
				pos: position{line: 1157, col: 5, offset: 39672},
				run: (*parser).callonExample1,
				expr: &seqExpr{
					pos: position{line: 1157, col: 5, offset: 39672},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1157, col: 5, offset: 39672},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1157, col: 12, offset: 39679},
								name: "ExampleStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1158, col: 5, offset: 39697},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1158, col: 11, offset: 39703},
								expr: &seqExpr{
									pos: position{line: 1158, col: 12, offset: 39704},
									exprs: []any{
										&notExpr{
											pos: position{line: 1158, col: 12, offset: 39704},
											expr: &ruleRefExpr{
												pos:  position{line: 1158, col: 13, offset: 39705},
												name: "ExampleDelimiter",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1158, col: 30, offset: 39722},
											name: "Element",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1159, col: 5, offset: 39736},
							name: "ExampleEnd",
						},
					},
				},
			},
		},
		{
			name: "ExampleStart",
			pos:  position{line: 1163, col: 1, offset: 39894},
			expr: &actionExpr{
				pos: position{line: 1163, col: 16, offset: 39909},
				run: (*parser).callonExampleStart1,
				expr: &seqExpr{
					pos: position{line: 1163, col: 16, offset: 39909},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1163, col: 16, offset: 39909},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1163, col: 26, offset: 39919},
								name: "ExampleDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1163, col: 43, offset: 39936},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1163, col: 53, offset: 39946},
							run: (*parser).callonExampleStart6,
						},
					},
				},
			},
		},
		{
			name: "ExampleEnd",
			pos:  position{line: 1171, col: 1, offset: 40195},
			expr: &seqExpr{
				pos: position{line: 1171, col: 14, offset: 40208},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1171, col: 14, offset: 40208},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1171, col: 24, offset: 40218},
							name: "ExampleDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1171, col: 41, offset: 40235},
						expr: &ruleRefExpr{
							pos:  position{line: 1171, col: 42, offset: 40236},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1171, col: 52, offset: 40246},
						run: (*parser).callonExampleEnd6,
					},
				},
			},
		},
		{
			name: "ExampleEquals",
			pos:  position{line: 1182, col: 1, offset: 40704},
			expr: &actionExpr{
				pos: position{line: 1182, col: 17, offset: 40720},
				run: (*parser).callonExampleEquals1,
				expr: &seqExpr{
					pos: position{line: 1182, col: 17, offset: 40720},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1182, col: 17, offset: 40720},
							label: "hyphens",
							expr: &seqExpr{
								pos: position{line: 1182, col: 26, offset: 40729},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1182, col: 26, offset: 40729},
										val:        "====",
										ignoreCase: false,
										want:       "\"====\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1182, col: 33, offset: 40736},
										expr: &litMatcher{
											pos:        position{line: 1182, col: 33, offset: 40736},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1182, col: 39, offset: 40742},
							run: (*parser).callonExampleEquals8,
						},
					},
				},
			},
		},
		{
			name: "ExampleDelimiter",
			pos:  position{line: 1190, col: 1, offset: 40930},
			expr: &actionExpr{
				pos: position{line: 1190, col: 20, offset: 40949},
				run: (*parser).callonExampleDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1190, col: 20, offset: 40949},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1190, col: 20, offset: 40949},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:  position{line: 1190, col: 29, offset: 40958},
								name: "ExampleEquals",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1191, col: 5, offset: 40978},
							expr: &ruleRefExpr{
								pos:  position{line: 1191, col: 5, offset: 40978},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "ExampleLine",
			pos:  position{line: 1197, col: 1, offset: 41170},
			expr: &actionExpr{
				pos: position{line: 1197, col: 15, offset: 41184},
				run: (*parser).callonExampleLine1,
				expr: &seqExpr{
					pos: position{line: 1197, col: 16, offset: 41185},
					exprs: []any{
						&notExpr{
							pos: position{line: 1197, col: 16, offset: 41185},
							expr: &ruleRefExpr{
								pos:  position{line: 1197, col: 17, offset: 41186},
								name: "ExampleDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1197, col: 34, offset: 41203},
							name: "NotEndOfFile",
						},
						&labeledExpr{
							pos:   position{line: 1197, col: 47, offset: 41216},
							label: "line",
							expr: &ruleRefExpr{
								pos:  position{line: 1197, col: 52, offset: 41221},
								name: "AnyText",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1197, col: 60, offset: 41229},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "Literal",
			pos:  position{line: 1203, col: 1, offset: 41277},
			expr: &actionExpr{
				pos: position{line: 1204, col: 5, offset: 41291},
				run: (*parser).callonLiteral1,
				expr: &seqExpr{
					pos: position{line: 1204, col: 5, offset: 41291},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1204, col: 5, offset: 41291},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1204, col: 12, offset: 41298},
								name: "LiteralStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1205, col: 5, offset: 41316},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1205, col: 11, offset: 41322},
								expr: &ruleRefExpr{
									pos:  position{line: 1205, col: 12, offset: 41323},
									name: "LiteralLine",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1206, col: 5, offset: 41341},
							name: "LiteralEnd",
						},
					},
				},
			},
		},
		{
			name: "LiteralStart",
			pos:  position{line: 1210, col: 1, offset: 41508},
			expr: &actionExpr{
				pos: position{line: 1210, col: 16, offset: 41523},
				run: (*parser).callonLiteralStart1,
				expr: &seqExpr{
					pos: position{line: 1210, col: 16, offset: 41523},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1210, col: 16, offset: 41523},
							name: "BeginningOfLine",
						},
						&labeledExpr{
							pos:   position{line: 1210, col: 32, offset: 41539},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1210, col: 42, offset: 41549},
								name: "LiteralDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1210, col: 59, offset: 41566},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1210, col: 69, offset: 41576},
							run: (*parser).callonLiteralStart7,
						},
					},
				},
			},
		},
		{
			name: "LiteralEnd",
			pos:  position{line: 1217, col: 1, offset: 41753},
			expr: &seqExpr{
				pos: position{line: 1217, col: 14, offset: 41766},
				exprs: []any{
					&ruleRefExpr{
						pos:  position{line: 1217, col: 14, offset: 41766},
						name: "BeginningOfLine",
					},
					&labeledExpr{
						pos:   position{line: 1217, col: 30, offset: 41782},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1217, col: 40, offset: 41792},
							name: "LiteralDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1217, col: 57, offset: 41809},
						expr: &ruleRefExpr{
							pos:  position{line: 1217, col: 58, offset: 41810},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1217, col: 68, offset: 41820},
						run: (*parser).callonLiteralEnd7,
					},
				},
			},
		},
		{
			name: "LiteralDots",
			pos:  position{line: 1226, col: 1, offset: 42080},
			expr: &actionExpr{
				pos: position{line: 1226, col: 15, offset: 42094},
				run: (*parser).callonLiteralDots1,
				expr: &seqExpr{
					pos: position{line: 1226, col: 15, offset: 42094},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1226, col: 15, offset: 42094},
							label: "dots",
							expr: &seqExpr{
								pos: position{line: 1226, col: 21, offset: 42100},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1226, col: 21, offset: 42100},
										val:        "....",
										ignoreCase: false,
										want:       "\"....\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1226, col: 28, offset: 42107},
										expr: &litMatcher{
											pos:        position{line: 1226, col: 28, offset: 42107},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1226, col: 34, offset: 42113},
							run: (*parser).callonLiteralDots8,
						},
					},
				},
			},
		},
		{
			name: "LiteralDelimiter",
			pos:  position{line: 1233, col: 1, offset: 42226},
			expr: &actionExpr{
				pos: position{line: 1233, col: 20, offset: 42245},
				run: (*parser).callonLiteralDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1233, col: 20, offset: 42245},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1233, col: 20, offset: 42245},
							label: "dots",
							expr: &ruleRefExpr{
								pos:  position{line: 1233, col: 26, offset: 42251},
								name: "LiteralDots",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1234, col: 5, offset: 42269},
							expr: &ruleRefExpr{
								pos:  position{line: 1234, col: 5, offset: 42269},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "LiteralLine",
			pos:  position{line: 1239, col: 1, offset: 42386},
			expr: &actionExpr{
				pos: position{line: 1239, col: 15, offset: 42400},
				run: (*parser).callonLiteralLine1,
				expr: &seqExpr{
					pos: position{line: 1239, col: 16, offset: 42401},
					exprs: []any{
						&notExpr{
							pos: position{line: 1239, col: 16, offset: 42401},
							expr: &ruleRefExpr{
								pos:  position{line: 1239, col: 17, offset: 42402},
								name: "LiteralDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1239, col: 34, offset: 42419},
							name: "NotEndOfFile",
						},
						&labeledExpr{
							pos:   position{line: 1239, col: 47, offset: 42432},
							label: "line",
							expr: &ruleRefExpr{
								pos:  position{line: 1239, col: 52, offset: 42437},
								name: "AnyText",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1239, col: 60, offset: 42445},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "Sidebar",
			pos:  position{line: 1243, col: 1, offset: 42491},
			expr: &actionExpr{
				pos: position{line: 1244, col: 5, offset: 42505},
				run: (*parser).callonSidebar1,
				expr: &seqExpr{
					pos: position{line: 1244, col: 5, offset: 42505},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1244, col: 5, offset: 42505},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1244, col: 12, offset: 42512},
								name: "SidebarStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1245, col: 5, offset: 42530},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1245, col: 11, offset: 42536},
								expr: &seqExpr{
									pos: position{line: 1245, col: 12, offset: 42537},
									exprs: []any{
										&notExpr{
											pos: position{line: 1245, col: 12, offset: 42537},
											expr: &ruleRefExpr{
												pos:  position{line: 1245, col: 13, offset: 42538},
												name: "SidebarDelimiter",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1245, col: 30, offset: 42555},
											name: "Element",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1246, col: 5, offset: 42569},
							name: "SidebarEnd",
						},
					},
				},
			},
		},
		{
			name: "SidebarStart",
			pos:  position{line: 1250, col: 1, offset: 42727},
			expr: &actionExpr{
				pos: position{line: 1250, col: 16, offset: 42742},
				run: (*parser).callonSidebarStart1,
				expr: &seqExpr{
					pos: position{line: 1250, col: 16, offset: 42742},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1250, col: 16, offset: 42742},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1250, col: 26, offset: 42752},
								name: "SidebarDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1250, col: 43, offset: 42769},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1250, col: 53, offset: 42779},
							run: (*parser).callonSidebarStart6,
						},
					},
				},
			},
		},
		{
			name: "SidebarEnd",
			pos:  position{line: 1257, col: 1, offset: 42956},
			expr: &seqExpr{
				pos: position{line: 1257, col: 14, offset: 42969},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1257, col: 14, offset: 42969},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1257, col: 24, offset: 42979},
							name: "SidebarDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1257, col: 41, offset: 42996},
						expr: &ruleRefExpr{
							pos:  position{line: 1257, col: 42, offset: 42997},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1257, col: 52, offset: 43007},
						run: (*parser).callonSidebarEnd6,
					},
				},
			},
		},
		{
			name: "SidebarAsterisks",
			pos:  position{line: 1266, col: 1, offset: 43267},
			expr: &actionExpr{
				pos: position{line: 1266, col: 20, offset: 43286},
				run: (*parser).callonSidebarAsterisks1,
				expr: &seqExpr{
					pos: position{line: 1266, col: 20, offset: 43286},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1266, col: 20, offset: 43286},
							label: "asterisks",
							expr: &seqExpr{
								pos: position{line: 1266, col: 31, offset: 43297},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1266, col: 31, offset: 43297},
										val:        "****",
										ignoreCase: false,
										want:       "\"****\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1266, col: 38, offset: 43304},
										expr: &litMatcher{
											pos:        position{line: 1266, col: 38, offset: 43304},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1266, col: 44, offset: 43310},
							run: (*parser).callonSidebarAsterisks8,
						},
					},
				},
			},
		},
		{
			name: "SidebarDelimiter",
			pos:  position{line: 1273, col: 1, offset: 43433},
			expr: &actionExpr{
				pos: position{line: 1273, col: 20, offset: 43452},
				run: (*parser).callonSidebarDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1273, col: 20, offset: 43452},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1273, col: 20, offset: 43452},
							label: "asterisks",
							expr: &ruleRefExpr{
								pos:  position{line: 1273, col: 31, offset: 43463},
								name: "SidebarAsterisks",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1274, col: 5, offset: 43486},
							expr: &ruleRefExpr{
								pos:  position{line: 1274, col: 5, offset: 43486},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "PreParse",
			pos:  position{line: 1280, col: 1, offset: 43609},
			expr: &actionExpr{
				pos: position{line: 1280, col: 12, offset: 43620},
				run: (*parser).callonPreParse1,
				expr: &seqExpr{
					pos: position{line: 1280, col: 12, offset: 43620},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1280, col: 12, offset: 43620},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 1280, col: 20, offset: 43628},
								expr: &ruleRefExpr{
									pos:  position{line: 1280, col: 21, offset: 43629},
									name: "PreParseElement",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1280, col: 39, offset: 43647},
							name: "EndOfFile",
						},
					},
				},
			},
		},
		{
			name: "PreParseElement",
			pos:  position{line: 1285, col: 1, offset: 43771},
			expr: &actionExpr{
				pos: position{line: 1285, col: 19, offset: 43789},
				run: (*parser).callonPreParseElement1,
				expr: &seqExpr{
					pos: position{line: 1285, col: 19, offset: 43789},
					exprs: []any{
						&notExpr{
							pos: position{line: 1285, col: 19, offset: 43789},
							expr: &ruleRefExpr{
								pos:  position{line: 1285, col: 20, offset: 43790},
								name: "EndOfFile",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1285, col: 30, offset: 43800},
							name: "BeginningOfLine",
						},
						&labeledExpr{
							pos:   position{line: 1285, col: 46, offset: 43816},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 1285, col: 55, offset: 43825},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 1285, col: 55, offset: 43825},
										name: "IfDefBlock",
									},
									&ruleRefExpr{
										pos:  position{line: 1285, col: 68, offset: 43838},
										name: "IfNDefBlock",
									},
									&ruleRefExpr{
										pos:  position{line: 1285, col: 82, offset: 43852},
										name: "IfEvalBlock",
									},
									&ruleRefExpr{
										pos:  position{line: 1285, col: 96, offset: 43866},
										name: "AttributeEntry",
									},
									&ruleRefExpr{
										pos:  position{line: 1285, col: 113, offset: 43883},
										name: "AttributeReset",
									},
									&ruleRefExpr{
										pos:  position{line: 1285, col: 130, offset: 43900},
										name: "PreParseLine",
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1285, col: 144, offset: 43914},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "PreParseLine",
			pos:  position{line: 1289, col: 1, offset: 43953},
			expr: &actionExpr{
				pos: position{line: 1289, col: 16, offset: 43968},
				run: (*parser).callonPreParseLine1,
				expr: &seqExpr{
					pos: position{line: 1289, col: 16, offset: 43968},
					exprs: []any{
						&notExpr{
							pos: position{line: 1289, col: 16, offset: 43968},
							expr: &ruleRefExpr{
								pos:  position{line: 1289, col: 17, offset: 43969},
								name: "EndIfDefStatement",
							},
						},
						&labeledExpr{
							pos:   position{line: 1289, col: 35, offset: 43987},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1289, col: 43, offset: 43995},
								expr: &ruleRefExpr{
									pos:  position{line: 1289, col: 43, offset: 43995},
									name: "PreParseLineElement",
								},
							},
						},
						&andExpr{
							pos: position{line: 1289, col: 64, offset: 44016},
							expr: &ruleRefExpr{
								pos:  position{line: 1289, col: 65, offset: 44017},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "PreParseLineElement",
			pos:  position{line: 1294, col: 1, offset: 44172},
			expr: &choiceExpr{
				pos: position{line: 1295, col: 5, offset: 44200},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1295, col: 5, offset: 44200},
						run: (*parser).callonPreParseLineElement2,
						expr: &labeledExpr{
							pos:   position{line: 1295, col: 5, offset: 44200},
							label: "arv",
							expr: &ruleRefExpr{
								pos:  position{line: 1295, col: 9, offset: 44204},
								name: "AttributeReference",
							},
						},
					},
					&actionExpr{
						pos: position{line: 1299, col: 6, offset: 44266},
						run: (*parser).callonPreParseLineElement5,
						expr: &oneOrMoreExpr{
							pos: position{line: 1299, col: 6, offset: 44266},
							expr: &charClassMatcher{
								pos:             position{line: 1299, col: 6, offset: 44266},
								val:             "[^\\r\\n{]",
								chars:           []rune{'\r', '\n', '{'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false},
								ignoreCase:      false,
								inverted:        true,
							},
						},
					},
					&actionExpr{
						pos: position{line: 1302, col: 8, offset: 44347},
						run: (*parser).callonPreParseLineElement8,
						expr: &litMatcher{
							pos:        position{line: 1302, col: 8, offset: 44347},
							val:        "{",
							ignoreCase: false,
							want:       "\"{\"",
						},
					},
				},
			},
		},
		{
			name: "IfDefBlock",
			pos:  position{line: 1305, col: 1, offset: 44385},
			expr: &actionExpr{
				pos: position{line: 1305, col: 14, offset: 44398},
				run: (*parser).callonIfDefBlock1,
				expr: &seqExpr{
					pos: position{line: 1305, col: 14, offset: 44398},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1305, col: 14, offset: 44398},
							name: "IfDefStatement",
						},
						&labeledExpr{
							pos:   position{line: 1305, col: 29, offset: 44413},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1305, col: 41, offset: 44425},
								name: "ConditionalAttributes",
							},
						},
						&litMatcher{
							pos:        position{line: 1305, col: 64, offset: 44448},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1305, col: 69, offset: 44453},
							expr: &ruleRefExpr{
								pos:  position{line: 1305, col: 69, offset: 44453},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1305, col: 73, offset: 44457},
							name: "EndOfLine",
						},
						&labeledExpr{
							pos:   position{line: 1305, col: 83, offset: 44467},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1305, col: 89, offset: 44473},
								expr: &ruleRefExpr{
									pos:  position{line: 1305, col: 90, offset: 44474},
									name: "PreParseElement",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1305, col: 109, offset: 44493},
							name: "EndIfDef",
						},
					},
				},
			},
		},
		{
			name: "IfNDefBlock",
			pos:  position{line: 1310, col: 1, offset: 44681},
			expr: &actionExpr{
				pos: position{line: 1310, col: 15, offset: 44695},
				run: (*parser).callonIfNDefBlock1,
				expr: &seqExpr{
					pos: position{line: 1310, col: 15, offset: 44695},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1310, col: 15, offset: 44695},
							val:        "ifndef::",
							ignoreCase: false,
							want:       "\"ifndef::\"",
						},
						&labeledExpr{
							pos:   position{line: 1310, col: 26, offset: 44706},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1310, col: 38, offset: 44718},
								name: "ConditionalAttributes",
							},
						},
						&litMatcher{
							pos:        position{line: 1310, col: 61, offset: 44741},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1310, col: 66, offset: 44746},
							expr: &ruleRefExpr{
								pos:  position{line: 1310, col: 66, offset: 44746},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1310, col: 70, offset: 44750},
							name: "EndOfLine",
						},
						&labeledExpr{
							pos:   position{line: 1310, col: 80, offset: 44760},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1310, col: 86, offset: 44766},
								expr: &ruleRefExpr{
									pos:  position{line: 1310, col: 87, offset: 44767},
									name: "PreParseElement",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1310, col: 106, offset: 44786},
							name: "EndIfDef",
						},
					},
				},
			},
		},
		{
			name: "IfEvalBlock",
			pos:  position{line: 1315, col: 1, offset: 44976},
			expr: &actionExpr{
				pos: position{line: 1315, col: 15, offset: 44990},
				run: (*parser).callonIfEvalBlock1,
				expr: &seqExpr{
					pos: position{line: 1315, col: 15, offset: 44990},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1315, col: 15, offset: 44990},
							name: "IfEvalStatement",
						},
						&litMatcher{
							pos:        position{line: 1315, col: 31, offset: 45006},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1315, col: 35, offset: 45010},
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 35, offset: 45010},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1315, col: 38, offset: 45013},
							label: "left",
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 44, offset: 45019},
								name: "IfEvalValue",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1315, col: 57, offset: 45032},
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 57, offset: 45032},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1315, col: 61, offset: 45036},
							label: "operand",
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 70, offset: 45045},
								name: "IfEvalOperator",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1315, col: 86, offset: 45061},
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 86, offset: 45061},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1315, col: 89, offset: 45064},
							label: "right",
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 96, offset: 45071},
								name: "IfEvalValue",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1315, col: 109, offset: 45084},
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 109, offset: 45084},
								name: "_",
							},
						},
						&litMatcher{
							pos:        position{line: 1315, col: 112, offset: 45087},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1315, col: 116, offset: 45091},
							expr: &ruleRefExpr{
								pos:  position{line: 1315, col: 116, offset: 45091},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1315, col: 120, offset: 45095},
							name: "EndOfLine",
						},
						&labeledExpr{
							pos:   position{line: 1315, col: 130, offset: 45105},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1315, col: 136, offset: 45111},
								expr: &ruleRefExpr{
									pos:  position{line: 1315, col: 137, offset: 45112},
									name: "PreParseElement",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1315, col: 156, offset: 45131},
							name: "EndIfDef",
						},
					},
				},
			},
		},
		{
			name: "Quote",
			pos:  position{line: 1322, col: 1, offset: 45352},
			expr: &actionExpr{
				pos: position{line: 1323, col: 5, offset: 45364},
				run: (*parser).callonQuote1,
				expr: &seqExpr{
					pos: position{line: 1323, col: 5, offset: 45364},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1323, col: 5, offset: 45364},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1323, col: 12, offset: 45371},
								name: "QuoteStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1324, col: 5, offset: 45387},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1324, col: 11, offset: 45393},
								expr: &seqExpr{
									pos: position{line: 1324, col: 12, offset: 45394},
									exprs: []any{
										&notExpr{
											pos: position{line: 1324, col: 12, offset: 45394},
											expr: &ruleRefExpr{
												pos:  position{line: 1324, col: 13, offset: 45395},
												name: "QuoteDelimiter",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1324, col: 28, offset: 45410},
											name: "Element",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1325, col: 5, offset: 45424},
							name: "QuoteEnd",
						},
					},
				},
			},
		},
		{
			name: "QuoteStart",
			pos:  position{line: 1329, col: 1, offset: 45576},
			expr: &actionExpr{
				pos: position{line: 1329, col: 14, offset: 45589},
				run: (*parser).callonQuoteStart1,
				expr: &seqExpr{
					pos: position{line: 1329, col: 14, offset: 45589},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1329, col: 14, offset: 45589},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1329, col: 24, offset: 45599},
								name: "QuoteDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1329, col: 39, offset: 45614},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1329, col: 49, offset: 45624},
							run: (*parser).callonQuoteStart6,
						},
					},
				},
			},
		},
		{
			name: "QuoteEnd",
			pos:  position{line: 1336, col: 1, offset: 45799},
			expr: &seqExpr{
				pos: position{line: 1336, col: 12, offset: 45810},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1336, col: 12, offset: 45810},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1336, col: 22, offset: 45820},
							name: "QuoteDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1336, col: 37, offset: 45835},
						expr: &ruleRefExpr{
							pos:  position{line: 1336, col: 38, offset: 45836},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1336, col: 48, offset: 45846},
						run: (*parser).callonQuoteEnd6,
					},
				},
			},
		},
		{
			name: "QuoteUnderlines",
			pos:  position{line: 1345, col: 1, offset: 46098},
			expr: &actionExpr{
				pos: position{line: 1345, col: 19, offset: 46116},
				run: (*parser).callonQuoteUnderlines1,
				expr: &seqExpr{
					pos: position{line: 1345, col: 19, offset: 46116},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1345, col: 19, offset: 46116},
							label: "underlines",
							expr: &seqExpr{
								pos: position{line: 1345, col: 31, offset: 46128},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1345, col: 31, offset: 46128},
										val:        "____",
										ignoreCase: false,
										want:       "\"____\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1345, col: 38, offset: 46135},
										expr: &litMatcher{
											pos:        position{line: 1345, col: 38, offset: 46135},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1345, col: 44, offset: 46141},
							run: (*parser).callonQuoteUnderlines8,
						},
					},
				},
			},
		},
		{
			name: "QuoteDelimiter",
			pos:  position{line: 1352, col: 1, offset: 46266},
			expr: &actionExpr{
				pos: position{line: 1352, col: 18, offset: 46283},
				run: (*parser).callonQuoteDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1352, col: 18, offset: 46283},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1352, col: 18, offset: 46283},
							label: "underlines",
							expr: &ruleRefExpr{
								pos:  position{line: 1352, col: 30, offset: 46295},
								name: "QuoteUnderlines",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1353, col: 5, offset: 46317},
							expr: &ruleRefExpr{
								pos:  position{line: 1353, col: 5, offset: 46317},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "ListItemValue",
			pos:  position{line: 1359, col: 1, offset: 46439},
			expr: &actionExpr{
				pos: position{line: 1359, col: 17, offset: 46455},
				run: (*parser).callonListItemValue1,
				expr: &seqExpr{
					pos: position{line: 1359, col: 17, offset: 46455},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1359, col: 17, offset: 46455},
							label: "line",
							expr: &oneOrMoreExpr{
								pos: position{line: 1359, col: 22, offset: 46460},
								expr: &ruleRefExpr{
									pos:  position{line: 1359, col: 22, offset: 46460},
									name: "InlineElement",
								},
							},
						},
						&andExpr{
							pos: position{line: 1359, col: 37, offset: 46475},
							expr: &ruleRefExpr{
								pos:  position{line: 1359, col: 38, offset: 46476},
								name: "EndOfLine",
							},
						},
						&labeledExpr{
							pos:   position{line: 1359, col: 48, offset: 46486},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1359, col: 54, offset: 46492},
								expr: &ruleRefExpr{
									pos:  position{line: 1359, col: 55, offset: 46493},
									name: "ListItemLine",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1359, col: 70, offset: 46508},
							label: "attachedBlocks",
							expr: &zeroOrOneExpr{
								pos: position{line: 1359, col: 85, offset: 46523},
								expr: &ruleRefExpr{
									pos:  position{line: 1359, col: 86, offset: 46524},
									name: "AttachedBlocks",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttachedBlock",
			pos:  position{line: 1370, col: 1, offset: 46756},
			expr: &actionExpr{
				pos: position{line: 1370, col: 17, offset: 46772},
				run: (*parser).callonAttachedBlock1,
				expr: &seqExpr{
					pos: position{line: 1370, col: 17, offset: 46772},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1370, col: 17, offset: 46772},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 1370, col: 26, offset: 46781},
								name: "AttachedBlockElement",
							},
						},
						&andExpr{
							pos: position{line: 1370, col: 48, offset: 46803},
							expr: &ruleRefExpr{
								pos:  position{line: 1370, col: 49, offset: 46804},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "AttachedBlockElement",
			pos:  position{line: 1374, col: 1, offset: 46843},
			expr: &actionExpr{
				pos: position{line: 1374, col: 24, offset: 46866},
				run: (*parser).callonAttachedBlockElement1,
				expr: &seqExpr{
					pos: position{line: 1374, col: 24, offset: 46866},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1374, col: 24, offset: 46866},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1374, col: 28, offset: 46870},
							expr: &ruleRefExpr{
								pos:  position{line: 1374, col: 28, offset: 46870},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1374, col: 31, offset: 46873},
							name: "NewLine",
						},
						&labeledExpr{
							pos:   position{line: 1374, col: 39, offset: 46881},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1374, col: 46, offset: 46888},
								name: "BlockElements",
							},
						},
					},
				},
			},
		},
		{
			name: "ListContinuation",
			pos:  position{line: 1378, col: 1, offset: 46976},
			expr: &actionExpr{
				pos: position{line: 1378, col: 20, offset: 46995},
				run: (*parser).callonListContinuation1,
				expr: &seqExpr{
					pos: position{line: 1378, col: 20, offset: 46995},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1378, col: 20, offset: 46995},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1378, col: 24, offset: 46999},
							expr: &ruleRefExpr{
								pos:  position{line: 1378, col: 24, offset: 46999},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1378, col: 27, offset: 47002},
							name: "NewLine",
						},
						&labeledExpr{
							pos:   position{line: 1378, col: 35, offset: 47010},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1378, col: 41, offset: 47016},
								name: "BlockElement",
							},
						},
					},
				},
			},
		},
		{
			name: "ListItemLine",
			pos:  position{line: 1382, col: 1, offset: 47112},
			expr: &actionExpr{
				pos: position{line: 1382, col: 16, offset: 47127},
				run: (*parser).callonListItemLine1,
				expr: &seqExpr{
					pos: position{line: 1382, col: 16, offset: 47127},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1382, col: 16, offset: 47127},
							name: "EndOfLine",
						},
						&notExpr{
							pos: position{line: 1382, col: 26, offset: 47137},
							expr: &ruleRefExpr{
								pos:  position{line: 1382, col: 27, offset: 47138},
								name: "OrderedListMarker",
							},
						},
						&notExpr{
							pos: position{line: 1382, col: 45, offset: 47156},
							expr: &ruleRefExpr{
								pos:  position{line: 1382, col: 46, offset: 47157},
								name: "UnorderedListMarker",
							},
						},
						&notExpr{
							pos: position{line: 1382, col: 66, offset: 47177},
							expr: &ruleRefExpr{
								pos:  position{line: 1382, col: 67, offset: 47178},
								name: "BlockDelimiters",
							},
						},
						&labeledExpr{
							pos:   position{line: 1382, col: 84, offset: 47195},
							label: "element",
							expr: &oneOrMoreExpr{
								pos: position{line: 1382, col: 92, offset: 47203},
								expr: &ruleRefExpr{
									pos:  position{line: 1382, col: 92, offset: 47203},
									name: "InlineElement",
								},
							},
						},
						&andExpr{
							pos: position{line: 1382, col: 107, offset: 47218},
							expr: &ruleRefExpr{
								pos:  position{line: 1382, col: 108, offset: 47219},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "AttachedBlocks",
			pos:  position{line: 1386, col: 1, offset: 47286},
			expr: &actionExpr{
				pos: position{line: 1386, col: 18, offset: 47303},
				run: (*parser).callonAttachedBlocks1,
				expr: &seqExpr{
					pos: position{line: 1386, col: 18, offset: 47303},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1386, col: 18, offset: 47303},
							label: "blocks",
							expr: &oneOrMoreExpr{
								pos: position{line: 1386, col: 25, offset: 47310},
								expr: &ruleRefExpr{
									pos:  position{line: 1386, col: 26, offset: 47311},
									name: "AttachedBlockElement",
								},
							},
						},
						&andExpr{
							pos: position{line: 1386, col: 49, offset: 47334},
							expr: &ruleRefExpr{
								pos:  position{line: 1386, col: 50, offset: 47335},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "ThematicBreak",
			pos:  position{line: 1391, col: 1, offset: 47374},
			expr: &actionExpr{
				pos: position{line: 1391, col: 17, offset: 47390},
				run: (*parser).callonThematicBreak1,
				expr: &seqExpr{
					pos: position{line: 1391, col: 17, offset: 47390},
					exprs: []any{
						&choiceExpr{
							pos: position{line: 1391, col: 18, offset: 47391},
							alternatives: []any{
								&litMatcher{
									pos:        position{line: 1391, col: 18, offset: 47391},
									val:        "'''",
									ignoreCase: false,
									want:       "\"'''\"",
								},
								&seqExpr{
									pos: position{line: 1391, col: 26, offset: 47399},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1391, col: 26, offset: 47399},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1391, col: 30, offset: 47403},
											expr: &ruleRefExpr{
												pos:  position{line: 1391, col: 30, offset: 47403},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 1391, col: 33, offset: 47406},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1391, col: 37, offset: 47410},
											expr: &ruleRefExpr{
												pos:  position{line: 1391, col: 37, offset: 47410},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 1391, col: 40, offset: 47413},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&seqExpr{
									pos: position{line: 1391, col: 46, offset: 47419},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1391, col: 46, offset: 47419},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1391, col: 50, offset: 47423},
											expr: &ruleRefExpr{
												pos:  position{line: 1391, col: 50, offset: 47423},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 1391, col: 53, offset: 47426},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1391, col: 57, offset: 47430},
											expr: &ruleRefExpr{
												pos:  position{line: 1391, col: 57, offset: 47430},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 1391, col: 60, offset: 47433},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
									},
								},
								&seqExpr{
									pos: position{line: 1391, col: 66, offset: 47439},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1391, col: 66, offset: 47439},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1391, col: 70, offset: 47443},
											expr: &ruleRefExpr{
												pos:  position{line: 1391, col: 70, offset: 47443},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 1391, col: 73, offset: 47446},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1391, col: 77, offset: 47450},
											expr: &ruleRefExpr{
												pos:  position{line: 1391, col: 77, offset: 47450},
												name: "_",
											},
										},
										&litMatcher{
											pos:        position{line: 1391, col: 80, offset: 47453},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
									},
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1391, col: 85, offset: 47458},
							expr: &ruleRefExpr{
								pos:  position{line: 1391, col: 85, offset: 47458},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1391, col: 88, offset: 47461},
							expr: &ruleRefExpr{
								pos:  position{line: 1391, col: 89, offset: 47462},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "PageBreak",
			pos:  position{line: 1397, col: 1, offset: 47590},
			expr: &actionExpr{
				pos: position{line: 1397, col: 13, offset: 47602},
				run: (*parser).callonPageBreak1,
				expr: &seqExpr{
					pos: position{line: 1397, col: 13, offset: 47602},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1397, col: 14, offset: 47603},
							val:        "<<<",
							ignoreCase: false,
							want:       "\"<<<\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1397, col: 21, offset: 47610},
							expr: &ruleRefExpr{
								pos:  position{line: 1397, col: 21, offset: 47610},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1397, col: 24, offset: 47613},
							expr: &ruleRefExpr{
								pos:  position{line: 1397, col: 25, offset: 47614},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "Fenced",
			pos:  position{line: 1403, col: 1, offset: 47734},
			expr: &actionExpr{
				pos: position{line: 1404, col: 5, offset: 47747},
				run: (*parser).callonFenced1,
				expr: &seqExpr{
					pos: position{line: 1404, col: 5, offset: 47747},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1404, col: 5, offset: 47747},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1404, col: 12, offset: 47754},
								name: "FencedStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1405, col: 5, offset: 47771},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1405, col: 11, offset: 47777},
								expr: &seqExpr{
									pos: position{line: 1405, col: 12, offset: 47778},
									exprs: []any{
										&notExpr{
											pos: position{line: 1405, col: 12, offset: 47778},
											expr: &ruleRefExpr{
												pos:  position{line: 1405, col: 13, offset: 47779},
												name: "FencedDelimiter",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1405, col: 29, offset: 47795},
											name: "Element",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1406, col: 5, offset: 47809},
							name: "FencedEnd",
						},
					},
				},
			},
		},
		{
			name: "FencedStart",
			pos:  position{line: 1410, col: 1, offset: 47964},
			expr: &actionExpr{
				pos: position{line: 1410, col: 15, offset: 47978},
				run: (*parser).callonFencedStart1,
				expr: &seqExpr{
					pos: position{line: 1410, col: 15, offset: 47978},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1410, col: 15, offset: 47978},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1410, col: 25, offset: 47988},
								name: "FencedDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1410, col: 41, offset: 48004},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1410, col: 51, offset: 48014},
							run: (*parser).callonFencedStart6,
						},
					},
				},
			},
		},
		{
			name: "FencedEnd",
			pos:  position{line: 1418, col: 1, offset: 48261},
			expr: &seqExpr{
				pos: position{line: 1418, col: 13, offset: 48273},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1418, col: 13, offset: 48273},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1418, col: 23, offset: 48283},
							name: "FencedDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1418, col: 39, offset: 48299},
						expr: &ruleRefExpr{
							pos:  position{line: 1418, col: 40, offset: 48300},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1418, col: 50, offset: 48310},
						run: (*parser).callonFencedEnd6,
					},
				},
			},
		},
		{
			name: "FencedBackticks",
			pos:  position{line: 1429, col: 1, offset: 48764},
			expr: &actionExpr{
				pos: position{line: 1429, col: 19, offset: 48782},
				run: (*parser).callonFencedBackticks1,
				expr: &seqExpr{
					pos: position{line: 1429, col: 19, offset: 48782},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1429, col: 19, offset: 48782},
							label: "backticks",
							expr: &seqExpr{
								pos: position{line: 1429, col: 30, offset: 48793},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1429, col: 30, offset: 48793},
										val:        "```",
										ignoreCase: false,
										want:       "\"```\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1429, col: 36, offset: 48799},
										expr: &litMatcher{
											pos:        position{line: 1429, col: 36, offset: 48799},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1429, col: 42, offset: 48805},
							run: (*parser).callonFencedBackticks8,
						},
					},
				},
			},
		},
		{
			name: "FencedDelimiter",
			pos:  position{line: 1437, col: 1, offset: 48999},
			expr: &actionExpr{
				pos: position{line: 1437, col: 19, offset: 49017},
				run: (*parser).callonFencedDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1437, col: 19, offset: 49017},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1437, col: 19, offset: 49017},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:  position{line: 1437, col: 28, offset: 49026},
								name: "FencedBackticks",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1438, col: 5, offset: 49048},
							expr: &ruleRefExpr{
								pos:  position{line: 1438, col: 5, offset: 49048},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "FencedLine",
			pos:  position{line: 1444, col: 1, offset: 49238},
			expr: &actionExpr{
				pos: position{line: 1444, col: 14, offset: 49251},
				run: (*parser).callonFencedLine1,
				expr: &seqExpr{
					pos: position{line: 1444, col: 15, offset: 49252},
					exprs: []any{
						&notExpr{
							pos: position{line: 1444, col: 15, offset: 49252},
							expr: &ruleRefExpr{
								pos:  position{line: 1444, col: 16, offset: 49253},
								name: "FencedDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1444, col: 32, offset: 49269},
							name: "NotEndOfFile",
						},
						&labeledExpr{
							pos:   position{line: 1444, col: 45, offset: 49282},
							label: "line",
							expr: &ruleRefExpr{
								pos:  position{line: 1444, col: 50, offset: 49287},
								name: "AnyText",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1444, col: 58, offset: 49295},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "Stem",
			pos:  position{line: 1450, col: 1, offset: 49343},
			expr: &actionExpr{
				pos: position{line: 1451, col: 5, offset: 49354},
				run: (*parser).callonStem1,
				expr: &seqExpr{
					pos: position{line: 1451, col: 5, offset: 49354},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1451, col: 5, offset: 49354},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1451, col: 12, offset: 49361},
								name: "StemStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1452, col: 5, offset: 49376},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1452, col: 11, offset: 49382},
								expr: &ruleRefExpr{
									pos:  position{line: 1452, col: 12, offset: 49383},
									name: "StemLine",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1453, col: 5, offset: 49398},
							name: "StemEnd",
						},
					},
				},
			},
		},
		{
			name: "StemStart",
			pos:  position{line: 1457, col: 1, offset: 49557},
			expr: &actionExpr{
				pos: position{line: 1457, col: 13, offset: 49569},
				run: (*parser).callonStemStart1,
				expr: &seqExpr{
					pos: position{line: 1457, col: 13, offset: 49569},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1457, col: 13, offset: 49569},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1457, col: 23, offset: 49579},
								name: "StemDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1457, col: 37, offset: 49593},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1457, col: 47, offset: 49603},
							run: (*parser).callonStemStart6,
						},
					},
				},
			},
		},
		{
			name: "StemEnd",
			pos:  position{line: 1464, col: 1, offset: 49777},
			expr: &seqExpr{
				pos: position{line: 1464, col: 11, offset: 49787},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1464, col: 11, offset: 49787},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1464, col: 21, offset: 49797},
							name: "StemDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1464, col: 35, offset: 49811},
						expr: &ruleRefExpr{
							pos:  position{line: 1464, col: 36, offset: 49812},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1464, col: 46, offset: 49822},
						run: (*parser).callonStemEnd6,
					},
				},
			},
		},
		{
			name: "StemPluses",
			pos:  position{line: 1473, col: 1, offset: 50076},
			expr: &actionExpr{
				pos: position{line: 1473, col: 14, offset: 50089},
				run: (*parser).callonStemPluses1,
				expr: &seqExpr{
					pos: position{line: 1473, col: 14, offset: 50089},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1473, col: 14, offset: 50089},
							label: "pluses",
							expr: &seqExpr{
								pos: position{line: 1473, col: 22, offset: 50097},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1473, col: 22, offset: 50097},
										val:        "++++",
										ignoreCase: false,
										want:       "\"++++\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1473, col: 29, offset: 50104},
										expr: &litMatcher{
											pos:        position{line: 1473, col: 29, offset: 50104},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1473, col: 35, offset: 50110},
							run: (*parser).callonStemPluses8,
						},
					},
				},
			},
		},
		{
			name: "StemDelimiter",
			pos:  position{line: 1480, col: 1, offset: 50227},
			expr: &actionExpr{
				pos: position{line: 1480, col: 17, offset: 50243},
				run: (*parser).callonStemDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1480, col: 17, offset: 50243},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1480, col: 17, offset: 50243},
							label: "pluses",
							expr: &ruleRefExpr{
								pos:  position{line: 1480, col: 25, offset: 50251},
								name: "StemPluses",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1481, col: 5, offset: 50268},
							expr: &ruleRefExpr{
								pos:  position{line: 1481, col: 5, offset: 50268},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "StemLine",
			pos:  position{line: 1486, col: 1, offset: 50384},
			expr: &actionExpr{
				pos: position{line: 1486, col: 12, offset: 50395},
				run: (*parser).callonStemLine1,
				expr: &seqExpr{
					pos: position{line: 1486, col: 13, offset: 50396},
					exprs: []any{
						&notExpr{
							pos: position{line: 1486, col: 13, offset: 50396},
							expr: &ruleRefExpr{
								pos:  position{line: 1486, col: 14, offset: 50397},
								name: "StemDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1486, col: 28, offset: 50411},
							name: "NotEndOfFile",
						},
						&labeledExpr{
							pos:   position{line: 1486, col: 41, offset: 50424},
							label: "line",
							expr: &ruleRefExpr{
								pos:  position{line: 1486, col: 46, offset: 50429},
								name: "AnyText",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1486, col: 54, offset: 50437},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "CrossReference",
			pos:  position{line: 1494, col: 1, offset: 50487},
			expr: &choiceExpr{
				pos: position{line: 1494, col: 18, offset: 50504},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1494, col: 18, offset: 50504},
						name: "InternalCrossReference",
					},
					&ruleRefExpr{
						pos:  position{line: 1494, col: 43, offset: 50529},
						name: "DocumentCrossReference",
					},
				},
			},
		},
		{
			name: "InternalCrossReference",
			pos:  position{line: 1496, col: 1, offset: 50553},
			expr: &actionExpr{
				pos: position{line: 1496, col: 26, offset: 50578},
				run: (*parser).callonInternalCrossReference1,
				expr: &seqExpr{
					pos: position{line: 1496, col: 26, offset: 50578},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1496, col: 26, offset: 50578},
							name: "CrossReferenceStart",
						},
						&labeledExpr{
							pos:   position{line: 1496, col: 46, offset: 50598},
							label: "id",
							expr: &ruleRefExpr{
								pos:  position{line: 1496, col: 50, offset: 50602},
								name: "CrossReferenceID",
							},
						},
						&labeledExpr{
							pos:   position{line: 1496, col: 68, offset: 50620},
							label: "label",
							expr: &zeroOrOneExpr{
								pos: position{line: 1496, col: 74, offset: 50626},
								expr: &actionExpr{
									pos: position{line: 1496, col: 75, offset: 50627},
									run: (*parser).callonInternalCrossReference8,
									expr: &seqExpr{
										pos: position{line: 1496, col: 75, offset: 50627},
										exprs: []any{
											&zeroOrMoreExpr{
												pos: position{line: 1496, col: 75, offset: 50627},
												expr: &ruleRefExpr{
													pos:  position{line: 1496, col: 75, offset: 50627},
													name: "_",
												},
											},
											&litMatcher{
												pos:        position{line: 1496, col: 78, offset: 50630},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&labeledExpr{
												pos:   position{line: 1496, col: 82, offset: 50634},
												label: "label",
												expr: &seqExpr{
													pos: position{line: 1496, col: 89, offset: 50641},
													exprs: []any{
														&zeroOrMoreExpr{
															pos: position{line: 1496, col: 89, offset: 50641},
															expr: &ruleRefExpr{
																pos:  position{line: 1496, col: 89, offset: 50641},
																name: "_",
															},
														},
														&ruleRefExpr{
															pos:  position{line: 1496, col: 92, offset: 50644},
															name: "CrossReferenceLabel",
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1496, col: 136, offset: 50688},
							val:        ">>",
							ignoreCase: false,
							want:       "\">>\"",
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceStart",
			pos:  position{line: 1504, col: 1, offset: 50892},
			expr: &litMatcher{
				pos:        position{line: 1504, col: 23, offset: 50914},
				val:        "<<",
				ignoreCase: false,
				want:       "\"<<\"",
			},
		},
		{
			name: "CrossReferenceID",
			pos:  position{line: 1506, col: 1, offset: 50921},
			expr: &actionExpr{
				pos: position{line: 1506, col: 21, offset: 50941},
				run: (*parser).callonCrossReferenceID1,
				expr: &seqExpr{
					pos: position{line: 1506, col: 21, offset: 50941},
					exprs: []any{
						&choiceExpr{
							pos: position{line: 1506, col: 22, offset: 50942},
							alternatives: []any{
								&ruleRefExpr{
									pos:  position{line: 1506, col: 22, offset: 50942},
									name: "Alpha",
								},
								&charClassMatcher{
									pos:             position{line: 1506, col: 30, offset: 50950},
									val:             "[:_]",
									chars:           []rune{':', '_'},
									basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
									ignoreCase:      false,
									inverted:        false,
								},
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1506, col: 36, offset: 50956},
							expr: &charClassMatcher{
								pos:             position{line: 1506, col: 36, offset: 50956},
								val:             "[\\p{L}\\p{N} _:.-]",
								chars:           []rune{' ', '_', ':', '.', '-'},
								classes:         []*unicode.RangeTable{rangeTable("L"), rangeTable("N")},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceLabel",
			pos:  position{line: 1512, col: 1, offset: 51177},
			expr: &oneOrMoreExpr{
				pos: position{line: 1512, col: 23, offset: 51199},
				expr: &choiceExpr{
					pos: position{line: 1513, col: 5, offset: 51205},
					alternatives: []any{
						&actionExpr{
							pos: position{line: 1513, col: 6, offset: 51206},
							run: (*parser).callonCrossReferenceLabel3,
							expr: &oneOrMoreExpr{
								pos: position{line: 1513, col: 6, offset: 51206},
								expr: &charClassMatcher{
									pos:             position{line: 1513, col: 6, offset: 51206},
									val:             "[^<>{[\\]]",
									chars:           []rune{'<', '>', '{', '[', ']'},
									basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false},
									ignoreCase:      false,
									inverted:        true,
								},
							},
						},
						&actionExpr{
							pos: position{line: 1516, col: 7, offset: 51287},
							run: (*parser).callonCrossReferenceLabel6,
							expr: &labeledExpr{
								pos:   position{line: 1516, col: 7, offset: 51287},
								label: "arv",
								expr: &ruleRefExpr{
									pos:  position{line: 1516, col: 11, offset: 51291},
									name: "AttributeReference",
								},
							},
						},
						&actionExpr{
							pos: position{line: 1519, col: 8, offset: 51349},
							run: (*parser).callonCrossReferenceLabel9,
							expr: &litMatcher{
								pos:        position{line: 1519, col: 8, offset: 51349},
								val:        "{",
								ignoreCase: false,
								want:       "\"{\"",
							},
						},
					},
				},
			},
		},
		{
			name: "DocumentCrossReference",
			pos:  position{line: 1522, col: 1, offset: 51388},
			expr: &actionExpr{
				pos: position{line: 1522, col: 26, offset: 51413},
				run: (*parser).callonDocumentCrossReference1,
				expr: &seqExpr{
					pos: position{line: 1522, col: 26, offset: 51413},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1522, col: 26, offset: 51413},
							val:        "xref:",
							ignoreCase: false,
							want:       "\"xref:\"",
						},
						&labeledExpr{
							pos:   position{line: 1522, col: 34, offset: 51421},
							label: "path",
							expr: &ruleRefExpr{
								pos:  position{line: 1522, col: 40, offset: 51427},
								name: "Path",
							},
						},
						&labeledExpr{
							pos:   position{line: 1522, col: 46, offset: 51433},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1522, col: 58, offset: 51445},
								name: "InlineAttributes",
							},
						},
					},
				},
			},
		},
		{
			name: "UppercaseRoman",
			pos:  position{line: 1529, col: 1, offset: 51611},
			expr: &actionExpr{
				pos: position{line: 1529, col: 18, offset: 51628},
				run: (*parser).callonUppercaseRoman1,
				expr: &seqExpr{
					pos: position{line: 1529, col: 18, offset: 51628},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1529, col: 18, offset: 51628},
							label: "thousands",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1529, col: 28, offset: 51638},
								expr: &litMatcher{
									pos:        position{line: 1529, col: 28, offset: 51638},
									val:        "M",
									ignoreCase: false,
									want:       "\"M\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1529, col: 33, offset: 51643},
							label: "hundreds",
							expr: &zeroOrOneExpr{
								pos: position{line: 1529, col: 42, offset: 51652},
								expr: &ruleRefExpr{
									pos:  position{line: 1529, col: 42, offset: 51652},
									name: "UppercaseRomanHundreds",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1529, col: 66, offset: 51676},
							label: "tens",
							expr: &zeroOrOneExpr{
								pos: position{line: 1529, col: 71, offset: 51681},
								expr: &ruleRefExpr{
									pos:  position{line: 1529, col: 72, offset: 51682},
									name: "UppercaseRomanTens",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1529, col: 93, offset: 51703},
							label: "ones",
							expr: &zeroOrOneExpr{
								pos: position{line: 1529, col: 98, offset: 51708},
								expr: &ruleRefExpr{
									pos:  position{line: 1529, col: 99, offset: 51709},
									name: "UppercaseRomanOnes",
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1529, col: 120, offset: 51730},
							run: (*parser).callonUppercaseRoman15,
						},
					},
				},
			},
		},
		{
			name: "UppercaseRomanHundreds",
			pos:  position{line: 1536, col: 1, offset: 51854},
			expr: &choiceExpr{
				pos: position{line: 1537, col: 5, offset: 51885},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1537, col: 5, offset: 51885},
						val:        "CM",
						ignoreCase: false,
						want:       "\"CM\"",
					},
					&litMatcher{
						pos:        position{line: 1538, col: 7, offset: 51896},
						val:        "CD",
						ignoreCase: false,
						want:       "\"CD\"",
					},
					&seqExpr{
						pos: position{line: 1539, col: 8, offset: 51908},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 1539, col: 8, offset: 51908},
								val:        "D",
								ignoreCase: false,
								want:       "\"D\"",
							},
							&labeledExpr{
								pos:   position{line: 1539, col: 12, offset: 51912},
								label: "hundreds",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1539, col: 21, offset: 51921},
									expr: &litMatcher{
										pos:        position{line: 1539, col: 21, offset: 51921},
										val:        "C",
										ignoreCase: false,
										want:       "\"C\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1539, col: 26, offset: 51926},
								run: (*parser).callonUppercaseRomanHundreds9,
							},
						},
					},
				},
			},
		},
		{
			name: "UppercaseRomanTens",
			pos:  position{line: 1542, col: 1, offset: 51972},
			expr: &choiceExpr{
				pos: position{line: 1543, col: 5, offset: 51999},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1543, col: 5, offset: 51999},
						val:        "XC",
						ignoreCase: false,
						want:       "\"XC\"",
					},
					&litMatcher{
						pos:        position{line: 1544, col: 7, offset: 52010},
						val:        "XL",
						ignoreCase: false,
						want:       "\"XL\"",
					},
					&seqExpr{
						pos: position{line: 1545, col: 8, offset: 52022},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1545, col: 8, offset: 52022},
								expr: &litMatcher{
									pos:        position{line: 1545, col: 8, offset: 52022},
									val:        "L",
									ignoreCase: false,
									want:       "\"L\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1545, col: 13, offset: 52027},
								label: "tens",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1545, col: 18, offset: 52032},
									expr: &litMatcher{
										pos:        position{line: 1545, col: 18, offset: 52032},
										val:        "X",
										ignoreCase: false,
										want:       "\"X\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1545, col: 23, offset: 52037},
								run: (*parser).callonUppercaseRomanTens10,
							},
						},
					},
				},
			},
		},
		{
			name: "UppercaseRomanOnes",
			pos:  position{line: 1548, col: 1, offset: 52079},
			expr: &choiceExpr{
				pos: position{line: 1549, col: 5, offset: 52106},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1549, col: 5, offset: 52106},
						val:        "IX",
						ignoreCase: false,
						want:       "\"IX\"",
					},
					&litMatcher{
						pos:        position{line: 1550, col: 7, offset: 52117},
						val:        "IV",
						ignoreCase: false,
						want:       "\"IV\"",
					},
					&seqExpr{
						pos: position{line: 1551, col: 8, offset: 52129},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1551, col: 8, offset: 52129},
								expr: &litMatcher{
									pos:        position{line: 1551, col: 8, offset: 52129},
									val:        "V",
									ignoreCase: false,
									want:       "\"V\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1551, col: 13, offset: 52134},
								label: "ones",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1551, col: 18, offset: 52139},
									expr: &litMatcher{
										pos:        position{line: 1551, col: 18, offset: 52139},
										val:        "I",
										ignoreCase: false,
										want:       "\"I\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1551, col: 23, offset: 52144},
								run: (*parser).callonUppercaseRomanOnes10,
							},
						},
					},
				},
			},
		},
		{
			name: "LowercaseRoman",
			pos:  position{line: 1554, col: 1, offset: 52186},
			expr: &actionExpr{
				pos: position{line: 1554, col: 18, offset: 52203},
				run: (*parser).callonLowercaseRoman1,
				expr: &seqExpr{
					pos: position{line: 1554, col: 18, offset: 52203},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1554, col: 18, offset: 52203},
							label: "thousands",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1554, col: 28, offset: 52213},
								expr: &litMatcher{
									pos:        position{line: 1554, col: 28, offset: 52213},
									val:        "m",
									ignoreCase: false,
									want:       "\"m\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1554, col: 33, offset: 52218},
							label: "hundreds",
							expr: &zeroOrOneExpr{
								pos: position{line: 1554, col: 42, offset: 52227},
								expr: &ruleRefExpr{
									pos:  position{line: 1554, col: 42, offset: 52227},
									name: "LowercaseRomanHundreds",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1554, col: 66, offset: 52251},
							label: "tens",
							expr: &zeroOrOneExpr{
								pos: position{line: 1554, col: 71, offset: 52256},
								expr: &ruleRefExpr{
									pos:  position{line: 1554, col: 72, offset: 52257},
									name: "LowercaseRomanTens",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1554, col: 93, offset: 52278},
							label: "ones",
							expr: &zeroOrOneExpr{
								pos: position{line: 1554, col: 98, offset: 52283},
								expr: &ruleRefExpr{
									pos:  position{line: 1554, col: 99, offset: 52284},
									name: "LowercaseRomanOnes",
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1554, col: 120, offset: 52305},
							run: (*parser).callonLowercaseRoman15,
						},
					},
				},
			},
		},
		{
			name: "LowercaseRomanHundreds",
			pos:  position{line: 1561, col: 1, offset: 52429},
			expr: &choiceExpr{
				pos: position{line: 1562, col: 5, offset: 52460},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1562, col: 5, offset: 52460},
						val:        "cm",
						ignoreCase: false,
						want:       "\"cm\"",
					},
					&litMatcher{
						pos:        position{line: 1563, col: 7, offset: 52471},
						val:        "cd",
						ignoreCase: false,
						want:       "\"cd\"",
					},
					&seqExpr{
						pos: position{line: 1564, col: 8, offset: 52483},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 1564, col: 8, offset: 52483},
								val:        "d",
								ignoreCase: false,
								want:       "\"d\"",
							},
							&labeledExpr{
								pos:   position{line: 1564, col: 12, offset: 52487},
								label: "hundreds",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1564, col: 21, offset: 52496},
									expr: &litMatcher{
										pos:        position{line: 1564, col: 21, offset: 52496},
										val:        "c",
										ignoreCase: false,
										want:       "\"c\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1564, col: 26, offset: 52501},
								run: (*parser).callonLowercaseRomanHundreds9,
							},
						},
					},
				},
			},
		},
		{
			name: "LowercaseRomanTens",
			pos:  position{line: 1567, col: 1, offset: 52547},
			expr: &choiceExpr{
				pos: position{line: 1568, col: 5, offset: 52574},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1568, col: 5, offset: 52574},
						val:        "xc",
						ignoreCase: false,
						want:       "\"xc\"",
					},
					&litMatcher{
						pos:        position{line: 1569, col: 7, offset: 52585},
						val:        "xl",
						ignoreCase: false,
						want:       "\"xl\"",
					},
					&seqExpr{
						pos: position{line: 1570, col: 8, offset: 52597},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1570, col: 8, offset: 52597},
								expr: &litMatcher{
									pos:        position{line: 1570, col: 8, offset: 52597},
									val:        "l",
									ignoreCase: false,
									want:       "\"l\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1570, col: 13, offset: 52602},
								label: "tens",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1570, col: 18, offset: 52607},
									expr: &litMatcher{
										pos:        position{line: 1570, col: 18, offset: 52607},
										val:        "x",
										ignoreCase: false,
										want:       "\"x\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1570, col: 23, offset: 52612},
								run: (*parser).callonLowercaseRomanTens10,
							},
						},
					},
				},
			},
		},
		{
			name: "LowercaseRomanOnes",
			pos:  position{line: 1573, col: 1, offset: 52654},
			expr: &choiceExpr{
				pos: position{line: 1574, col: 5, offset: 52681},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1574, col: 5, offset: 52681},
						val:        "ix",
						ignoreCase: false,
						want:       "\"ix\"",
					},
					&litMatcher{
						pos:        position{line: 1575, col: 7, offset: 52692},
						val:        "iv",
						ignoreCase: false,
						want:       "\"iv\"",
					},
					&seqExpr{
						pos: position{line: 1576, col: 8, offset: 52704},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1576, col: 8, offset: 52704},
								expr: &litMatcher{
									pos:        position{line: 1576, col: 8, offset: 52704},
									val:        "v",
									ignoreCase: false,
									want:       "\"v\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1576, col: 13, offset: 52709},
								label: "ones",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1576, col: 18, offset: 52714},
									expr: &litMatcher{
										pos:        position{line: 1576, col: 18, offset: 52714},
										val:        "i",
										ignoreCase: false,
										want:       "\"i\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1576, col: 23, offset: 52719},
								run: (*parser).callonLowercaseRomanOnes10,
							},
						},
					},
				},
			},
		},
		{
			name: "OrderedListItem",
			pos:  position{line: 1581, col: 1, offset: 52763},
			expr: &actionExpr{
				pos: position{line: 1581, col: 19, offset: 52781},
				run: (*parser).callonOrderedListItem1,
				expr: &seqExpr{
					pos: position{line: 1581, col: 19, offset: 52781},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1581, col: 19, offset: 52781},
							label: "marker",
							expr: &ruleRefExpr{
								pos:  position{line: 1581, col: 27, offset: 52789},
								name: "OrderedListMarker",
							},
						},
						&labeledExpr{
							pos:   position{line: 1581, col: 47, offset: 52809},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1581, col: 54, offset: 52816},
								name: "ListItemValue",
							},
						},
					},
				},
			},
		},
		{
			name: "OrderedListMarker",
			pos:  position{line: 1588, col: 1, offset: 53063},
			expr: &actionExpr{
				pos: position{line: 1588, col: 21, offset: 53083},
				run: (*parser).callonOrderedListMarker1,
				expr: &seqExpr{
					pos: position{line: 1588, col: 21, offset: 53083},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1588, col: 21, offset: 53083},
							label: "indent",
							expr: &ruleRefExpr{
								pos:  position{line: 1588, col: 29, offset: 53091},
								name: "AnySpaces",
							},
						},
						&labeledExpr{
							pos:   position{line: 1588, col: 40, offset: 53102},
							label: "marker",
							expr: &choiceExpr{
								pos: position{line: 1588, col: 48, offset: 53110},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1588, col: 48, offset: 53110},
										run: (*parser).callonOrderedListMarker7,
										expr: &seqExpr{
											pos: position{line: 1588, col: 48, offset: 53110},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 1588, col: 48, offset: 53110},
													label: "ordinal",
													expr: &actionExpr{
														pos: position{line: 1588, col: 57, offset: 53119},
														run: (*parser).callonOrderedListMarker10,
														expr: &oneOrMoreExpr{
															pos: position{line: 1588, col: 58, offset: 53120},
															expr: &litMatcher{
																pos:        position{line: 1588, col: 58, offset: 53120},
																val:        ".",
																ignoreCase: false,
																want:       "\".\"",
															},
														},
													},
												},
												&andCodeExpr{
													pos: position{line: 1591, col: 4, offset: 53224},
													run: (*parser).callonOrderedListMarker13,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1599, col: 3, offset: 53461},
										run: (*parser).callonOrderedListMarker14,
										expr: &seqExpr{
											pos: position{line: 1599, col: 3, offset: 53461},
											exprs: []any{
												&oneOrMoreExpr{
													pos: position{line: 1599, col: 3, offset: 53461},
													expr: &charClassMatcher{
														pos:             position{line: 1599, col: 3, offset: 53461},
														val:             "[0-9]",
														ranges:          []rune{'0', '9'},
														basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
														ignoreCase:      false,
														inverted:        false,
													},
												},
												&litMatcher{
													pos:        position{line: 1599, col: 10, offset: 53468},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1600, col: 3, offset: 53505},
										run: (*parser).callonOrderedListMarker19,
										expr: &seqExpr{
											pos: position{line: 1600, col: 3, offset: 53505},
											exprs: []any{
												&charClassMatcher{
													pos:             position{line: 1600, col: 3, offset: 53505},
													val:             "[a-z]",
													ranges:          []rune{'a', 'z'},
													basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
													ignoreCase:      false,
													inverted:        false,
												},
												&litMatcher{
													pos:        position{line: 1600, col: 9, offset: 53511},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1601, col: 3, offset: 53548},
										run: (*parser).callonOrderedListMarker23,
										expr: &seqExpr{
											pos: position{line: 1601, col: 3, offset: 53548},
											exprs: []any{
												&charClassMatcher{
													pos:             position{line: 1601, col: 3, offset: 53548},
													val:             "[A-Z]",
													ranges:          []rune{'A', 'Z'},
													basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
													ignoreCase:      false,
													inverted:        false,
												},
												&litMatcher{
													pos:        position{line: 1601, col: 9, offset: 53554},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1602, col: 3, offset: 53591},
										run: (*parser).callonOrderedListMarker27,
										expr: &seqExpr{
											pos: position{line: 1602, col: 3, offset: 53591},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 1602, col: 3, offset: 53591},
													name: "LowercaseRoman",
												},
												&litMatcher{
													pos:        position{line: 1602, col: 18, offset: 53606},
													val:        ")",
													ignoreCase: false,
													want:       "\")\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1603, col: 3, offset: 53643},
										run: (*parser).callonOrderedListMarker31,
										expr: &seqExpr{
											pos: position{line: 1603, col: 3, offset: 53643},
											exprs: []any{
												&ruleRefExpr{
													pos:  position{line: 1603, col: 3, offset: 53643},
													name: "UppercaseRoman",
												},
												&litMatcher{
													pos:        position{line: 1603, col: 18, offset: 53658},
													val:        ")",
													ignoreCase: false,
													want:       "\")\"",
												},
											},
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1605, col: 1, offset: 53695},
							name: "__",
						},
					},
				},
			},
		},
		{
			name: "UnorderedListItem",
			pos:  position{line: 1614, col: 1, offset: 53835},
			expr: &actionExpr{
				pos: position{line: 1614, col: 21, offset: 53855},
				run: (*parser).callonUnorderedListItem1,
				expr: &seqExpr{
					pos: position{line: 1614, col: 21, offset: 53855},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1614, col: 21, offset: 53855},
							label: "marker",
							expr: &ruleRefExpr{
								pos:  position{line: 1614, col: 29, offset: 53863},
								name: "UnorderedListMarker",
							},
						},
						&labeledExpr{
							pos:   position{line: 1614, col: 50, offset: 53884},
							label: "checklist",
							expr: &zeroOrOneExpr{
								pos: position{line: 1614, col: 60, offset: 53894},
								expr: &ruleRefExpr{
									pos:  position{line: 1614, col: 61, offset: 53895},
									name: "Checklist",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1614, col: 73, offset: 53907},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1614, col: 80, offset: 53914},
								name: "ListItemValue",
							},
						},
					},
				},
			},
		},
		{
			name: "UnorderedListMarker",
			pos:  position{line: 1622, col: 1, offset: 54222},
			expr: &actionExpr{
				pos: position{line: 1622, col: 23, offset: 54244},
				run: (*parser).callonUnorderedListMarker1,
				expr: &seqExpr{
					pos: position{line: 1622, col: 23, offset: 54244},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1622, col: 23, offset: 54244},
							label: "indent",
							expr: &ruleRefExpr{
								pos:  position{line: 1622, col: 31, offset: 54252},
								name: "AnySpaces",
							},
						},
						&labeledExpr{
							pos:   position{line: 1622, col: 42, offset: 54263},
							label: "marker",
							expr: &actionExpr{
								pos: position{line: 1622, col: 50, offset: 54271},
								run: (*parser).callonUnorderedListMarker6,
								expr: &choiceExpr{
									pos: position{line: 1622, col: 51, offset: 54272},
									alternatives: []any{
										&oneOrMoreExpr{
											pos: position{line: 1622, col: 51, offset: 54272},
											expr: &litMatcher{
												pos:        position{line: 1622, col: 51, offset: 54272},
												val:        "*",
												ignoreCase: false,
												want:       "\"*\"",
											},
										},
										&oneOrMoreExpr{
											pos: position{line: 1622, col: 58, offset: 54279},
											expr: &litMatcher{
												pos:        position{line: 1622, col: 58, offset: 54279},
												val:        "-",
												ignoreCase: false,
												want:       "\"-\"",
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1624, col: 4, offset: 54321},
							run: (*parser).callonUnorderedListMarker12,
						},
						&ruleRefExpr{
							pos:  position{line: 1627, col: 1, offset: 54369},
							name: "__",
						},
					},
				},
			},
		},
		{
			name: "Checklist",
			pos:  position{line: 1633, col: 1, offset: 54453},
			expr: &actionExpr{
				pos: position{line: 1633, col: 13, offset: 54465},
				run: (*parser).callonChecklist1,
				expr: &seqExpr{
					pos: position{line: 1633, col: 13, offset: 54465},
					exprs: []any{
						&andExpr{
							pos: position{line: 1633, col: 13, offset: 54465},
							expr: &litMatcher{
								pos:        position{line: 1633, col: 14, offset: 54466},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1634, col: 1, offset: 54471},
							label: "checklist",
							expr: &choiceExpr{
								pos: position{line: 1635, col: 7, offset: 54489},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1635, col: 7, offset: 54489},
										run: (*parser).callonChecklist7,
										expr: &litMatcher{
											pos:        position{line: 1635, col: 7, offset: 54489},
											val:        "[ ]",
											ignoreCase: false,
											want:       "\"[ ]\"",
										},
									},
									&actionExpr{
										pos: position{line: 1636, col: 7, offset: 54546},
										run: (*parser).callonChecklist9,
										expr: &litMatcher{
											pos:        position{line: 1636, col: 7, offset: 54546},
											val:        "[*]",
											ignoreCase: false,
											want:       "\"[*]\"",
										},
									},
									&actionExpr{
										pos: position{line: 1637, col: 7, offset: 54601},
										run: (*parser).callonChecklist11,
										expr: &litMatcher{
											pos:        position{line: 1637, col: 7, offset: 54601},
											val:        "[x]",
											ignoreCase: false,
											want:       "\"[x]\"",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1638, col: 7, offset: 54655},
							name: "__",
						},
					},
				},
			},
		},
		{
			name: "DescriptionListItem",
			pos:  position{line: 1643, col: 1, offset: 54698},
			expr: &actionExpr{
				pos: position{line: 1643, col: 23, offset: 54720},
				run: (*parser).callonDescriptionListItem1,
				expr: &seqExpr{
					pos: position{line: 1643, col: 23, offset: 54720},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1643, col: 23, offset: 54720},
							label: "inlineAnchor",
							expr: &zeroOrOneExpr{
								pos: position{line: 1643, col: 36, offset: 54733},
								expr: &ruleRefExpr{
									pos:  position{line: 1643, col: 37, offset: 54734},
									name: "AnchorAttribute",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1643, col: 55, offset: 54752},
							label: "term",
							expr: &ruleRefExpr{
								pos:  position{line: 1643, col: 61, offset: 54758},
								name: "DescriptionListTerm",
							},
						},
						&labeledExpr{
							pos:   position{line: 1643, col: 82, offset: 54779},
							label: "marker",
							expr: &ruleRefExpr{
								pos:  position{line: 1643, col: 90, offset: 54787},
								name: "DescriptionListMarker",
							},
						},
						&labeledExpr{
							pos:   position{line: 1643, col: 113, offset: 54810},
							label: "whitespace",
							expr: &oneOrMoreExpr{
								pos: position{line: 1643, col: 124, offset: 54821},
								expr: &choiceExpr{
									pos: position{line: 1643, col: 125, offset: 54822},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 1643, col: 125, offset: 54822},
											run: (*parser).callonDescriptionListItem13,
											expr: &ruleRefExpr{
												pos:  position{line: 1643, col: 125, offset: 54822},
												name: "_",
											},
										},
										&ruleRefExpr{
											pos:  position{line: 1643, col: 180, offset: 54877},
											name: "NewLine",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1643, col: 190, offset: 54887},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1643, col: 197, offset: 54894},
								name: "DescriptionListItemValue",
							},
						},
					},
				},
			},
		},
		{
			name: "DescriptionListTerm",
			pos:  position{line: 1655, col: 1, offset: 55477},
			expr: &actionExpr{
				pos: position{line: 1655, col: 23, offset: 55499},
				run: (*parser).callonDescriptionListTerm1,
				expr: &labeledExpr{
					pos:   position{line: 1655, col: 23, offset: 55499},
					label: "term",
					expr: &oneOrMoreExpr{
						pos: position{line: 1655, col: 28, offset: 55504},
						expr: &seqExpr{
							pos: position{line: 1655, col: 29, offset: 55505},
							exprs: []any{
								&notExpr{
									pos: position{line: 1655, col: 29, offset: 55505},
									expr: &ruleRefExpr{
										pos:  position{line: 1655, col: 30, offset: 55506},
										name: "DescriptionListMarker",
									},
								},
								&notExpr{
									pos: position{line: 1655, col: 52, offset: 55528},
									expr: &ruleRefExpr{
										pos:  position{line: 1655, col: 53, offset: 55529},
										name: "EndOfLine",
									},
								},
								&ruleRefExpr{
									pos:  position{line: 1655, col: 63, offset: 55539},
									name: "InlineElement",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DescriptionListMarker",
			pos:  position{line: 1659, col: 1, offset: 55595},
			expr: &actionExpr{
				pos: position{line: 1659, col: 25, offset: 55619},
				run: (*parser).callonDescriptionListMarker1,
				expr: &seqExpr{
					pos: position{line: 1659, col: 25, offset: 55619},
					exprs: []any{
						&zeroOrMoreExpr{
							pos: position{line: 1659, col: 25, offset: 55619},
							expr: &ruleRefExpr{
								pos:  position{line: 1659, col: 25, offset: 55619},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1659, col: 28, offset: 55622},
							label: "marker",
							expr: &actionExpr{
								pos: position{line: 1659, col: 36, offset: 55630},
								run: (*parser).callonDescriptionListMarker6,
								expr: &oneOrMoreExpr{
									pos: position{line: 1659, col: 36, offset: 55630},
									expr: &choiceExpr{
										pos: position{line: 1659, col: 37, offset: 55631},
										alternatives: []any{
											&litMatcher{
												pos:        position{line: 1659, col: 37, offset: 55631},
												val:        ":",
												ignoreCase: false,
												want:       "\":\"",
											},
											&litMatcher{
												pos:        position{line: 1659, col: 43, offset: 55637},
												val:        ";",
												ignoreCase: false,
												want:       "\";\"",
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1661, col: 4, offset: 55679},
							run: (*parser).callonDescriptionListMarker11,
						},
						&zeroOrMoreExpr{
							pos: position{line: 1668, col: 1, offset: 55806},
							expr: &ruleRefExpr{
								pos:  position{line: 1668, col: 1, offset: 55806},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "DescriptionListItemValue",
			pos:  position{line: 1673, col: 1, offset: 55846},
			expr: &actionExpr{
				pos: position{line: 1673, col: 28, offset: 55873},
				run: (*parser).callonDescriptionListItemValue1,
				expr: &seqExpr{
					pos: position{line: 1673, col: 28, offset: 55873},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1673, col: 28, offset: 55873},
							label: "line",
							expr: &choiceExpr{
								pos: position{line: 1673, col: 34, offset: 55879},
								alternatives: []any{
									&oneOrMoreExpr{
										pos: position{line: 1673, col: 34, offset: 55879},
										expr: &ruleRefExpr{
											pos:  position{line: 1673, col: 34, offset: 55879},
											name: "InlineElement",
										},
									},
									&ruleRefExpr{
										pos:  position{line: 1673, col: 51, offset: 55896},
										name: "BlockElement",
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1673, col: 65, offset: 55910},
							label: "attachedBlocks",
							expr: &zeroOrOneExpr{
								pos: position{line: 1673, col: 80, offset: 55925},
								expr: &ruleRefExpr{
									pos:  position{line: 1673, col: 81, offset: 55926},
									name: "AttachedBlocks",
								},
							},
						},
						&andExpr{
							pos: position{line: 1673, col: 99, offset: 55944},
							expr: &ruleRefExpr{
								pos:  position{line: 1673, col: 100, offset: 55945},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineComment",
			pos:  position{line: 1682, col: 1, offset: 56106},
			expr: &actionExpr{
				pos: position{line: 1682, col: 21, offset: 56126},
				run: (*parser).callonSingleLineComment1,
				expr: &seqExpr{
					pos: position{line: 1682, col: 21, offset: 56126},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1682, col: 21, offset: 56126},
							name: "SingleLineCommentDelimiter",
						},
						&notExpr{
							pos: position{line: 1682, col: 48, offset: 56153},
							expr: &litMatcher{
								pos:        position{line: 1682, col: 49, offset: 56154},
								val:        "//",
								ignoreCase: false,
								want:       "\"//\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1682, col: 54, offset: 56159},
							label: "comment",
							expr: &ruleRefExpr{
								pos:  position{line: 1682, col: 63, offset: 56168},
								name: "SingleLineCommentContent",
							},
						},
						&andExpr{
							pos: position{line: 1682, col: 89, offset: 56194},
							expr: &ruleRefExpr{
								pos:  position{line: 1682, col: 90, offset: 56195},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineCommentDelimiter",
			pos:  position{line: 1687, col: 1, offset: 56376},
			expr: &actionExpr{
				pos: position{line: 1687, col: 30, offset: 56405},
				run: (*parser).callonSingleLineCommentDelimiter1,
				expr: &litMatcher{
					pos:        position{line: 1687, col: 30, offset: 56405},
					val:        "//",
					ignoreCase: false,
					want:       "\"//\"",
				},
			},
		},
		{
			name: "SingleLineCommentContent",
			pos:  position{line: 1692, col: 1, offset: 56498},
			expr: &actionExpr{
				pos: position{line: 1692, col: 28, offset: 56525},
				run: (*parser).callonSingleLineCommentContent1,
				expr: &zeroOrMoreExpr{
					pos: position{line: 1692, col: 28, offset: 56525},
					expr: &charClassMatcher{
						pos:             position{line: 1692, col: 28, offset: 56525},
						val:             "[^\\n]",
						chars:           []rune{'\n'},
						basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
						ignoreCase:      false,
						inverted:        true,
					},
				},
			},
		},
		{
			name: "MultiLineComment",
			pos:  position{line: 1697, col: 1, offset: 56618},
			expr: &actionExpr{
				pos: position{line: 1698, col: 5, offset: 56641},
				run: (*parser).callonMultiLineComment1,
				expr: &seqExpr{
					pos: position{line: 1698, col: 5, offset: 56641},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1698, col: 5, offset: 56641},
							label: "start",
							expr: &ruleRefExpr{
								pos:  position{line: 1698, col: 12, offset: 56648},
								name: "MultiLineCommentStart",
							},
						},
						&labeledExpr{
							pos:   position{line: 1699, col: 5, offset: 56675},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1699, col: 11, offset: 56681},
								expr: &ruleRefExpr{
									pos:  position{line: 1699, col: 12, offset: 56682},
									name: "MultiLineCommentLine",
								},
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1700, col: 5, offset: 56709},
							name: "MultiLineCommentEnd",
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentStart",
			pos:  position{line: 1704, col: 1, offset: 56894},
			expr: &actionExpr{
				pos: position{line: 1704, col: 25, offset: 56918},
				run: (*parser).callonMultiLineCommentStart1,
				expr: &seqExpr{
					pos: position{line: 1704, col: 25, offset: 56918},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1704, col: 25, offset: 56918},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:  position{line: 1704, col: 35, offset: 56928},
								name: "MultiLineCommentDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1704, col: 61, offset: 56954},
							name: "EndOfLine",
						},
						&andCodeExpr{
							pos: position{line: 1704, col: 72, offset: 56965},
							run: (*parser).callonMultiLineCommentStart6,
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentEnd",
			pos:  position{line: 1712, col: 1, offset: 57228},
			expr: &seqExpr{
				pos: position{line: 1712, col: 23, offset: 57250},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1712, col: 23, offset: 57250},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:  position{line: 1712, col: 33, offset: 57260},
							name: "MultiLineCommentDelimiter",
						},
					},
					&andExpr{
						pos: position{line: 1712, col: 59, offset: 57286},
						expr: &ruleRefExpr{
							pos:  position{line: 1712, col: 60, offset: 57287},
							name: "EndOfLine",
						},
					},
					&andCodeExpr{
						pos: position{line: 1712, col: 70, offset: 57297},
						run: (*parser).callonMultiLineCommentEnd6,
					},
				},
			},
		},
		{
			name: "MultiLineCommentForwardSlashes",
			pos:  position{line: 1723, col: 1, offset: 57791},
			expr: &actionExpr{
				pos: position{line: 1723, col: 34, offset: 57824},
				run: (*parser).callonMultiLineCommentForwardSlashes1,
				expr: &seqExpr{
					pos: position{line: 1723, col: 34, offset: 57824},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1723, col: 34, offset: 57824},
							label: "forwardSlashes",
							expr: &seqExpr{
								pos: position{line: 1723, col: 50, offset: 57840},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1723, col: 50, offset: 57840},
										val:        "////",
										ignoreCase: false,
										want:       "\"////\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1723, col: 57, offset: 57847},
										expr: &litMatcher{
											pos:        position{line: 1723, col: 57, offset: 57847},
											val:        "/",
											ignoreCase: false,
											want:       "\"/\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1723, col: 63, offset: 57853},
							run: (*parser).callonMultiLineCommentForwardSlashes8,
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentDelimiter",
			pos:  position{line: 1732, col: 1, offset: 58166},
			expr: &actionExpr{
				pos: position{line: 1732, col: 29, offset: 58194},
				run: (*parser).callonMultiLineCommentDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1732, col: 29, offset: 58194},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1732, col: 29, offset: 58194},
							label: "forwardSlashes",
							expr: &ruleRefExpr{
								pos:  position{line: 1732, col: 45, offset: 58210},
								name: "MultiLineCommentForwardSlashes",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1733, col: 5, offset: 58247},
							expr: &ruleRefExpr{
								pos:  position{line: 1733, col: 5, offset: 58247},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentLine",
			pos:  position{line: 1739, col: 1, offset: 58468},
			expr: &actionExpr{
				pos: position{line: 1739, col: 24, offset: 58491},
				run: (*parser).callonMultiLineCommentLine1,
				expr: &seqExpr{
					pos: position{line: 1739, col: 25, offset: 58492},
					exprs: []any{
						&notExpr{
							pos: position{line: 1739, col: 25, offset: 58492},
							expr: &ruleRefExpr{
								pos:  position{line: 1739, col: 26, offset: 58493},
								name: "MultiLineCommentDelimiter",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1739, col: 52, offset: 58519},
							name: "NotEndOfFile",
						},
						&labeledExpr{
							pos:   position{line: 1739, col: 65, offset: 58532},
							label: "line",
							expr: &ruleRefExpr{
								pos:  position{line: 1739, col: 70, offset: 58537},
								name: "AnyText",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1739, col: 78, offset: 58545},
							name: "EndOfLine",
						},
					},
				},
			},
		},
		{
			name: "Counter",
			pos:  position{line: 1745, col: 1, offset: 58593},
			expr: &choiceExpr{
				pos: position{line: 1745, col: 11, offset: 58603},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1745, col: 11, offset: 58603},
						name: "CounterIncrement",
					},
					&ruleRefExpr{
						pos:  position{line: 1745, col: 30, offset: 58622},
						name: "CounterSilentIncrement",
					},
				},
			},
		},
		{
			name: "CounterIncrement",
			pos:  position{line: 1747, col: 1, offset: 58646},
			expr: &actionExpr{
				pos: position{line: 1747, col: 20, offset: 58665},
				run: (*parser).callonCounterIncrement1,
				expr: &seqExpr{
					pos: position{line: 1747, col: 20, offset: 58665},
					exprs: []any{
						&notExpr{
							pos: position{line: 1747, col: 20, offset: 58665},
							expr: &litMatcher{
								pos:        position{line: 1747, col: 21, offset: 58666},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 1747, col: 26, offset: 58671},
							val:        "{counter:",
							ignoreCase: false,
							want:       "\"{counter:\"",
						},
						&labeledExpr{
							pos:   position{line: 1747, col: 38, offset: 58683},
							label: "name",
							expr: &ruleRefExpr{
								pos:  position{line: 1747, col: 43, offset: 58688},
								name: "AttributeEntryName",
							},
						},
						&labeledExpr{
							pos:   position{line: 1747, col: 62, offset: 58707},
							label: "initialValue",
							expr: &zeroOrOneExpr{
								pos: position{line: 1747, col: 75, offset: 58720},
								expr: &ruleRefExpr{
									pos:  position{line: 1747, col: 76, offset: 58721},
									name: "CounterInitialValue",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1747, col: 98, offset: 58743},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
					},
				},
			},
		},
		{
			name: "CounterSilentIncrement",
			pos:  position{line: 1751, col: 1, offset: 58844},
			expr: &actionExpr{
				pos: position{line: 1751, col: 26, offset: 58869},
				run: (*parser).callonCounterSilentIncrement1,
				expr: &seqExpr{
					pos: position{line: 1751, col: 26, offset: 58869},
					exprs: []any{
						&notExpr{
							pos: position{line: 1751, col: 26, offset: 58869},
							expr: &litMatcher{
								pos:        position{line: 1751, col: 27, offset: 58870},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 1751, col: 32, offset: 58875},
							val:        "{counter2:",
							ignoreCase: false,
							want:       "\"{counter2:\"",
						},
						&labeledExpr{
							pos:   position{line: 1751, col: 45, offset: 58888},
							label: "name",
							expr: &ruleRefExpr{
								pos:  position{line: 1751, col: 50, offset: 58893},
								name: "AttributeEntryName",
							},
						},
						&labeledExpr{
							pos:   position{line: 1751, col: 69, offset: 58912},
							label: "initialValue",
							expr: &zeroOrOneExpr{
								pos: position{line: 1751, col: 82, offset: 58925},
								expr: &ruleRefExpr{
									pos:  position{line: 1751, col: 83, offset: 58926},
									name: "CounterInitialValue",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1751, col: 105, offset: 58948},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
					},
				},
			},
		},
		{
			name: "CounterInitialValue",
			pos:  position{line: 1755, col: 1, offset: 59050},
			expr: &actionExpr{
				pos: position{line: 1755, col: 23, offset: 59072},
				run: (*parser).callonCounterInitialValue1,
				expr: &seqExpr{
					pos: position{line: 1755, col: 23, offset: 59072},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1755, col: 23, offset: 59072},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 1755, col: 27, offset: 59076},
							label: "initializer",
							expr: &ruleRefExpr{
								pos:  position{line: 1755, col: 40, offset: 59089},
								name: "CounterInitializer",
							},
						},
					},
				},
			},
		},
		{
			name: "CounterInitializer",
			pos:  position{line: 1759, col: 1, offset: 59142},
			expr: &choiceExpr{
				pos: position{line: 1759, col: 23, offset: 59164},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1759, col: 23, offset: 59164},
						run: (*parser).callonCounterInitializer2,
						expr: &charClassMatcher{
							pos:             position{line: 1759, col: 23, offset: 59164},
							val:             "[a-zA-Z]",
							ranges:          []rune{'a', 'z', 'A', 'Z'},
							basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
							ignoreCase:      false,
							inverted:        false,
						},
					},
					&actionExpr{
						pos: position{line: 1762, col: 7, offset: 59220},
						run: (*parser).callonCounterInitializer4,
						expr: &oneOrMoreExpr{
							pos: position{line: 1762, col: 7, offset: 59220},
							expr: &charClassMatcher{
								pos:             position{line: 1762, col: 7, offset: 59220},
								val:             "[0-9]",
								ranges:          []rune{'0', '9'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
						},
					},
				},
			},
		},
		{
			name: "InlinePassthrough",
			pos:  position{line: 1769, col: 1, offset: 59286},
			expr: &actionExpr{
				pos: position{line: 1769, col: 21, offset: 59306},
				run: (*parser).callonInlinePassthrough1,
				expr: &seqExpr{
					pos: position{line: 1769, col: 21, offset: 59306},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1769, col: 21, offset: 59306},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 1769, col: 32, offset: 59317},
								expr: &ruleRefExpr{
									pos:  position{line: 1769, col: 33, offset: 59318},
									name: "FormatAttributes",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1769, col: 53, offset: 59338},
							label: "text",
							expr: &choiceExpr{
								pos: position{line: 1769, col: 59, offset: 59344},
								alternatives: []any{
									&ruleRefExpr{
										pos:  position{line: 1769, col: 59, offset: 59344},
										name: "InlineSinglePassthrough",
									},
									&ruleRefExpr{
										pos:  position{line: 1769, col: 85, offset: 59370},
										name: "InlineDoublePassthrough",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineSinglePassthrough",
			pos:  position{line: 1773, col: 1, offset: 59516},
			expr: &actionExpr{
				pos: position{line: 1773, col: 27, offset: 59542},
				run: (*parser).callonInlineSinglePassthrough1,
				expr: &seqExpr{
					pos: position{line: 1773, col: 27, offset: 59542},
					exprs: []any{
						&notExpr{
							pos: position{line: 1773, col: 27, offset: 59542},
							expr: &ruleRefExpr{
								pos:  position{line: 1773, col: 28, offset: 59543},
								name: "Escape",
							},
						},
						&litMatcher{
							pos:        position{line: 1773, col: 35, offset: 59550},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&andExpr{
							pos: position{line: 1773, col: 39, offset: 59554},
							expr: &notExpr{
								pos: position{line: 1773, col: 41, offset: 59556},
								expr: &litMatcher{
									pos:        position{line: 1773, col: 42, offset: 59557},
									val:        "+",
									ignoreCase: false,
									want:       "\"+\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1773, col: 47, offset: 59562},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1773, col: 54, offset: 59569},
								name: "SinglePassthroughTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 1773, col: 82, offset: 59597},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&notExpr{
							pos: position{line: 1773, col: 86, offset: 59601},
							expr: &litMatcher{
								pos:        position{line: 1773, col: 87, offset: 59602},
								val:        "+",
								ignoreCase: false,
								want:       "\"+\"",
							},
						},
						&andExpr{
							pos: position{line: 1773, col: 91, offset: 59606},
							expr: &notExpr{
								pos: position{line: 1773, col: 93, offset: 59608},
								expr: &ruleRefExpr{
									pos:  position{line: 1773, col: 94, offset: 59609},
									name: "Alphanumeric",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SinglePassthroughTextValue",
			pos:  position{line: 1778, col: 1, offset: 59732},
			expr: &actionExpr{
				pos: position{line: 1778, col: 30, offset: 59761},
				run: (*parser).callonSinglePassthroughTextValue1,
				expr: &seqExpr{
					pos: position{line: 1778, col: 30, offset: 59761},
					exprs: []any{
						&notExpr{
							pos: position{line: 1778, col: 30, offset: 59761},
							expr: &ruleRefExpr{
								pos:  position{line: 1778, col: 31, offset: 59762},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1778, col: 33, offset: 59764},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1778, col: 39, offset: 59770},
								expr: &actionExpr{
									pos: position{line: 1778, col: 40, offset: 59771},
									run: (*parser).callonSinglePassthroughTextValue7,
									expr: &seqExpr{
										pos: position{line: 1778, col: 40, offset: 59771},
										exprs: []any{
											&notExpr{
												pos: position{line: 1778, col: 40, offset: 59771},
												expr: &ruleRefExpr{
													pos:  position{line: 1778, col: 41, offset: 59772},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 1778, col: 43, offset: 59774},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1778, col: 49, offset: 59780},
													expr: &ruleRefExpr{
														pos:  position{line: 1778, col: 50, offset: 59781},
														name: "SinglePassthroughTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SinglePassthroughTextElement",
			pos:  position{line: 1783, col: 1, offset: 60043},
			expr: &actionExpr{
				pos: position{line: 1783, col: 32, offset: 60074},
				run: (*parser).callonSinglePassthroughTextElement1,
				expr: &seqExpr{
					pos: position{line: 1783, col: 32, offset: 60074},
					exprs: []any{
						&notExpr{
							pos: position{line: 1783, col: 32, offset: 60074},
							expr: &seqExpr{
								pos: position{line: 1783, col: 34, offset: 60076},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1783, col: 34, offset: 60076},
										val:        "+",
										ignoreCase: false,
										want:       "\"+\"",
									},
									&notExpr{
										pos: position{line: 1783, col: 38, offset: 60080},
										expr: &litMatcher{
											pos:        position{line: 1783, col: 39, offset: 60081},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1783, col: 44, offset: 60086},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 1783, col: 53, offset: 60095},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineDoublePassthrough",
			pos:  position{line: 1788, col: 1, offset: 60236},
			expr: &actionExpr{
				pos: position{line: 1788, col: 27, offset: 60262},
				run: (*parser).callonInlineDoublePassthrough1,
				expr: &seqExpr{
					pos: position{line: 1788, col: 27, offset: 60262},
					exprs: []any{
						&notExpr{
							pos: position{line: 1788, col: 27, offset: 60262},
							expr: &ruleRefExpr{
								pos:  position{line: 1788, col: 28, offset: 60263},
								name: "DoubleEscape",
							},
						},
						&litMatcher{
							pos:        position{line: 1788, col: 41, offset: 60276},
							val:        "++",
							ignoreCase: false,
							want:       "\"++\"",
						},
						&labeledExpr{
							pos:   position{line: 1788, col: 46, offset: 60281},
							label: "value",
							expr: &ruleRefExpr{
								pos:  position{line: 1788, col: 53, offset: 60288},
								name: "DoublePassthroughTextValue",
							},
						},
						&litMatcher{
							pos:        position{line: 1788, col: 81, offset: 60316},
							val:        "++",
							ignoreCase: false,
							want:       "\"++\"",
						},
					},
				},
			},
		},
		{
			name: "DoublePassthroughTextValue",
			pos:  position{line: 1793, col: 1, offset: 60431},
			expr: &actionExpr{
				pos: position{line: 1793, col: 30, offset: 60460},
				run: (*parser).callonDoublePassthroughTextValue1,
				expr: &seqExpr{
					pos: position{line: 1793, col: 30, offset: 60460},
					exprs: []any{
						&notExpr{
							pos: position{line: 1793, col: 30, offset: 60460},
							expr: &ruleRefExpr{
								pos:  position{line: 1793, col: 31, offset: 60461},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1793, col: 33, offset: 60463},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1793, col: 39, offset: 60469},
								expr: &actionExpr{
									pos: position{line: 1793, col: 40, offset: 60470},
									run: (*parser).callonDoublePassthroughTextValue7,
									expr: &seqExpr{
										pos: position{line: 1793, col: 40, offset: 60470},
										exprs: []any{
											&notExpr{
												pos: position{line: 1793, col: 40, offset: 60470},
												expr: &ruleRefExpr{
													pos:  position{line: 1793, col: 41, offset: 60471},
													name: "_",
												},
											},
											&labeledExpr{
												pos:   position{line: 1793, col: 43, offset: 60473},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1793, col: 49, offset: 60479},
													expr: &ruleRefExpr{
														pos:  position{line: 1793, col: 50, offset: 60480},
														name: "DoublePassthroughTextElement",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoublePassthroughTextElement",
			pos:  position{line: 1798, col: 1, offset: 60754},
			expr: &actionExpr{
				pos: position{line: 1798, col: 32, offset: 60785},
				run: (*parser).callonDoublePassthroughTextElement1,
				expr: &seqExpr{
					pos: position{line: 1798, col: 32, offset: 60785},
					exprs: []any{
						&notExpr{
							pos: position{line: 1798, col: 32, offset: 60785},
							expr: &litMatcher{
								pos:        position{line: 1798, col: 34, offset: 60787},
								val:        "++",
								ignoreCase: false,
								want:       "\"++\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1798, col: 40, offset: 60793},
							label: "element",
							expr: &ruleRefExpr{
								pos:  position{line: 1798, col: 49, offset: 60802},
								name: "FormattedTextElement",
							},
						},
					},
				},
			},
		},
		{
			name: "IfDef",
			pos:  position{line: 1804, col: 1, offset: 60944},
			expr: &actionExpr{
				pos: position{line: 1804, col: 9, offset: 60952},
				run: (*parser).callonIfDef1,
				expr: &seqExpr{
					pos: position{line: 1804, col: 9, offset: 60952},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1804, col: 9, offset: 60952},
							name: "IfDefStatement",
						},
						&labeledExpr{
							pos:   position{line: 1804, col: 24, offset: 60967},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1804, col: 36, offset: 60979},
								name: "ConditionalAttributes",
							},
						},
						&litMatcher{
							pos:        position{line: 1804, col: 59, offset: 61002},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1804, col: 64, offset: 61007},
							expr: &ruleRefExpr{
								pos:  position{line: 1804, col: 64, offset: 61007},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1804, col: 68, offset: 61011},
							expr: &ruleRefExpr{
								pos:  position{line: 1804, col: 69, offset: 61012},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "IfDefStatement",
			pos:  position{line: 1809, col: 1, offset: 61132},
			expr: &actionExpr{
				pos: position{line: 1809, col: 18, offset: 61149},
				run: (*parser).callonIfDefStatement1,
				expr: &litMatcher{
					pos:        position{line: 1809, col: 18, offset: 61149},
					val:        "ifdef::",
					ignoreCase: false,
					want:       "\"ifdef::\"",
				},
			},
		},
		{
			name: "IfNDef",
			pos:  position{line: 1814, col: 1, offset: 61265},
			expr: &actionExpr{
				pos: position{line: 1814, col: 10, offset: 61274},
				run: (*parser).callonIfNDef1,
				expr: &seqExpr{
					pos: position{line: 1814, col: 10, offset: 61274},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1814, col: 10, offset: 61274},
							val:        "ifndef::",
							ignoreCase: false,
							want:       "\"ifndef::\"",
						},
						&labeledExpr{
							pos:   position{line: 1814, col: 21, offset: 61285},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1814, col: 33, offset: 61297},
								name: "ConditionalAttributes",
							},
						},
						&litMatcher{
							pos:        position{line: 1814, col: 56, offset: 61320},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1814, col: 61, offset: 61325},
							expr: &ruleRefExpr{
								pos:  position{line: 1814, col: 61, offset: 61325},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1814, col: 65, offset: 61329},
							expr: &ruleRefExpr{
								pos:  position{line: 1814, col: 66, offset: 61330},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineIfDef",
			pos:  position{line: 1819, col: 1, offset: 61452},
			expr: &actionExpr{
				pos: position{line: 1819, col: 15, offset: 61466},
				run: (*parser).callonInlineIfDef1,
				expr: &seqExpr{
					pos: position{line: 1819, col: 15, offset: 61466},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1819, col: 15, offset: 61466},
							val:        "ifdef::",
							ignoreCase: false,
							want:       "\"ifdef::\"",
						},
						&labeledExpr{
							pos:   position{line: 1819, col: 25, offset: 61476},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1819, col: 37, offset: 61488},
								name: "ConditionalAttributes",
							},
						},
						&litMatcher{
							pos:        position{line: 1819, col: 60, offset: 61511},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 1819, col: 64, offset: 61515},
							label: "content",
							expr: &ruleRefExpr{
								pos:  position{line: 1819, col: 73, offset: 61524},
								name: "InlineConditionalContent",
							},
						},
						&litMatcher{
							pos:        position{line: 1819, col: 99, offset: 61550},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1819, col: 103, offset: 61554},
							expr: &ruleRefExpr{
								pos:  position{line: 1819, col: 103, offset: 61554},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "InlineIfNDef",
			pos:  position{line: 1824, col: 1, offset: 61713},
			expr: &actionExpr{
				pos: position{line: 1824, col: 16, offset: 61728},
				run: (*parser).callonInlineIfNDef1,
				expr: &seqExpr{
					pos: position{line: 1824, col: 16, offset: 61728},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1824, col: 16, offset: 61728},
							val:        "ifndef::",
							ignoreCase: false,
							want:       "\"ifndef::\"",
						},
						&labeledExpr{
							pos:   position{line: 1824, col: 27, offset: 61739},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:  position{line: 1824, col: 39, offset: 61751},
								name: "ConditionalAttributes",
							},
						},
						&litMatcher{
							pos:        position{line: 1824, col: 62, offset: 61774},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 1824, col: 66, offset: 61778},
							label: "content",
							expr: &ruleRefExpr{
								pos:  position{line: 1824, col: 75, offset: 61787},
								name: "InlineConditionalContent",
							},
						},
						&litMatcher{
							pos:        position{line: 1824, col: 101, offset: 61813},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1824, col: 105, offset: 61817},
							expr: &ruleRefExpr{
								pos:  position{line: 1824, col: 105, offset: 61817},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "EndIfDef",
			pos:  position{line: 1829, col: 1, offset: 61978},
			expr: &actionExpr{
				pos: position{line: 1829, col: 12, offset: 61989},
				run: (*parser).callonEndIfDef1,
				expr: &seqExpr{
					pos: position{line: 1829, col: 12, offset: 61989},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1829, col: 12, offset: 61989},
							name: "EndIfDefStatement",
						},
						&labeledExpr{
							pos:   position{line: 1829, col: 30, offset: 62007},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 1829, col: 41, offset: 62018},
								expr: &ruleRefExpr{
									pos:  position{line: 1829, col: 42, offset: 62019},
									name: "ConditionalAttributes",
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1829, col: 66, offset: 62043},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1829, col: 72, offset: 62049},
							expr: &ruleRefExpr{
								pos:  position{line: 1829, col: 72, offset: 62049},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1829, col: 75, offset: 62052},
							expr: &ruleRefExpr{
								pos:  position{line: 1829, col: 76, offset: 62053},
								name: "EndOfLine",
							},
						},
					},
				},
			},
		},
		{
			name: "EndIfDefStatement",
			pos:  position{line: 1839, col: 1, offset: 62340},
			expr: &actionExpr{
				pos: position{line: 1839, col: 21, offset: 62360},
				run: (*parser).callonEndIfDefStatement1,
				expr: &litMatcher{
					pos:        position{line: 1839, col: 21, offset: 62360},
					val:        "endif::",
					ignoreCase: false,
					want:       "\"endif::\"",
				},
			},
		},
		{
			name: "ConditionalAttributes",
			pos:  position{line: 1844, col: 1, offset: 62476},
			expr: &actionExpr{
				pos: position{line: 1844, col: 25, offset: 62500},
				run: (*parser).callonConditionalAttributes1,
				expr: &labeledExpr{
					pos:   position{line: 1844, col: 25, offset: 62500},
					label: "attr",
					expr: &choiceExpr{
						pos: position{line: 1844, col: 31, offset: 62506},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 1844, col: 31, offset: 62506},
								name: "ConditionalAttributesAny",
							},
							&ruleRefExpr{
								pos:  position{line: 1844, col: 58, offset: 62533},
								name: "ConditionalAttributesAll",
							},
						},
					},
				},
			},
		},
		{
			name: "ConditionalAttributesAny",
			pos:  position{line: 1849, col: 1, offset: 62657},
			expr: &actionExpr{
				pos: position{line: 1849, col: 28, offset: 62684},
				run: (*parser).callonConditionalAttributesAny1,
				expr: &labeledExpr{
					pos:   position{line: 1849, col: 28, offset: 62684},
					label: "names",
					expr: &oneOrMoreExpr{
						pos: position{line: 1849, col: 34, offset: 62690},
						expr: &actionExpr{
							pos: position{line: 1850, col: 5, offset: 62696},
							run: (*parser).callonConditionalAttributesAny4,
							expr: &seqExpr{
								pos: position{line: 1850, col: 5, offset: 62696},
								exprs: []any{
									&labeledExpr{
										pos:   position{line: 1850, col: 5, offset: 62696},
										label: "name",
										expr: &ruleRefExpr{
											pos:  position{line: 1850, col: 10, offset: 62701},
											name: "AttributeEntryName",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 1850, col: 29, offset: 62720},
										expr: &ruleRefExpr{
											pos:  position{line: 1850, col: 29, offset: 62720},
											name: "_",
										},
									},
									&zeroOrOneExpr{
										pos: position{line: 1850, col: 32, offset: 62723},
										expr: &litMatcher{
											pos:        position{line: 1850, col: 32, offset: 62723},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 1850, col: 37, offset: 62728},
										expr: &ruleRefExpr{
											pos:  position{line: 1850, col: 37, offset: 62728},
											name: "_",
										},
									},
									&andCodeExpr{
										pos: position{line: 1851, col: 5, offset: 62736},
										run: (*parser).callonConditionalAttributesAny14,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ConditionalAttributesAll",
			pos:  position{line: 1861, col: 1, offset: 62997},
			expr: &actionExpr{
				pos: position{line: 1861, col: 28, offset: 63024},
				run: (*parser).callonConditionalAttributesAll1,
				expr: &labeledExpr{
					pos:   position{line: 1861, col: 28, offset: 63024},
					label: "names",
					expr: &oneOrMoreExpr{
						pos: position{line: 1861, col: 34, offset: 63030},
						expr: &actionExpr{
							pos: position{line: 1862, col: 5, offset: 63036},
							run: (*parser).callonConditionalAttributesAll4,
							expr: &seqExpr{
								pos: position{line: 1862, col: 5, offset: 63036},
								exprs: []any{
									&labeledExpr{
										pos:   position{line: 1862, col: 5, offset: 63036},
										label: "name",
										expr: &ruleRefExpr{
											pos:  position{line: 1862, col: 10, offset: 63041},
											name: "AttributeEntryName",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 1862, col: 29, offset: 63060},
										expr: &ruleRefExpr{
											pos:  position{line: 1862, col: 29, offset: 63060},
											name: "_",
										},
									},
									&zeroOrOneExpr{
										pos: position{line: 1862, col: 32, offset: 63063},
										expr: &litMatcher{
											pos:        position{line: 1862, col: 32, offset: 63063},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
									},
									&zeroOrMoreExpr{
										pos: position{line: 1862, col: 37, offset: 63068},
										expr: &ruleRefExpr{
											pos:  position{line: 1862, col: 37, offset: 63068},
											name: "_",
										},
									},
									&andCodeExpr{
										pos: position{line: 1863, col: 5, offset: 63076},
										run: (*parser).callonConditionalAttributesAll14,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineConditionalContent",
			pos:  position{line: 1873, col: 1, offset: 63337},
			expr: &actionExpr{
				pos: position{line: 1873, col: 28, offset: 63364},
				run: (*parser).callonInlineConditionalContent1,
				expr: &labeledExpr{
					pos:   position{line: 1873, col: 28, offset: 63364},
					label: "content",
					expr: &oneOrMoreExpr{
						pos: position{line: 1873, col: 36, offset: 63372},
						expr: &actionExpr{
							pos: position{line: 1873, col: 37, offset: 63373},
							run: (*parser).callonInlineConditionalContent4,
							expr: &seqExpr{
								pos: position{line: 1873, col: 37, offset: 63373},
								exprs: []any{
									&notExpr{
										pos: position{line: 1873, col: 37, offset: 63373},
										expr: &litMatcher{
											pos:        position{line: 1873, col: 38, offset: 63374},
											val:        "]",
											ignoreCase: false,
											want:       "\"]\"",
										},
									},
									&labeledExpr{
										pos:   position{line: 1873, col: 42, offset: 63378},
										label: "element",
										expr: &ruleRefExpr{
											pos:  position{line: 1873, col: 50, offset: 63386},
											name: "InlineElement",
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IfEval",
			pos:  position{line: 1879, col: 1, offset: 63459},
			expr: &actionExpr{
				pos: position{line: 1879, col: 10, offset: 63468},
				run: (*parser).callonIfEval1,
				expr: &seqExpr{
					pos: position{line: 1879, col: 10, offset: 63468},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1879, col: 10, offset: 63468},
							name: "IfEvalStatement",
						},
						&litMatcher{
							pos:        position{line: 1879, col: 26, offset: 63484},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1879, col: 30, offset: 63488},
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 30, offset: 63488},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1879, col: 33, offset: 63491},
							label: "left",
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 39, offset: 63497},
								name: "IfEvalValue",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1879, col: 52, offset: 63510},
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 52, offset: 63510},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1879, col: 56, offset: 63514},
							label: "operand",
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 65, offset: 63523},
								name: "IfEvalOperator",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1879, col: 81, offset: 63539},
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 81, offset: 63539},
								name: "_",
							},
						},
						&labeledExpr{
							pos:   position{line: 1879, col: 84, offset: 63542},
							label: "right",
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 91, offset: 63549},
								name: "IfEvalValue",
							},
						},
						&zeroOrMoreExpr{
							pos: position{line: 1879, col: 104, offset: 63562},
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 104, offset: 63562},
								name: "_",
							},
						},
						&litMatcher{
							pos:        position{line: 1879, col: 107, offset: 63565},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1879, col: 111, offset: 63569},
							expr: &ruleRefExpr{
								pos:  position{line: 1879, col: 111, offset: 63569},
								name: "_",
							},
						},
					},
				},
			},
		},
		{
			name: "IfEvalStatement",
			pos:  position{line: 1884, col: 1, offset: 63774},
			expr: &actionExpr{
				pos: position{line: 1884, col: 19, offset: 63792},
				run: (*parser).callonIfEvalStatement1,
				expr: &litMatcher{
					pos:        position{line: 1884, col: 19, offset: 63792},
					val:        "ifeval::",
					ignoreCase: false,
					want:       "\"ifeval::\"",
				},
			},
		},
		{
			name: "IfEvalValue",
			pos:  position{line: 1889, col: 1, offset: 63910},
			expr: &actionExpr{
				pos: position{line: 1889, col: 15, offset: 63924},
				run: (*parser).callonIfEvalValue1,
				expr: &labeledExpr{
					pos:   position{line: 1889, col: 15, offset: 63924},
					label: "val",
					expr: &choiceExpr{
						pos: position{line: 1889, col: 20, offset: 63929},
						alternatives: []any{
							&ruleRefExpr{
								pos:  position{line: 1889, col: 20, offset: 63929},
								name: "SingleQuoteAttributeValue",
							},
							&ruleRefExpr{
								pos:  position{line: 1889, col: 48, offset: 63957},
								name: "DoubleQuoteAttributeValue",
							},
							&ruleRefExpr{
								pos:  position{line: 1889, col: 76, offset: 63985},
								name: "NakedAttributeValue",
							},
						},
					},
				},
			},
		},
		{
			name: "IfEvalOperator",
			pos:  position{line: 1903, col: 1, offset: 64614},
			expr: &choiceExpr{
				pos: position{line: 1904, col: 7, offset: 64638},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1904, col: 8, offset: 64639},
						run: (*parser).callonIfEvalOperator2,
						expr: &litMatcher{
							pos:        position{line: 1904, col: 8, offset: 64639},
							val:        "==",
							ignoreCase: false,
							want:       "\"==\"",
						},
					},
					&actionExpr{
						pos: position{line: 1905, col: 8, offset: 64702},
						run: (*parser).callonIfEvalOperator4,
						expr: &litMatcher{
							pos:        position{line: 1905, col: 8, offset: 64702},
							val:        "!=",
							ignoreCase: false,
							want:       "\"!=\"",
						},
					},
					&actionExpr{
						pos: position{line: 1906, col: 8, offset: 64768},
						run: (*parser).callonIfEvalOperator6,
						expr: &litMatcher{
							pos:        position{line: 1906, col: 8, offset: 64768},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
					},
					&actionExpr{
						pos: position{line: 1907, col: 8, offset: 64834},
						run: (*parser).callonIfEvalOperator8,
						expr: &litMatcher{
							pos:        position{line: 1907, col: 8, offset: 64834},
							val:        "<=",
							ignoreCase: false,
							want:       "\"<=\"",
						},
					},
					&actionExpr{
						pos: position{line: 1908, col: 8, offset: 64907},
						run: (*parser).callonIfEvalOperator10,
						expr: &litMatcher{
							pos:        position{line: 1908, col: 8, offset: 64907},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
					},
					&actionExpr{
						pos: position{line: 1909, col: 8, offset: 64976},
						run: (*parser).callonIfEvalOperator12,
						expr: &litMatcher{
							pos:        position{line: 1909, col: 8, offset: 64976},
							val:        ">=",
							ignoreCase: false,
							want:       "\">=\"",
						},
					},
				},
			},
		},
		{
			name: "SpecialCharacter",
			pos:  position{line: 1912, col: 1, offset: 65047},
			expr: &actionExpr{
				pos: position{line: 1912, col: 20, offset: 65066},
				run: (*parser).callonSpecialCharacter1,
				expr: &choiceExpr{
					pos: position{line: 1912, col: 21, offset: 65067},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 1912, col: 21, offset: 65067},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
						&litMatcher{
							pos:        position{line: 1912, col: 27, offset: 65073},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
						&litMatcher{
							pos:        position{line: 1912, col: 33, offset: 65079},
							val:        "&",
							ignoreCase: false,
							want:       "\"&\"",
						},
					},
				},
			},
		},
		{
			name: "SingleTilde",
			pos:  position{line: 1916, col: 1, offset: 65150},
			expr: &seqExpr{
				pos: position{line: 1916, col: 15, offset: 65164},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 1916, col: 15, offset: 65164},
						val:        "`",
						ignoreCase: false,
						want:       "\"`\"",
					},
					&andExpr{
						pos: position{line: 1916, col: 19, offset: 65168},
						expr: &notExpr{
							pos: position{line: 1916, col: 21, offset: 65170},
							expr: &litMatcher{
								pos:        position{line: 1916, col: 22, offset: 65171},
								val:        "`",
								ignoreCase: false,
								want:       "\"`\"",
							},
						},
					},
				},
			},
		},
		{
			name: "Apostrophe",
			pos:  position{line: 1918, col: 1, offset: 65177},
			expr: &choiceExpr{
				pos: position{line: 1918, col: 15, offset: 65191},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1918, col: 15, offset: 65191},
						run: (*parser).callonApostrophe2,
						expr: &seqExpr{
							pos: position{line: 1918, col: 15, offset: 65191},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1918, col: 15, offset: 65191},
									val:        "\\'",
									ignoreCase: false,
									want:       "\"\\\\'\"",
								},
								&andExpr{
									pos: position{line: 1918, col: 21, offset: 65197},
									expr: &charClassMatcher{
										pos:             position{line: 1918, col: 22, offset: 65198},
										val:             "[\\p{L}]",
										classes:         []*unicode.RangeTable{rangeTable("L")},
										basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
										ignoreCase:      false,
										inverted:        false,
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1920, col: 9, offset: 65256},
						run: (*parser).callonApostrophe7,
						expr: &seqExpr{
							pos: position{line: 1920, col: 9, offset: 65256},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1920, col: 9, offset: 65256},
									val:        "'",
									ignoreCase: false,
									want:       "\"'\"",
								},
								&andExpr{
									pos: position{line: 1920, col: 13, offset: 65260},
									expr: &charClassMatcher{
										pos:             position{line: 1920, col: 14, offset: 65261},
										val:             "[\\p{L}]",
										classes:         []*unicode.RangeTable{rangeTable("L")},
										basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
										ignoreCase:      false,
										inverted:        false,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Punctuation",
			pos:  position{line: 1925, col: 1, offset: 65324},
			expr: &actionExpr{
				pos: position{line: 1925, col: 15, offset: 65338},
				run: (*parser).callonPunctuation1,
				expr: &choiceExpr{
					pos: position{line: 1925, col: 17, offset: 65340},
					alternatives: []any{
						&charClassMatcher{
							pos:             position{line: 1925, col: 18, offset: 65341},
							val:             "[,;.?)/:!=\"'@-[\\]]",
							chars:           []rune{',', ';', '.', '?', ')', '/', ':', '!', '=', '"', '\'', ']'},
							ranges:          []rune{'@', '['},
							basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, true, false, true, false, false, true, false, true, true, false, false, false, false, false, false, false, false, false, false, true, true, false, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
							ignoreCase:      false,
							inverted:        false,
						},
						&seqExpr{
							pos: position{line: 1925, col: 41, offset: 65364},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1925, col: 41, offset: 65364},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&notExpr{
									pos: position{line: 1925, col: 45, offset: 65368},
									expr: &litMatcher{
										pos:        position{line: 1925, col: 46, offset: 65369},
										val:        "(",
										ignoreCase: false,
										want:       "\"(\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "LineBreak",
			pos:  position{line: 1930, col: 1, offset: 65487},
			expr: &actionExpr{
				pos: position{line: 1930, col: 13, offset: 65499},
				run: (*parser).callonLineBreak1,
				expr: &seqExpr{
					pos: position{line: 1930, col: 13, offset: 65499},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1930, col: 13, offset: 65499},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1930, col: 17, offset: 65503},
							expr: &ruleRefExpr{
								pos:  position{line: 1930, col: 17, offset: 65503},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1930, col: 20, offset: 65506},
							expr: &ruleRefExpr{
								pos:  position{line: 1930, col: 22, offset: 65508},
								name: "EndOfLine",
							},
						},
						&andCodeExpr{
							pos: position{line: 1930, col: 33, offset: 65519},
							run: (*parser).callonLineBreak8,
						},
					},
				},
			},
		},
		{
			name: "CurvedQuote",
			pos:  position{line: 1938, col: 1, offset: 65732},
			expr: &choiceExpr{
				pos: position{line: 1938, col: 16, offset: 65747},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1938, col: 16, offset: 65747},
						name: "SingleCurvedQuote",
					},
					&ruleRefExpr{
						pos:  position{line: 1938, col: 36, offset: 65767},
						name: "DoubleCurvedQuote",
					},
				},
			},
		},
		{
			name: "DoubleCurvedQuote",
			pos:  position{line: 1940, col: 1, offset: 65787},
			expr: &actionExpr{
				pos: position{line: 1940, col: 21, offset: 65807},
				run: (*parser).callonDoubleCurvedQuote1,
				expr: &choiceExpr{
					pos: position{line: 1940, col: 22, offset: 65808},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 1940, col: 22, offset: 65808},
							val:        "\"`",
							ignoreCase: false,
							want:       "\"\\\"`\"",
						},
						&litMatcher{
							pos:        position{line: 1940, col: 30, offset: 65816},
							val:        "`\"",
							ignoreCase: false,
							want:       "\"`\\\"\"",
						},
					},
				},
			},
		},
		{
			name: "SingleCurvedQuote",
			pos:  position{line: 1942, col: 1, offset: 65854},
			expr: &actionExpr{
				pos: position{line: 1942, col: 21, offset: 65874},
				run: (*parser).callonSingleCurvedQuote1,
				expr: &choiceExpr{
					pos: position{line: 1942, col: 22, offset: 65875},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 1942, col: 22, offset: 65875},
							val:        "'`",
							ignoreCase: false,
							want:       "\"'`\"",
						},
						&litMatcher{
							pos:        position{line: 1942, col: 29, offset: 65882},
							val:        "`'",
							ignoreCase: false,
							want:       "\"`'\"",
						},
					},
				},
			},
		},
		{
			name: "EmptyLine",
			pos:  position{line: 1944, col: 1, offset: 65919},
			expr: &actionExpr{
				pos: position{line: 1944, col: 13, offset: 65931},
				run: (*parser).callonEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 1944, col: 13, offset: 65931},
					exprs: []any{
						&ruleRefExpr{
							pos:  position{line: 1944, col: 13, offset: 65931},
							name: "BeginningOfLine",
						},
						&zeroOrMoreExpr{
							pos: position{line: 1944, col: 29, offset: 65947},
							expr: &ruleRefExpr{
								pos:  position{line: 1944, col: 29, offset: 65947},
								name: "_",
							},
						},
						&ruleRefExpr{
							pos:  position{line: 1944, col: 32, offset: 65950},
							name: "NewLine",
						},
					},
				},
			},
		},
		{
			name: "SoftNewLine",
			pos:  position{line: 1949, col: 1, offset: 66134},
			expr: &seqExpr{
				pos: position{line: 1949, col: 15, offset: 66148},
				exprs: []any{
					&notExpr{
						pos: position{line: 1949, col: 15, offset: 66148},
						expr: &litMatcher{
							pos:        position{line: 1949, col: 16, offset: 66149},
							val:        "\\",
							ignoreCase: false,
							want:       "\"\\\\\"",
						},
					},
					&ruleRefExpr{
						pos:  position{line: 1949, col: 21, offset: 66154},
						name: "NewLine",
					},
				},
			},
		},
		{
			name: "NewLine",
			pos:  position{line: 1951, col: 1, offset: 66163},
			expr: &actionExpr{
				pos: position{line: 1951, col: 11, offset: 66173},
				run: (*parser).callonNewLine1,
				expr: &choiceExpr{
					pos: position{line: 1951, col: 12, offset: 66174},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 1951, col: 12, offset: 66174},
							val:        "\n",
							ignoreCase: false,
							want:       "\"\\n\"",
						},
						&litMatcher{
							pos:        position{line: 1951, col: 19, offset: 66181},
							val:        "\r",
							ignoreCase: false,
							want:       "\"\\r\"",
						},
						&litMatcher{
							pos:        position{line: 1951, col: 26, offset: 66188},
							val:        "\r\n",
							ignoreCase: false,
							want:       "\"\\r\\n\"",
						},
					},
				},
			},
		},
		{
			name: "Percentage",
			pos:  position{line: 1956, col: 1, offset: 66280},
			expr: &actionExpr{
				pos: position{line: 1956, col: 15, offset: 66294},
				run: (*parser).callonPercentage1,
				expr: &seqExpr{
					pos: position{line: 1956, col: 15, offset: 66294},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1956, col: 15, offset: 66294},
							label: "percentage",
							expr: &ruleRefExpr{
								pos:  position{line: 1956, col: 26, offset: 66305},
								name: "PositiveInteger",
							},
						},
						&litMatcher{
							pos:        position{line: 1956, col: 42, offset: 66321},
							val:        "%",
							ignoreCase: false,
							want:       "\"%\"",
						},
					},
				},
			},
		},
		{
			name: "PositiveInteger",
			pos:  position{line: 1960, col: 1, offset: 66357},
			expr: &actionExpr{
				pos: position{line: 1960, col: 20, offset: 66376},
				run: (*parser).callonPositiveInteger1,
				expr: &seqExpr{
					pos: position{line: 1960, col: 20, offset: 66376},
					exprs: []any{
						&oneOrMoreExpr{
							pos: position{line: 1960, col: 21, offset: 66377},
							expr: &charClassMatcher{
								pos:             position{line: 1960, col: 21, offset: 66377},
								val:             "[0-9]",
								ranges:          []rune{'0', '9'},
								basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
								ignoreCase:      false,
								inverted:        false,
							},
						},
						&andCodeExpr{
							pos: position{line: 1960, col: 29, offset: 66385},
							run: (*parser).callonPositiveInteger5,
						},
					},
				},
			},
		},
		{
			name: "NotNewLine",
			pos:  position{line: 1966, col: 1, offset: 66476},
			expr: &notExpr{
				pos: position{line: 1966, col: 14, offset: 66489},
				expr: &ruleRefExpr{
					pos:  position{line: 1966, col: 15, offset: 66490},
					name: "NewLine",
				},
			},
		},
		{
			name: "NotSpace",
			pos:  position{line: 1968, col: 1, offset: 66499},
			expr: &notExpr{
				pos: position{line: 1968, col: 12, offset: 66510},
				expr: &ruleRefExpr{
					pos:  position{line: 1968, col: 13, offset: 66511},
					name: "_",
				},
			},
		},
		{
			name: "Alpha",
			pos:  position{line: 1970, col: 1, offset: 66514},
			expr: &charClassMatcher{
				pos:             position{line: 1970, col: 9, offset: 66522},
				val:             "[\\p{L}]",
				classes:         []*unicode.RangeTable{rangeTable("L")},
				basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
				ignoreCase:      false,
				inverted:        false,
			},
		},
		{
			name: "Alphanumeric",
			pos:  position{line: 1972, col: 1, offset: 66531},
			expr: &charClassMatcher{
				pos:             position{line: 1972, col: 16, offset: 66546},
				val:             "[\\p{L}\\p{N}]",
				classes:         []*unicode.RangeTable{rangeTable("L"), rangeTable("N")},
				basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
				ignoreCase:      false,
				inverted:        false,
			},
		},
		{
			name: "EndOfFile",
			pos:  position{line: 1974, col: 1, offset: 66560},
			expr: &actionExpr{
				pos: position{line: 1974, col: 13, offset: 66572},
				run: (*parser).callonEndOfFile1,
				expr: &notExpr{
					pos: position{line: 1974, col: 13, offset: 66572},
					expr: &anyMatcher{
						line: 1974, col: 14, offset: 66573,
					},
				},
			},
		},
		{
			name: "NotEndOfFile",
			pos:  position{line: 1979, col: 1, offset: 66647},
			expr: &andExpr{
				pos: position{line: 1979, col: 16, offset: 66662},
				expr: &anyMatcher{
					line: 1979, col: 18, offset: 66664,
				},
			},
		},
		{
			name: "BeginningOfLine",
			pos:  position{line: 1981, col: 1, offset: 66668},
			expr: &notExpr{
				pos: position{line: 1981, col: 19, offset: 66686},
				expr: &ruleRefExpr{
					pos:  position{line: 1981, col: 20, offset: 66687},
					name: "OffsetCharacter",
				},
			},
		},
		{
			name: "OffsetCharacter",
			pos:  position{line: 1983, col: 1, offset: 66704},
			expr: &seqExpr{
				pos: position{line: 1983, col: 19, offset: 66722},
				exprs: []any{
					&anyMatcher{
						line: 1983, col: 19, offset: 66722,
					},
					&andCodeExpr{
						pos: position{line: 1983, col: 21, offset: 66724},
						run: (*parser).callonOffsetCharacter3,
					},
				},
			},
		},
		{
			name: "Indent",
			pos:  position{line: 1988, col: 1, offset: 66873},
			expr: &actionExpr{
				pos: position{line: 1988, col: 10, offset: 66882},
				run: (*parser).callonIndent1,
				expr: &seqExpr{
					pos: position{line: 1988, col: 10, offset: 66882},
					exprs: []any{
						&zeroOrMoreExpr{
							pos: position{line: 1988, col: 10, offset: 66882},
							expr: &ruleRefExpr{
								pos:  position{line: 1988, col: 10, offset: 66882},
								name: "_",
							},
						},
						&andExpr{
							pos: position{line: 1988, col: 13, offset: 66885},
							expr: &notExpr{
								pos: position{line: 1988, col: 15, offset: 66887},
								expr: &ruleRefExpr{
									pos:  position{line: 1988, col: 16, offset: 66888},
									name: "_",
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1988, col: 19, offset: 66891},
							run: (*parser).callonIndent8,
						},
					},
				},
			},
		},
		{
			name: "EndOfLine",
			pos:  position{line: 1996, col: 1, offset: 67042},
			expr: &choiceExpr{
				pos: position{line: 1996, col: 13, offset: 67054},
				alternatives: []any{
					&ruleRefExpr{
						pos:  position{line: 1996, col: 13, offset: 67054},
						name: "NewLine",
					},
					&ruleRefExpr{
						pos:  position{line: 1996, col: 23, offset: 67064},
						name: "EndOfFile",
					},
				},
			},
		},
		{
			name: "InlineText",
			pos:  position{line: 1998, col: 1, offset: 67075},
			expr: &labeledExpr{
				pos:   position{line: 1998, col: 14, offset: 67088},
				label: "text",
				expr: &actionExpr{
					pos: position{line: 1998, col: 20, offset: 67094},
					run: (*parser).callonInlineText2,
					expr: &oneOrMoreExpr{
						pos: position{line: 1998, col: 20, offset: 67094},
						expr: &ruleRefExpr{
							pos:  position{line: 1998, col: 20, offset: 67094},
							name: "Alphanumeric",
						},
					},
				},
			},
		},
		{
			name: "UnbrokenText",
			pos:  position{line: 2000, col: 1, offset: 67140},
			expr: &actionExpr{
				pos: position{line: 2000, col: 16, offset: 67155},
				run: (*parser).callonUnbrokenText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 2000, col: 16, offset: 67155},
					expr: &ruleRefExpr{
						pos:  position{line: 2000, col: 16, offset: 67155},
						name: "CharacterClassInline",
					},
				},
			},
		},
		{
			name: "AnyText",
			pos:  position{line: 2005, col: 1, offset: 67268},
			expr: &actionExpr{
				pos: position{line: 2005, col: 11, offset: 67278},
				run: (*parser).callonAnyText1,
				expr: &zeroOrMoreExpr{
					pos: position{line: 2005, col: 11, offset: 67278},
					expr: &ruleRefExpr{
						pos:  position{line: 2005, col: 11, offset: 67278},
						name: "CharacterClassInline",
					},
				},
			},
		},
		{
			name: "AnySpaces",
			pos:  position{line: 2010, col: 1, offset: 67386},
			expr: &actionExpr{
				pos: position{line: 2010, col: 13, offset: 67398},
				run: (*parser).callonAnySpaces1,
				expr: &zeroOrMoreExpr{
					pos: position{line: 2010, col: 13, offset: 67398},
					expr: &ruleRefExpr{
						pos:  position{line: 2010, col: 13, offset: 67398},
						name: "_",
					},
				},
			},
		},
		{
			name: "CharacterClassAll",
			pos:  position{line: 2015, col: 1, offset: 67438},
			expr: &actionExpr{
				pos: position{line: 2015, col: 21, offset: 67458},
				run: (*parser).callonCharacterClassAll1,
				expr: &choiceExpr{
					pos: position{line: 2015, col: 22, offset: 67459},
					alternatives: []any{
						&anyMatcher{
							line: 2015, col: 22, offset: 67459,
						},
						&ruleRefExpr{
							pos:  position{line: 2015, col: 26, offset: 67463},
							name: "NewLine",
						},
					},
				},
			},
		},
		{
			name: "CharacterClassInline",
			pos:  position{line: 2020, col: 1, offset: 67570},
			expr: &charClassMatcher{
				pos:             position{line: 2020, col: 24, offset: 67593},
				val:             "[^\\n]",
				chars:           []rune{'\n'},
				basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
				ignoreCase:      false,
				inverted:        true,
			},
		},
		{
			name: "CharacterGroupWord",
			pos:  position{line: 2022, col: 1, offset: 67601},
			expr: &actionExpr{
				pos: position{line: 2022, col: 22, offset: 67622},
				run: (*parser).callonCharacterGroupWord1,
				expr: &charClassMatcher{
					pos:             position{line: 2022, col: 22, offset: 67622},
					val:             "[\\p{M}\\p{Nd}\\p{Pc}\\p{Join_Control}\\p{L}]",
					classes:         []*unicode.RangeTable{rangeTable("M"), rangeTable("Nd"), rangeTable("Pc"), rangeTable("Join_Control"), rangeTable("L")},
					basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false},
					ignoreCase:      false,
					inverted:        false,
				},
			},
		},
		{
			name: "__",
			pos:  position{line: 2027, col: 1, offset: 67796},
			expr: &actionExpr{
				pos: position{line: 2027, col: 6, offset: 67801},
				run: (*parser).callon__1,
				expr: &oneOrMoreExpr{
					pos: position{line: 2027, col: 6, offset: 67801},
					expr: &ruleRefExpr{
						pos:  position{line: 2027, col: 6, offset: 67801},
						name: "_",
					},
				},
			},
		},
		{
			name: "_",
			pos:  position{line: 2032, col: 1, offset: 67905},
			expr: &actionExpr{
				pos: position{line: 2032, col: 5, offset: 67909},
				run: (*parser).callon_1,
				expr: &charClassMatcher{
					pos:             position{line: 2032, col: 5, offset: 67909},
					val:             "[ \\t]",
					chars:           []rune{' ', '\t'},
					basicLatinChars: [128]bool{false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
					ignoreCase:      false,
					inverted:        false,
				},
			},
		},
		{
			name: "Escape",
			pos:  position{line: 2037, col: 1, offset: 68015},
			expr: &actionExpr{
				pos: position{line: 2037, col: 10, offset: 68024},
				run: (*parser).callonEscape1,
				expr: &litMatcher{
					pos:        position{line: 2037, col: 10, offset: 68024},
					val:        "\\",
					ignoreCase: false,
					want:       "\"\\\\\"",
				},
			},
		},
		{
			name: "DoubleEscape",
			pos:  position{line: 2039, col: 1, offset: 68061},
			expr: &actionExpr{
				pos: position{line: 2039, col: 16, offset: 68076},
				run: (*parser).callonDoubleEscape1,
				expr: &litMatcher{
					pos:        position{line: 2039, col: 16, offset: 68076},
					val:        "\\\\",
					ignoreCase: false,
					want:       "\"\\\\\\\\\"",
				},
			},
		},
	},
}

func (c *current) onDocument1(content any) (any, error) {
	debugPosition(c, "document: %T %s\n", content, string(c.text))
	return flat(content.([]any)), nil
}

func (p *parser) callonDocument1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDocument1(stack["content"])
}

func (c *current) onElement1(element any) (any, error) {
	debugPosition(c, "element: %T %s\n", element, string(c.text))
	return element, nil
}

func (p *parser) callonElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onElement1(stack["element"])
}

func (c *current) onBlockElement7(element any) (bool, error) {
	debugPosition(c, "checking block element: %T %v\n", element, element)
	return element != nil, nil
}

func (p *parser) callonBlockElement7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElement7(stack["element"])
}

func (c *current) onBlockElement1(element any) (any, error) {
	debugPosition(c, "block element: %T %v\n", element, element)
	return compose(c, element.(asciidoc.Element))
}

func (p *parser) callonBlockElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElement1(stack["element"])
}

func (c *current) onBlockElements1(blockElement any) (any, error) {
	debugPosition(c, "matched block element: %T\n", blockElement)
	return blockElement, nil
}

func (p *parser) callonBlockElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElements1(stack["blockElement"])
}

func (c *current) onNakedBlocks1(block any) (any, error) {
	debugPosition(c, "matched naked block element: %T %s\n", block, string(c.text))
	return block, nil
}

func (p *parser) callonNakedBlocks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedBlocks1(stack["block"])
}

func (c *current) onAttributableBlocks22(attributes, element any) (bool, error) {
	return attributes != nil || element != nil, nil

}

func (p *parser) callonAttributableBlocks22() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributableBlocks22(stack["attributes"], stack["element"])
}

func (c *current) onAttributableBlocks1(attributes, element any) (any, error) {
	if element == nil {
		debugPosition(c, "matched naked block attributes: \"%s\"\n", string(c.text))
		return asciidoc.NewBlockAttributes(attributes.(asciidoc.AttributeList)), nil
	}
	if attributes != nil {
		debugPosition(c, "matched attributed element!: %T %v (%d)\n", element, attributes, len(attributes.([]asciidoc.Attribute)))
	}
	debugPosition(c, "matched attributable block element: %T attributes: %T \"%s\"\n", element, attributes, string(c.text))
	return compose(c, element.(asciidoc.AttributableElement), setAttributes[asciidoc.AttributableElement](attributes))

}

func (p *parser) callonAttributableBlocks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributableBlocks1(stack["attributes"], stack["element"])
}

func (c *current) onBlockAttributes4(anchor any) (any, error) {
	return anchor, nil

}

func (p *parser) callonBlockAttributes4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockAttributes4(stack["anchor"])
}

func (c *current) onBlockAttributes7(title any) (any, error) {
	return title, nil

}

func (p *parser) callonBlockAttributes7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockAttributes7(stack["title"])
}

func (c *current) onBlockAttributes10(attributes any) (any, error) {
	return attributes, nil

}

func (p *parser) callonBlockAttributes10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockAttributes10(stack["attributes"])
}

func (c *current) onBlockAttributes13(attributes any) (any, error) {
	return attributes, nil

}

func (p *parser) callonBlockAttributes13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockAttributes13(stack["attributes"])
}

func (c *current) onBlockAttributes1(attribute any) (any, error) {
	debugPosition(c, "matched block attribute: %v\n", attribute)
	return attribute, nil
}

func (p *parser) callonBlockAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockAttributes1(stack["attribute"])
}

func (c *current) onBlockTitle1(content any) (any, error) {
	debugPosition(c, "matched block title!: %s\n", string(c.text))
	els, err := coalesce(content.(asciidoc.Set))
	if err != nil {
		return nil, err
	}
	return asciidoc.NewTitleAttribute(els), nil
}

func (p *parser) callonBlockTitle1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTitle1(stack["content"])
}

func (c *current) onBlockTitleContent1(content any) (any, error) {
	return flat(content.([]any)), nil
}

func (p *parser) callonBlockTitleContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTitleContent1(stack["content"])
}

func (c *current) onBlockEmptyLine1() (any, error) {
	debugPosition(c, "matched block empty line %d chars \"%s\"\n", len(string(c.text)), string(c.text))
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))
}

func (p *parser) callonBlockEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockEmptyLine1()
}

func (c *current) onBlockElementAttribute1(attributes any) (any, error) {
	debugPosition(c, "matched block element attribute: \"%s\"\n", string(c.text))
	return attributes, nil
}

func (p *parser) callonBlockElementAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElementAttribute1(stack["attributes"])
}

func (c *current) onBlockElementAdditionalAttribute1(attributes any) (any, error) {
	debugPosition(c, "matched additional block element attribute: \"%s\"\n", string(c.text))
	return attributes, nil
}

func (p *parser) callonBlockElementAdditionalAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElementAdditionalAttribute1(stack["attributes"])
}

func (c *current) onBlockElementAttributes1(attribute, additionalAttributes any) (any, error) {
	debugPosition(c, "matched block attributes!: %v additional: (%d)\n", attribute, len(additionalAttributes.([]any)))
	attributes := []any{attribute}
	if additionalAttributes != nil {
		attributes = append(attributes, additionalAttributes.([]any)...)
	}
	return extractAttributes(attributes, nil)
}

func (p *parser) callonBlockElementAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElementAttributes1(stack["attribute"], stack["additionalAttributes"])
}

func (c *current) onNakedBlockAttributes1(attribute, additionalAttributes any) (any, error) {
	debugPosition(c, "matched naked block attributes: \"%s\"\n", string(c.text))
	attributes := []any{attribute}
	if additionalAttributes != nil {
		attributes = append(attributes, additionalAttributes.([]any)...)
	}
	as, err := extractAttributes(attributes, nil)
	if err != nil {
		return nil, err
	}
	return asciidoc.NewBlockAttributes(as), nil
}

func (p *parser) callonNakedBlockAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedBlockAttributes1(stack["attribute"], stack["additionalAttributes"])
}

func (c *current) onBlockDelimiters1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonBlockDelimiters1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockDelimiters1(stack["delimiter"])
}

func (c *current) onSection4() (any, error) {
	debugPosition(c, "matched section level %s\n", string(c.text))
	return len(c.text) - 1, nil

}

func (p *parser) callonSection4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSection4()
}

func (c *current) onSection7(level any) (bool, error) {
	debugPosition(c, "check section level: %d\n", level.(int))
	return level.(int) < 6, nil

}

func (p *parser) callonSection7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSection7(stack["level"])
}

func (c *current) onSection1(level, title any) (any, error) {
	debugPosition(c, "matched section\n")
	return compose(c, asciidoc.NewSection(join(flat(title.([]any))), level.(int)))

}

func (p *parser) callonSection1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSection1(stack["level"], stack["title"])
}

func (c *current) onSectionTitleValue1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonSectionTitleValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSectionTitleValue1(stack["element"])
}

func (c *current) onAttributeEntry1(name, value any) (any, error) {
	debugPosition(c, "matched attribute entry: %s value: %v\n", string(c.text), value)
	return compose(c, asciidoc.NewAttributeEntry(name.(string)), setElements[*asciidoc.AttributeEntry](value))
}

func (p *parser) callonAttributeEntry1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeEntry1(stack["name"], stack["value"])
}

func (c *current) onAttributeEntryName1() (any, error) {
	debugPosition(c, "matched attribute entry name: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonAttributeEntryName1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeEntryName1()
}

func (c *current) onAttributeEntryElements1(value any) (any, error) {
	debugPosition(c, "matched attribute entry elements: %s (%d)\n", string(c.text), len(value.([]any)))
	return join[asciidoc.Element](flat(value.([]any))), nil
}

func (p *parser) callonAttributeEntryElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeEntryElements1(stack["value"])
}

func (c *current) onAttributeReset2(name any) (any, error) {
	return compose(c, asciidoc.NewAttributeReset(name.(string)))
}

func (p *parser) callonAttributeReset2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReset2(stack["name"])
}

func (c *current) onAttributeReset10(name any) (any, error) {
	return compose(c, asciidoc.NewAttributeReset(name.(string)))
}

func (p *parser) callonAttributeReset10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReset10(stack["name"])
}

func (c *current) onAttributes1(attributes any) (any, error) {
	debugPosition(c, "matched attributes: %s\n", string(c.text))
	return attributes, nil
}

func (p *parser) callonAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributes1(stack["attributes"])
}

func (c *current) onAttributeList1(attributes any) (any, error) {
	debugPosition(c, "matched attribute list: %s\n", string(c.text))
	return extractAttributes(attributes.([]any), nil)
}

func (p *parser) callonAttributeList1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList1(stack["attributes"])
}

func (c *current) onAttributeListItem1(attribute any) (any, error) {
	return attribute, nil
}

func (p *parser) callonAttributeListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeListItem1(stack["attribute"])
}

func (c *current) onAttribute5(name any) (any, error) {
	return name, nil
}

func (p *parser) callonAttribute5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttribute5(stack["name"])
}

func (c *current) onAttribute1(name, value any) (any, error) {
	if name != nil {
		return asciidoc.NewNamedAttribute(name.(string), value.(*attributeValue).value, value.(*attributeValue).quote), nil
	}
	return asciidoc.NewPositionalAttribute(value.(*attributeValue).value), nil
}

func (p *parser) callonAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttribute1(stack["name"], stack["value"])
}

func (c *current) onShorthandAttributes1(attribute any) (any, error) {
	debugPosition(c, "matched attributes: %s\n", string(c.text))
	return attribute, nil
}

func (p *parser) callonShorthandAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandAttributes1(stack["attribute"])
}

func (c *current) onShorthandAttribute1(style, values any) (any, error) {
	return asciidoc.NewShorthandAttribute(style, values.([]any))
}

func (p *parser) callonShorthandAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandAttribute1(stack["style"], stack["values"])
}

func (c *current) onShorthandStyle1(value any) (any, error) {
	return asciidoc.NewShorthandID(value.(asciidoc.Set)), nil
}

func (p *parser) callonShorthandStyle1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandStyle1(stack["value"])
}

func (c *current) onShorthandID1(value any) (any, error) {
	return asciidoc.NewShorthandID(value.(asciidoc.Set)), nil
}

func (p *parser) callonShorthandID1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandID1(stack["value"])
}

func (c *current) onShorthandRole1(value any) (any, error) {
	return asciidoc.NewShorthandRole(value.(asciidoc.Set)), nil
}

func (p *parser) callonShorthandRole1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandRole1(stack["value"])
}

func (c *current) onShorthandOption1(value any) (any, error) {
	return asciidoc.NewShorthandOption(value.(asciidoc.Set)), nil
}

func (p *parser) callonShorthandOption1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandOption1(stack["value"])
}

func (c *current) onShorthandAttributeValue1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonShorthandAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandAttributeValue1(stack["value"])
}

func (c *current) onSingleQuoteAttributeValue1(value any) (any, error) {
	return &attributeValue{value: join(value.([]any)), quote: asciidoc.AttributeQuoteTypeSingle}, nil
}

func (p *parser) callonSingleQuoteAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleQuoteAttributeValue1(stack["value"])
}

func (c *current) onSingleQuoteAttributeValueElement2() (any, error) {
	return asciidoc.NewString("'"), nil
}

func (p *parser) callonSingleQuoteAttributeValueElement2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleQuoteAttributeValueElement2()
}

func (c *current) onSingleQuoteAttributeValueElement8() (any, error) {
	return asciidoc.NewString(string(c.text)), nil

}

func (p *parser) callonSingleQuoteAttributeValueElement8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleQuoteAttributeValueElement8()
}

func (c *current) onDoubleQuoteAttributeValue1(value any) (any, error) {
	return &attributeValue{value: join(value.([]any)), quote: asciidoc.AttributeQuoteTypeDouble}, nil
}

func (p *parser) callonDoubleQuoteAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleQuoteAttributeValue1(stack["value"])
}

func (c *current) onDoubleQuoteAttributeValueElement2() (any, error) {
	return asciidoc.NewString("\""), nil
}

func (p *parser) callonDoubleQuoteAttributeValueElement2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleQuoteAttributeValueElement2()
}

func (c *current) onDoubleQuoteAttributeValueElement8() (any, error) {
	return asciidoc.NewString(string(c.text)), nil

}

func (p *parser) callonDoubleQuoteAttributeValueElement8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleQuoteAttributeValueElement8()
}

func (c *current) onNakedAttributeValue10() (any, error) {
	// Stop on commas, equals, spaces or end bracket
	return asciidoc.NewString(string(c.text)), nil

}

func (p *parser) callonNakedAttributeValue10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedAttributeValue10()
}

func (c *current) onNakedAttributeValue1(value any) (any, error) {
	debugPosition(c, "matched naked attribute value elements: %s\n", string(c.text))
	return &attributeValue{value: join[asciidoc.Element](flat(value.([]any)))}, nil
}

func (p *parser) callonNakedAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedAttributeValue1(stack["value"])
}

func (c *current) onInlineAttributes1(attributes any) (any, error) {
	debugPosition(c, "matched inline attributes: %s\n", string(c.text))
	return attributes, nil
}

func (p *parser) callonInlineAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAttributes1(stack["attributes"])
}

func (c *current) onNamedAttributeName1() (any, error) {
	debugPosition(c, "matched named attribute name: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonNamedAttributeName1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNamedAttributeName1()
}

func (c *current) onAttributeReference1(attribute any) (any, error) {
	return attribute, nil
}

func (p *parser) callonAttributeReference1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReference1(stack["attribute"])
}

func (c *current) onAttributeReferenceValue1(name any) (any, error) {
	return populatePosition(c, asciidoc.NewAttributeReference(name.(string))), nil
}

func (p *parser) callonAttributeReferenceValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReferenceValue1(stack["name"])
}

func (c *current) onSingleBoldText1(value any) (any, error) {
	debugPosition(c, "match bold text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonSingleBoldText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldText1(stack["value"])
}

func (c *current) onSingleBoldTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleBoldTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldTextValue7(stack["value"])
}

func (c *current) onSingleBoldTextValue1(value any) (any, error) {
	debugPosition(c, "match bold element %s\n", string(c.text))
	return compose(c, asciidoc.NewBold(), setElements[*asciidoc.Bold](flat(value.([]any))))
}

func (p *parser) callonSingleBoldTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldTextValue1(stack["value"])
}

func (c *current) onSingleBoldTextElement1(element any) (any, error) {
	debugPosition(c, "match bold text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSingleBoldTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldTextElement1(stack["element"])
}

func (c *current) onDoubleBoldText1(value any) (any, error) {
	debugPosition(c, "match double bold text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonDoubleBoldText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldText1(stack["value"])
}

func (c *current) onDoubleBoldTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleBoldTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldTextValue7(stack["value"])
}

func (c *current) onDoubleBoldTextValue1(value any) (any, error) {
	debugPosition(c, "match double bold element %s\n", string(c.text))
	return compose(c, asciidoc.NewDoubleBold(), setElements[*asciidoc.DoubleBold](flat(value.([]any))))
}

func (p *parser) callonDoubleBoldTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldTextValue1(stack["value"])
}

func (c *current) onDoubleBoldTextElement1(element any) (any, error) {
	debugPosition(c, "match double bold text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonDoubleBoldTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldTextElement1(stack["element"])
}

func (c *current) onSingleItalicText1(value any) (any, error) {
	debugPosition(c, "match Italic text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonSingleItalicText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicText1(stack["value"])
}

func (c *current) onSingleItalicTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleItalicTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicTextValue7(stack["value"])
}

func (c *current) onSingleItalicTextValue1(value any) (any, error) {
	debugPosition(c, "match Italic element %s\n", string(c.text))
	return asciidoc.NewItalic(flat(value.([]any))), nil
}

func (p *parser) callonSingleItalicTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicTextValue1(stack["value"])
}

func (c *current) onSingleItalicTextElement1(element any) (any, error) {
	debugPosition(c, "match Italic text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSingleItalicTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicTextElement1(stack["element"])
}

func (c *current) onDoubleItalicText1(value any) (any, error) {
	debugPosition(c, "match double Italic text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonDoubleItalicText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicText1(stack["value"])
}

func (c *current) onDoubleItalicTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleItalicTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicTextValue7(stack["value"])
}

func (c *current) onDoubleItalicTextValue1(value any) (any, error) {
	debugPosition(c, "match double Italic element %s\n", string(c.text))
	return asciidoc.NewDoubleItalic(flat(value.([]any))), nil
}

func (p *parser) callonDoubleItalicTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicTextValue1(stack["value"])
}

func (c *current) onDoubleItalicTextElement1(element any) (any, error) {
	debugPosition(c, "match double Italic text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonDoubleItalicTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicTextElement1(stack["element"])
}

func (c *current) onSubscriptText1(value any) (any, error) {
	debugPosition(c, "match subscript text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonSubscriptText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptText1(stack["value"])
}

func (c *current) onSubscriptTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSubscriptTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptTextValue7(stack["value"])
}

func (c *current) onSubscriptTextValue1(value any) (any, error) {
	debugPosition(c, "match subscript element %s\n", string(c.text))
	return compose(c, asciidoc.NewSubscript(), setElements[*asciidoc.Subscript](flat(value.([]any))))
}

func (p *parser) callonSubscriptTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptTextValue1(stack["value"])
}

func (c *current) onSubscriptTextElement1(element any) (any, error) {
	debugPosition(c, "match subscript text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSubscriptTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptTextElement1(stack["element"])
}

func (c *current) onEscapedSubscript1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonEscapedSubscript1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEscapedSubscript1()
}

func (c *current) onSuperscriptText1(value any) (any, error) {
	debugPosition(c, "match superscript text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonSuperscriptText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptText1(stack["value"])
}

func (c *current) onSuperscriptTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSuperscriptTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptTextValue7(stack["value"])
}

func (c *current) onSuperscriptTextValue1(value any) (any, error) {
	debugPosition(c, "match superscript element %s\n", string(c.text))
	return compose(c, asciidoc.NewSuperscript(), setElements[*asciidoc.Superscript](flat(value.([]any))))
}

func (p *parser) callonSuperscriptTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptTextValue1(stack["value"])
}

func (c *current) onSuperscriptTextElement1(element any) (any, error) {
	debugPosition(c, "match superscript text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSuperscriptTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptTextElement1(stack["element"])
}

func (c *current) onEscapedSuperscript1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonEscapedSuperscript1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEscapedSuperscript1()
}

func (c *current) onSingleMonospaceText1(value any) (any, error) {
	debugPosition(c, "match Monospace text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonSingleMonospaceText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceText1(stack["value"])
}

func (c *current) onSingleMonospaceTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleMonospaceTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceTextValue7(stack["value"])
}

func (c *current) onSingleMonospaceTextValue1(value any) (any, error) {
	debugPosition(c, "match Monospace element %s\n", string(c.text))
	return asciidoc.NewMonospace(flat(value.([]any))), nil
}

func (p *parser) callonSingleMonospaceTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceTextValue1(stack["value"])
}

func (c *current) onSingleMonospaceTextElement1(element any) (any, error) {
	debugPosition(c, "match Monospace text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSingleMonospaceTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceTextElement1(stack["element"])
}

func (c *current) onDoubleMonospaceText1(value any) (any, error) {
	debugPosition(c, "match double Monospace text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonDoubleMonospaceText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceText1(stack["value"])
}

func (c *current) onDoubleMonospaceTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleMonospaceTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceTextValue7(stack["value"])
}

func (c *current) onDoubleMonospaceTextValue1(value any) (any, error) {
	debugPosition(c, "match double Monospace element %s\n", string(c.text))
	return asciidoc.NewDoubleMonospace(flat(value.([]any))), nil
}

func (p *parser) callonDoubleMonospaceTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceTextValue1(stack["value"])
}

func (c *current) onDoubleMonospaceTextElement1(element any) (any, error) {
	debugPosition(c, "match double Monospace text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonDoubleMonospaceTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceTextElement1(stack["element"])
}

func (c *current) onAnchor10(label any) (any, error) {
	return label, nil
}

func (p *parser) callonAnchor10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchor10(stack["label"])
}

func (c *current) onAnchor1(id, label any) (any, error) {
	var lbl asciidoc.Set
	if label != nil {
		lbl = join(label.([]any))
	}
	debugPosition(c, "matched anchor: %s\n", string(c.text))
	return compose(c, asciidoc.NewAnchor(id.(string), lbl))
}

func (p *parser) callonAnchor1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchor1(stack["id"], stack["label"])
}

func (c *current) onAnchorAttribute10(label any) (any, error) {
	return label, nil
}

func (p *parser) callonAnchorAttribute10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorAttribute10(stack["label"])
}

func (c *current) onAnchorAttribute1(id, label any) (any, error) {
	var lbl asciidoc.Set
	if label != nil {
		lbl = join(label.([]any))
	}
	debugPosition(c, "matched anchor attribute: %s\n", string(c.text))
	return populatePosition(c, asciidoc.NewAnchorAttribute(asciidoc.NewString(id.(string)), lbl)), nil
}

func (p *parser) callonAnchorAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorAttribute1(stack["id"], stack["label"])
}

func (c *current) onAnchorLabel6() (any, error) {
	return asciidoc.NewString(string(c.text)), nil

}

func (p *parser) callonAnchorLabel6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorLabel6()
}

func (c *current) onAnchorLabel9(arv any) (any, error) {
	return arv, nil

}

func (p *parser) callonAnchorLabel9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorLabel9(stack["arv"])
}

func (c *current) onAnchorLabel12() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonAnchorLabel12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorLabel12()
}

func (c *current) onAdmonition6() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeNote), nil
}

func (p *parser) callonAdmonition6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition6()
}

func (c *current) onAdmonition8() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeTip), nil
}

func (p *parser) callonAdmonition8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition8()
}

func (c *current) onAdmonition10() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeImportant), nil
}

func (p *parser) callonAdmonition10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition10()
}

func (c *current) onAdmonition12() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeCaution), nil
}

func (p *parser) callonAdmonition12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition12()
}

func (c *current) onAdmonition14() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeWarning), nil
}

func (p *parser) callonAdmonition14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition14()
}

func (c *current) onAdmonition1(admonition any) (any, error) {
	debugPosition(c, "matched admonition: %s\n", string(c.text))
	return admonition, nil
}

func (p *parser) callonAdmonition1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition1(stack["admonition"])
}

func (c *current) onInlineElements1(content, eol any) (any, error) {
	debugPosition(c, "inline elements: %s\n", string(c.text))
	els := flat(content.([]any))
	if eol, ok := eol.(*asciidoc.NewLine); ok {
		els = append(els, eol)
	}
	return els, nil
}

func (p *parser) callonInlineElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineElements1(stack["content"], stack["eol"])
}

func (c *current) onInlineElement1(element any) (any, error) {
	debugPosition(c, "inline element: \"%s\" (%T)\n", string(c.text), element)
	return element, nil
}

func (p *parser) callonInlineElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineElement1(stack["element"])
}

func (c *current) onNakedInlineText1() (any, error) {

	debugPosition(c, "matched naked inline text: %s\n", string(c.text))
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonNakedInlineText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedInlineText1()
}

func (c *current) onFootnote1(id, value any) (any, error) {
	return asciidoc.NewFootnote(id.(string), value.([]any)), nil
}

func (p *parser) callonFootnote1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFootnote1(stack["id"], stack["value"])
}

func (c *current) onFootnoteId1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonFootnoteId1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFootnoteId1()
}

func (c *current) onFootnoteValue1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonFootnoteValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFootnoteValue1(stack["element"])
}

func (c *current) onFormattedText1(attributes, text any) (any, error) {
	return compose(c, text.(asciidoc.AttributableElement), setAttributes[asciidoc.AttributableElement](attributes))

}

func (p *parser) callonFormattedText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFormattedText1(stack["attributes"], stack["text"])
}

func (c *current) onFormatAttributes1(attributes any) (any, error) {
	debugPosition(c, "matched shorthand attributes: %s\n", string(c.text))
	return attributes, nil
}

func (p *parser) callonFormatAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFormatAttributes1(stack["attributes"])
}

func (c *current) onBlockImage1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewBlockImage(path.(asciidoc.Set)), setAttributes[*asciidoc.BlockImage](attributes))
}

func (p *parser) callonBlockImage1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockImage1(stack["path"], stack["attributes"])
}

func (c *current) onInlineImage1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewInlineImage(path.(asciidoc.Set)), setAttributes[*asciidoc.InlineImage](attributes))
}

func (p *parser) callonInlineImage1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineImage1(stack["path"], stack["attributes"])
}

func (c *current) onIcon5() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonIcon5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIcon5()
}

func (c *current) onIcon1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewIcon(path.(string)), setAttributes[*asciidoc.Icon](attributes))
}

func (p *parser) callonIcon1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIcon1(stack["path"], stack["attributes"])
}

func (c *current) onFileInclude1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewFileInclude(), setElements[*asciidoc.FileInclude](path), setAttributes[*asciidoc.FileInclude](attributes))
}

func (p *parser) callonFileInclude1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFileInclude1(stack["path"], stack["attributes"])
}

func (c *current) onFileIncludePath1(path any) (any, error) {
	return path, nil
}

func (p *parser) callonFileIncludePath1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFileIncludePath1(stack["path"])
}

func (c *current) onLink1(link any) (any, error) {
	debugPosition(c, "matched link\n")
	return link, nil
}

func (p *parser) callonLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLink1(stack["link"])
}

func (c *current) onHTMLLink1(url any) (any, error) {
	debugPosition(c, "matched HTML link\n")
	return asciidoc.NewLink(url.(asciidoc.URL)), nil
}

func (p *parser) callonHTMLLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLLink1(stack["url"])
}

func (c *current) onPrefixedLink1(url, attributes any) (any, error) {
	debugPosition(c, "matched link:\n")

	return compose(c, asciidoc.NewLink(url.(asciidoc.URL)), setAttributes[*asciidoc.Link](attributes))
}

func (p *parser) callonPrefixedLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrefixedLink1(stack["url"], stack["attributes"])
}

func (c *current) onExternalLink1(url, attributes any) (any, error) {
	debugPosition(c, "matched external link\n")
	return compose(c, asciidoc.NewLink(url.(asciidoc.URL)), setAttributes[*asciidoc.Link](attributes))
}

func (p *parser) callonExternalLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExternalLink1(stack["url"], stack["attributes"])
}

func (c *current) onTable1(attributes, cells any) (any, error) {
	debugPosition(c, "TABLE: matched table \"%s\" (%v)\n", string(c.text), attributes)
	table, err := parseTable(attributes, cells.([]any))
	if err != nil {
		return nil, err
	}
	debugPosition(c, "TABLE: matched table row count %d\n", len(table.Set))
	return compose(c, table)
}

func (p *parser) callonTable1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTable1(stack["attributes"], stack["cells"])
}

func (c *current) onTableElements1(te any) (any, error) {
	debugPosition(c, "TABLE: matched table elements \"%s\" (%T)\n", string(c.text), te)
	return te, nil
}

func (p *parser) callonTableElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableElements1(stack["te"])
}

func (c *current) onTableElement1(element any) (any, error) {
	debugPosition(c, "TABLE: matched table element \"%s\" (%T)\n", string(c.text), element)
	return element, nil
}

func (p *parser) callonTableElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableElement1(stack["element"])
}

func (c *current) onTableStart1() (any, error) {
	debugPosition(c, "TABLE: matched table start %s\n", string(c.text))
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonTableStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableStart1()
}

func (c *current) onTableEmptyLine1() (any, error) {
	debugPosition(c, "TABLE: matched table empty line %s\n", string(c.text))
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))
}

func (p *parser) callonTableEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableEmptyLine1()
}

func (c *current) onTableIfDef1(ifdef any) (any, error) {
	debugPosition(c, "TABLE: matched table ifdef %s\n", string(c.text))
	return compose(c, ifdef.(*asciidoc.IfDef))
}

func (p *parser) callonTableIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableIfDef1(stack["ifdef"])
}

func (c *current) onTableIfNDef1(ifndef any) (any, error) {
	debugPosition(c, "TABLE: matched table ifndef %s\n", string(c.text))
	return compose(c, ifndef.(*asciidoc.IfNDef))
}

func (p *parser) callonTableIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableIfNDef1(stack["ifndef"])
}

func (c *current) onTableEndIfDef1(endifdef any) (any, error) {
	debugPosition(c, "TABLE: matched table end if %s\n", string(c.text))
	return compose(c, endifdef.(*asciidoc.EndIf))
}

func (p *parser) callonTableEndIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableEndIfDef1(stack["endifdef"])
}

func (c *current) onTableComment1(comment any) (any, error) {
	debugPosition(c, "TABLE: matched table comment %s\n", string(c.text))
	return compose(c, comment.(*asciidoc.SingleLineComment))
}

func (p *parser) callonTableComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableComment1(stack["comment"])
}

func (c *current) onTableMultiLineComment1(comment any) (any, error) {
	debugPosition(c, "TABLE: matched table multiline comment %s\n", string(c.text))
	return compose(c, comment.(*asciidoc.MultiLineComment))
}

func (p *parser) callonTableMultiLineComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableMultiLineComment1(stack["comment"])
}

func (c *current) onTableCellInlineContent1(content any) (any, error) {
	debugPosition(c, "TABLE: matched table cell inline content: %s\n", string(c.text))
	return trim(mergeStrings(flat(content.([]any)))), nil
}

func (p *parser) callonTableCellInlineContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellInlineContent1(stack["content"])
}

func (c *current) onTableCellInlineContentElement1(element any) (any, error) {
	debugPosition(c, "TABLE: inline table element: \"%s\"\n", string(c.text))
	return element, nil
}

func (p *parser) callonTableCellInlineContentElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellInlineContentElement1(stack["element"])
}

func (c *current) onTableEnd1() (any, error) {
	debugPosition(c, "TABLE: matched table end %s\n", string(c.text))
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonTableEnd1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableEnd1()
}

func (c *current) onTableRow1(initial, additional any) (any, error) {
	debugPosition(c, "TABLE ROW: matched table row \"%s\"\n", string(c.text))

	var rows = []*asciidoc.TableCell{initial.(*asciidoc.TableCell)}
	if len(additional.([]any)) > 0 {
		rows = append(rows, cast[any, *asciidoc.TableCell](additional.([]any))...)
	}
	return rows, nil
}

func (p *parser) callonTableRow1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableRow1(stack["initial"], stack["additional"])
}

func (c *current) onInitialInlineTableCell1(format, content any) (any, error) {
	debugPosition(c, "TABLE: matched initial inline table cell \"%s\" (format:%v)\n", string(c.text), format)
	return compose(c, newTableCell(format), setElements[*asciidoc.TableCell](content.(asciidoc.Set)))
}

func (p *parser) callonInitialInlineTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialInlineTableCell1(stack["format"], stack["content"])
}

func (c *current) onAdditionalInlineTableCell1(format, content any) (any, error) {
	debugPosition(c, "TABLE: matched additional inline table cell \"%s\" (format:%v)\n", string(c.text), format)
	return compose(c, newTableCell(format), setElements[*asciidoc.TableCell](content.(asciidoc.Set)))
}

func (p *parser) callonAdditionalInlineTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalInlineTableCell1(stack["format"], stack["content"])
}

func (c *current) onInitialBlockTableCell17(format, content any) (bool, error) {
	debugPosition(c, "TABLE: checking block initial table cell\n")
	return format != nil && format.(*asciidoc.TableCellFormat).Style.Value == asciidoc.TableCellStyleAsciiDoc, nil

}

func (p *parser) callonInitialBlockTableCell17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialBlockTableCell17(stack["format"], stack["content"])
}

func (c *current) onInitialBlockTableCell1(format, content any) (any, error) {
	debugPosition(c, "TABLE: matched initial block table cell \"%s\" (format:%v)\n", string(c.text), format)
	return compose(c, newTableCell(format), setElements[*asciidoc.TableCell](asciidoc.Set(cast[any, asciidoc.Element](content.([]any)))))
}

func (p *parser) callonInitialBlockTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialBlockTableCell1(stack["format"], stack["content"])
}

func (c *current) onAdditionalBlockTableCell17(format, content any) (bool, error) {
	debugPosition(c, "TABLE: checking additional block table cell\n")
	return format != nil && format.(*asciidoc.TableCellFormat).Style.Value == asciidoc.TableCellStyleAsciiDoc, nil

}

func (p *parser) callonAdditionalBlockTableCell17() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalBlockTableCell17(stack["format"], stack["content"])
}

func (c *current) onAdditionalBlockTableCell1(format, content any) (any, error) {
	debugPosition(c, "TABLE: matched additional block table cell \"%s\" (format:%v) (%T)\n", string(c.text), format, content)
	return compose(c, newTableCell(format), setElements[*asciidoc.TableCell](asciidoc.Set(cast[any, asciidoc.Element](content.([]any)))))
}

func (p *parser) callonAdditionalBlockTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalBlockTableCell1(stack["format"], stack["content"])
}

func (c *current) onInlineTableLines1(content any) (any, error) {
	debugPosition(c, "TABLE: matched inline table lines \"%s\" (%T)\n", string(c.text), content)
	return content, nil
}

func (p *parser) callonInlineTableLines1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableLines1(stack["content"])
}

func (c *current) onEmptyCell1() (any, error) {
	debugPosition(c, "TABLE: empty cell: \"%s\"\n", string(c.text))
	return asciidoc.Set{asciidoc.NewString(string(c.text))}, nil
}

func (p *parser) callonEmptyCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmptyCell1()
}

func (c *current) onMultiLineTableCell1(lines, content any) (any, error) {
	var cellLines asciidoc.Set
	if lines != nil {
		debugPosition(c, "TABLE LINES: inline table lines (%d), content (%d): \"%s\"\n", len(lines.([]any)), len(content.([]asciidoc.Element)), string(c.text))
		cellLines = flat(lines.([]any))
	} else {
		debugPosition(c, "TABLE CELL: inline table lines (0), content (%d): \"%s\"\n", len(content.([]any)), string(c.text))
	}
	cellLines = append(cellLines, content.([]asciidoc.Element)...)
	return trim(cellLines), nil
}

func (p *parser) callonMultiLineTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineTableCell1(stack["lines"], stack["content"])
}

func (c *current) onInlineTableCellIntermediateLine13(nl any) (any, error) {
	return nl, nil
}

func (p *parser) callonInlineTableCellIntermediateLine13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellIntermediateLine13(stack["nl"])
}

func (c *current) onInlineTableCellIntermediateLine1(newline, content, newlineBeforeEmptyLine any) (any, error) {
	debugPosition(c, "TABLE: inline table intermediate cell line (%d): \"%s\"\n", len(content.([]any)), string(c.text))
	var els []asciidoc.Element
	if newline != nil {
		els = []asciidoc.Element{newline.(*asciidoc.NewLine)}
	}
	els = append(els, trim(mergeStrings(flat(content.([]any))))...)
	if newlineBeforeEmptyLine != nil {
		els = append(els, newlineBeforeEmptyLine.(*asciidoc.NewLine))
	}
	return els, nil
}

func (p *parser) callonInlineTableCellIntermediateLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellIntermediateLine1(stack["newline"], stack["content"], stack["newlineBeforeEmptyLine"])
}

func (c *current) onInlineTableCellEmptyLine1() (any, error) {
	debugPosition(c, "TABLE: inline table intermediate cell empty line (%d): \"%s\"\n", string(c.text))
	return asciidoc.Set{asciidoc.EmptyLine{}}, nil
}

func (p *parser) callonInlineTableCellEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellEmptyLine1()
}

func (c *current) onInlineTableCellLastLine1(nl, content any) (any, error) {
	debugPosition(c, "TABLE: inline table last cell line (%d): \"%s\"\n", len(content.([]any)), string(c.text))
	var els = []asciidoc.Element{nl.(*asciidoc.NewLine)}
	els = append(els, trim(mergeStrings(flat(content.([]any))))...)
	return els, nil
}

func (p *parser) callonInlineTableCellLastLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellLastLine1(stack["nl"], stack["content"])
}

func (c *current) onBlockTableCellLine1(content any) (any, error) {
	debugPosition(c, "TABLE: block table cell line: \"%s\"\n", string(c.text))
	return content, nil
}

func (p *parser) callonBlockTableCellLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTableCellLine1(stack["content"])
}

func (c *current) onBlockTableCellLastLine1(content any) (any, error) {
	debugPosition(c, "TABLE: inline table last cell line (%d): \"%s\"\n", len(content.([]any)), string(c.text))
	return trim(mergeStrings(flat(content.([]any)))), nil
}

func (p *parser) callonBlockTableCellLastLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTableCellLastLine1(stack["content"])
}

func (c *current) onInlineTableElements1(content any) (any, error) {
	debugPosition(c, "TABLE: inline table elements (%d): %s\n", len(content.([]any)), string(c.text))
	return trim(mergeStrings(flat(content.([]any)))), nil
}

func (p *parser) callonInlineTableElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableElements1(stack["content"])
}

func (c *current) onInlineTableElement1(element any) (any, error) {
	debugPosition(c, "TABLE: inline table element: \"%s\"\n", string(c.text))
	return element, nil
}

func (p *parser) callonInlineTableElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableElement1(stack["element"])
}

func (c *current) onBlockTableElement1(element any) (any, error) {
	debugPosition(c, "TABLE: block table element %T: %s\n", element, string(c.text))
	return element, nil
}

func (p *parser) callonBlockTableElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTableElement1(stack["element"])
}

func (c *current) onNakedInlineTableCellText1() (any, error) {

	debugPosition(c, "TABLE: matched naked inline table cell text: %s\n", string(c.text))
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonNakedInlineTableCellText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedInlineTableCellText1()
}

func (c *current) onCharacterClassTableCell1() (any, error) {
	debugPosition(c, "TABLE: matched table cell character: \"%s\"\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonCharacterClassTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCharacterClassTableCell1()
}

func (c *current) onInitialTableCellDelimiter1(format any) (any, error) {
	debugPosition(c, "TABLE: matched initial table cell delimiter %s\n", string(c.text))
	if format != nil {
		return format, nil
	}
	return asciidoc.NewTableCellFormat(), nil
}

func (p *parser) callonInitialTableCellDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialTableCellDelimiter1(stack["format"])
}

func (c *current) onAdditionalTableCellDelimiter1(format any) (any, error) {
	debugPosition(c, "TABLE: matched additional table cell delimiter \"%s\" format:%v\n", string(c.text), format)
	return format, nil
}

func (p *parser) callonAdditionalTableCellDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalTableCellDelimiter1(stack["format"])
}

func (c *current) onInitialTableCellFormat7(format any) (bool, error) {
	debugPosition(c, "TABLE: checking initial table cell format \"%s\"\n", string(c.text))
	return format != nil, nil
}

func (p *parser) callonInitialTableCellFormat7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialTableCellFormat7(stack["format"])
}

func (c *current) onInitialTableCellFormat1(format any) (any, error) {
	debugPosition(c, "TABLE: matched initial table cell format \"%s\"\n", string(c.text))
	return format, nil
}

func (p *parser) callonInitialTableCellFormat1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialTableCellFormat1(stack["format"])
}

func (c *current) onAdditionalTableCellFormat8(lead, format any) (bool, error) {
	debugPosition(c, "TABLE: checking table cell format \"%s\"\n", string(c.text))
	return lead != nil && format != nil, nil
}

func (p *parser) callonAdditionalTableCellFormat8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalTableCellFormat8(stack["lead"], stack["format"])
}

func (c *current) onAdditionalTableCellFormat1(lead, format any) (any, error) {
	debugPosition(c, "TABLE: matched table cell format \"%s\"\n", string(c.text))
	return format, nil
}

func (p *parser) callonAdditionalTableCellFormat1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalTableCellFormat1(stack["lead"], stack["format"])
}

func (c *current) onTableCellSpan5(n any) (any, error) {

	debugPosition(c, "TABLE: matched col span:%s\n", string(c.text))
	return n, nil
}

func (p *parser) callonTableCellSpan5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellSpan5(stack["n"])
}

func (c *current) onTableCellSpan10(n any) (any, error) {

	debugPosition(c, "TABLE: matched row span:%s\n", string(c.text))
	return n, nil

}

func (p *parser) callonTableCellSpan10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellSpan10(stack["n"])
}

func (c *current) onTableCellSpan1(column, row any) (any, error) {
	span := asciidoc.NewTableCellSpan()
	span.Column = asciidoc.Maybe[int](column, span.Column.Value)
	span.Row = asciidoc.Maybe[int](row, span.Row.Value)
	return span, nil

}

func (p *parser) callonTableCellSpan1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellSpan1(stack["column"], stack["row"])
}

func (c *current) onTableCellFormat8() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonTableCellFormat8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat8()
}

func (c *current) onTableCellFormat5(multiplier any) (any, error) {

	return strconv.Atoi(multiplier.(string))

}

func (p *parser) callonTableCellFormat5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat5(stack["multiplier"])
}

func (c *current) onTableCellFormat16(span any) (any, error) {
	debugPosition(c, "TABLE: checking span: %s %T %v\n", string(c.text), span, span)
	return span, nil

}

func (p *parser) callonTableCellFormat16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat16(stack["span"])
}

func (c *current) onTableCellFormat22() (any, error) {
	return asciidoc.TableCellHorizontalAlignLeft, nil
}

func (p *parser) callonTableCellFormat22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat22()
}

func (c *current) onTableCellFormat24() (any, error) {
	return asciidoc.TableCellHorizontalAlignRight, nil
}

func (p *parser) callonTableCellFormat24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat24()
}

func (c *current) onTableCellFormat26() (any, error) {
	return asciidoc.TableCellHorizontalAlignCenter, nil
}

func (p *parser) callonTableCellFormat26() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat26()
}

func (c *current) onTableCellFormat31() (any, error) {
	return asciidoc.TableCellVerticalAlignTop, nil
}

func (p *parser) callonTableCellFormat31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat31()
}

func (c *current) onTableCellFormat33() (any, error) {
	return asciidoc.TableCellVerticalAlignBottom, nil
}

func (p *parser) callonTableCellFormat33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat33()
}

func (c *current) onTableCellFormat35() (any, error) {
	return asciidoc.TableCellVerticalAlignMiddle, nil
}

func (p *parser) callonTableCellFormat35() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat35()
}

func (c *current) onTableCellFormat40() (any, error) {
	return asciidoc.TableCellStyleAsciiDoc, nil
}

func (p *parser) callonTableCellFormat40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat40()
}

func (c *current) onTableCellFormat42() (any, error) {
	return asciidoc.TableCellStyleDefault, nil
}

func (p *parser) callonTableCellFormat42() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat42()
}

func (c *current) onTableCellFormat44() (any, error) {
	return asciidoc.TableCellStyleEmphasis, nil
}

func (p *parser) callonTableCellFormat44() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat44()
}

func (c *current) onTableCellFormat46() (any, error) {
	return asciidoc.TableCellStyleHeader, nil
}

func (p *parser) callonTableCellFormat46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat46()
}

func (c *current) onTableCellFormat48() (any, error) {
	return asciidoc.TableCellStyleLiteral, nil
}

func (p *parser) callonTableCellFormat48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat48()
}

func (c *current) onTableCellFormat50() (any, error) {
	return asciidoc.TableCellStyleMonospace, nil
}

func (p *parser) callonTableCellFormat50() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat50()
}

func (c *current) onTableCellFormat52() (any, error) {
	return asciidoc.TableCellStyleStrong, nil
}

func (p *parser) callonTableCellFormat52() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat52()
}

func (c *current) onTableCellFormat54(multiplier, span, horizontalAlign, verticalAlign, style any) (bool, error) {
	return (multiplier != nil || span != nil || horizontalAlign != nil || verticalAlign != nil || style != nil), nil

}

func (p *parser) callonTableCellFormat54() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat54(stack["multiplier"], stack["span"], stack["horizontalAlign"], stack["verticalAlign"], stack["style"])
}

func (c *current) onTableCellFormat1(multiplier, span, horizontalAlign, verticalAlign, style any) (any, error) {
	debugPosition(c, "TABLE: matched table cell format: %s\n", string(c.text))
	format := asciidoc.NewTableCellFormat()
	format.Multiplier = asciidoc.Maybe[int](multiplier, format.Multiplier.Value)
	if span != nil {
		format.Span = span.(asciidoc.TableCellSpan)
	}
	format.HorizontalAlign = asciidoc.Maybe[asciidoc.TableCellHorizontalAlign](horizontalAlign, format.HorizontalAlign.Value)
	format.VerticalAlign = asciidoc.Maybe[asciidoc.TableCellVerticalAlign](verticalAlign, format.VerticalAlign.Value)
	format.Style = asciidoc.Maybe[asciidoc.TableCellStyle](style, format.Style.Value)
	return format, nil
}

func (p *parser) callonTableCellFormat1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat1(stack["multiplier"], stack["span"], stack["horizontalAlign"], stack["verticalAlign"], stack["style"])
}

func (c *current) onURLScheme1() (any, error) {
	debugPosition(c, "matched url scheme\n")
	return string(c.text), nil
}

func (p *parser) callonURLScheme1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onURLScheme1()
}

func (c *current) onURL1(scheme, path any) (any, error) {
	debugPosition(c, "matched url\n")
	s, _ := scheme.(string)
	return compose(c, asciidoc.NewURL(s, path.(asciidoc.Set)))
}

func (p *parser) callonURL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onURL1(stack["scheme"], stack["path"])
}

func (c *current) onFullURL1(scheme, path any) (any, error) {
	debugPosition(c, "matched full url\n")
	return compose(c, asciidoc.NewURL(scheme.(string), path.(asciidoc.Set)))
}

func (p *parser) callonFullURL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFullURL1(stack["scheme"], stack["path"])
}

func (c *current) onPath1(elements any) (any, error) {
	debugPosition(c, "matched path \"%s\"\n", string(c.text))
	return mergeStrings(elements.([]any)), nil
}

func (p *parser) callonPath1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPath1(stack["elements"])
}

func (c *current) onPathElement2() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonPathElement2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPathElement2()
}

func (c *current) onPathElement5() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonPathElement5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPathElement5()
}

func (c *current) onEmail1(name, domain any) (any, error) {
	return compose(c, asciidoc.NewEmail(name.(string)+"@"+domain.(string)))
}

func (p *parser) callonEmail1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmail1(stack["name"], stack["domain"])
}

func (c *current) onEmailName4() (any, error) {
	// See https://en.wikipedia.org/wiki/Email_address#Local-part
	return string(c.text), nil
}

func (p *parser) callonEmailName4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailName4()
}

func (c *current) onEmailName9(name any) (bool, error) {
	n := name.(string)
	return !strings.Contains(n, "..") && !strings.HasPrefix(n, ".") && !strings.HasSuffix(n, "."), nil
}

func (p *parser) callonEmailName9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailName9(stack["name"])
}

func (c *current) onEmailName1(name any) (any, error) {
	return name.(string), nil
}

func (p *parser) callonEmailName1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailName1(stack["name"])
}

func (c *current) onEmailDomain4() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonEmailDomain4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailDomain4()
}

func (c *current) onEmailDomain15(domain any) (bool, error) {
	d := domain.(string)
	return !strings.HasPrefix(d, "-") && !strings.HasSuffix(d, "-"), nil
}

func (p *parser) callonEmailDomain15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailDomain15(stack["domain"])
}

func (c *current) onEmailDomain1(domain any) (any, error) {
	return domain.(string), nil
}

func (p *parser) callonEmailDomain1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailDomain1(stack["domain"])
}

func (c *current) onListing1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewListing(start.(asciidoc.Delimiter)), setLines[*asciidoc.Listing](cast[any, string](lines.([]any))))

}

func (p *parser) callonListing1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListing1(stack["start"], stack["lines"])
}

func (c *current) onListingStart7(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeListing, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonListingStart7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingStart7(stack["delimiter"])
}

func (c *current) onListingStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonListingStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingStart1(stack["delimiter"])
}

func (c *current) onListingEnd7(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeListing)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeListing)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonListingEnd7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingEnd7(stack["delimiter"])
}

func (c *current) onListingHyphens8(hyphens any) (bool, error) {
	return delimitedLength(hyphens) == 4, nil

}

func (p *parser) callonListingHyphens8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingHyphens8(stack["hyphens"])
}

func (c *current) onListingHyphens1(hyphens any) (any, error) {

	return delimitedLength(hyphens), nil

}

func (p *parser) callonListingHyphens1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingHyphens1(stack["hyphens"])
}

func (c *current) onListingDelimiter1(hyphens any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeListing, Length: hyphens.(int)}, nil

}

func (p *parser) callonListingDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingDelimiter1(stack["hyphens"])
}

func (c *current) onListingLine1(line any) (any, error) {
	debugPosition(c, "matched listing line \"%s\" (%d)\n", line.(string), len(line.(string)))
	return line.(string), nil
}

func (p *parser) callonListingLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingLine1(stack["line"])
}

func (c *current) onOpen1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewOpenBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.OpenBlock](join(lines.([]any))))

}

func (p *parser) callonOpen1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpen1(stack["start"], stack["lines"])
}

func (c *current) onOpenStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeOpen, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonOpenStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenStart6(stack["delimiter"])
}

func (c *current) onOpenStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonOpenStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenStart1(stack["delimiter"])
}

func (c *current) onOpenEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeOpen)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeOpen)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonOpenEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenEnd6(stack["delimiter"])
}

func (c *current) onOpenEquals1(hyphens any) (any, error) {

	return string(c.text), nil

}

func (p *parser) callonOpenEquals1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenEquals1(stack["hyphens"])
}

func (c *current) onOpenDelimiter1(hyphens any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeOpen, Length: len(hyphens.(string))}, nil

}

func (p *parser) callonOpenDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenDelimiter1(stack["hyphens"])
}

func (c *current) onSingleMarkedText1(value any) (any, error) {
	debugPosition(c, "match Marked text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonSingleMarkedText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedText1(stack["value"])
}

func (c *current) onSingleMarkedTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleMarkedTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedTextValue7(stack["value"])
}

func (c *current) onSingleMarkedTextValue1(value any) (any, error) {
	debugPosition(c, "match Marked element %s\n", string(c.text))
	return compose(c, asciidoc.NewMarked(), setElements[*asciidoc.Marked](flat(value.([]any))))
}

func (p *parser) callonSingleMarkedTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedTextValue1(stack["value"])
}

func (c *current) onSingleMarkedTextElement1(element any) (any, error) {
	debugPosition(c, "match Marked text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSingleMarkedTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedTextElement1(stack["element"])
}

func (c *current) onDoubleMarkedText1(value any) (any, error) {
	debugPosition(c, "match double Marked text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonDoubleMarkedText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedText1(stack["value"])
}

func (c *current) onDoubleMarkedTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleMarkedTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedTextValue7(stack["value"])
}

func (c *current) onDoubleMarkedTextValue1(value any) (any, error) {
	debugPosition(c, "match double Marked element %s\n", string(c.text))
	return compose(c, asciidoc.NewDoubleMarked(), setElements[*asciidoc.DoubleMarked](flat(value.([]any))))
}

func (p *parser) callonDoubleMarkedTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedTextValue1(stack["value"])
}

func (c *current) onDoubleMarkedTextElement1(element any) (any, error) {
	debugPosition(c, "match double Marked text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonDoubleMarkedTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedTextElement1(stack["element"])
}

func (c *current) onExample1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewExampleBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.ExampleBlock](join(lines.([]any))))

}

func (p *parser) callonExample1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExample1(stack["start"], stack["lines"])
}

func (c *current) onExampleStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeExample, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonExampleStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleStart6(stack["delimiter"])
}

func (c *current) onExampleStart1(delimiter any) (any, error) {
	debugPosition(c, "matched example start: %s\n", string(c.text))
	return delimiter, nil

}

func (p *parser) callonExampleStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleStart1(stack["delimiter"])
}

func (c *current) onExampleEnd6(delimiter any) (bool, error) {
	debugPosition(c, "matched example end: %s\n", string(c.text))
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeExample)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeExample)
		return true, nil
	}
	debugPosition(c, "example end wrong length: %s (%d vs. %d)\n", string(c.text), previous, delimiter.(asciidoc.Delimiter).Length)
	return false, nil

}

func (p *parser) callonExampleEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleEnd6(stack["delimiter"])
}

func (c *current) onExampleEquals8(hyphens any) (bool, error) {
	return delimitedLength(hyphens) >= 4, nil

}

func (p *parser) callonExampleEquals8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleEquals8(stack["hyphens"])
}

func (c *current) onExampleEquals1(hyphens any) (any, error) {

	debugPosition(c, "matched example equals: %s\n", string(c.text))
	return delimitedLength(hyphens), nil

}

func (p *parser) callonExampleEquals1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleEquals1(stack["hyphens"])
}

func (c *current) onExampleDelimiter1(hyphens any) (any, error) {
	debugPosition(c, "matched example delimiter: %s\n", string(c.text))
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeExample, Length: hyphens.(int)}, nil

}

func (p *parser) callonExampleDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleDelimiter1(stack["hyphens"])
}

func (c *current) onExampleLine1(line any) (any, error) {
	return line.(string), nil
}

func (p *parser) callonExampleLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleLine1(stack["line"])
}

func (c *current) onLiteral1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewLiteralBlock(start.(asciidoc.Delimiter)), setLines[*asciidoc.LiteralBlock](cast[any, string](lines.([]any))))

}

func (p *parser) callonLiteral1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteral1(stack["start"], stack["lines"])
}

func (c *current) onLiteralStart7(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeLiteral, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonLiteralStart7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralStart7(stack["delimiter"])
}

func (c *current) onLiteralStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonLiteralStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralStart1(stack["delimiter"])
}

func (c *current) onLiteralEnd7(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeLiteral)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeLiteral)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonLiteralEnd7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralEnd7(stack["delimiter"])
}

func (c *current) onLiteralDots8(dots any) (bool, error) {
	return delimitedLength(dots) >= 4, nil

}

func (p *parser) callonLiteralDots8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralDots8(stack["dots"])
}

func (c *current) onLiteralDots1(dots any) (any, error) {

	return delimitedLength(dots), nil

}

func (p *parser) callonLiteralDots1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralDots1(stack["dots"])
}

func (c *current) onLiteralDelimiter1(dots any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeLiteral, Length: dots.(int)}, nil

}

func (p *parser) callonLiteralDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralDelimiter1(stack["dots"])
}

func (c *current) onLiteralLine1(line any) (any, error) {
	return line.(string), nil
}

func (p *parser) callonLiteralLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralLine1(stack["line"])
}

func (c *current) onSidebar1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewSidebarBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.SidebarBlock](join(lines.([]any))))

}

func (p *parser) callonSidebar1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebar1(stack["start"], stack["lines"])
}

func (c *current) onSidebarStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeSidebar, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonSidebarStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarStart6(stack["delimiter"])
}

func (c *current) onSidebarStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonSidebarStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarStart1(stack["delimiter"])
}

func (c *current) onSidebarEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeSidebar)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeSidebar)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonSidebarEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarEnd6(stack["delimiter"])
}

func (c *current) onSidebarAsterisks8(asterisks any) (bool, error) {
	return delimitedLength(asterisks) >= 4, nil

}

func (p *parser) callonSidebarAsterisks8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarAsterisks8(stack["asterisks"])
}

func (c *current) onSidebarAsterisks1(asterisks any) (any, error) {

	return delimitedLength(asterisks), nil

}

func (p *parser) callonSidebarAsterisks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarAsterisks1(stack["asterisks"])
}

func (c *current) onSidebarDelimiter1(asterisks any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeSidebar, Length: asterisks.(int)}, nil

}

func (p *parser) callonSidebarDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarDelimiter1(stack["asterisks"])
}

func (c *current) onPreParse1(content any) (any, error) {
	debugPosition(c, "complete preparse: %T\n", flat(content.([]any)))
	return flat(content.([]any)), nil
}

func (p *parser) callonPreParse1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParse1(stack["content"])
}

func (c *current) onPreParseElement1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonPreParseElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseElement1(stack["element"])
}

func (c *current) onPreParseLine1(content any) (any, error) {
	debugPosition(c, "matched preparse line: \"%s\"\n", string(c.text))
	return flat(append(content.([]any), &asciidoc.NewLine{})), nil
}

func (p *parser) callonPreParseLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseLine1(stack["content"])
}

func (c *current) onPreParseLineElement2(arv any) (any, error) {
	return arv, nil

}

func (p *parser) callonPreParseLineElement2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseLineElement2(stack["arv"])
}

func (c *current) onPreParseLineElement5() (any, error) {
	return asciidoc.NewString(string(c.text)), nil

}

func (p *parser) callonPreParseLineElement5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseLineElement5()
}

func (c *current) onPreParseLineElement8() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonPreParseLineElement8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseLineElement8()
}

func (c *current) onIfDefBlock1(attributes, lines any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewIfDefBlock(attr.names, attr.union), setElements[*asciidoc.IfDefBlock](flat(lines.([]any))))
}

func (p *parser) callonIfDefBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfDefBlock1(stack["attributes"], stack["lines"])
}

func (c *current) onIfNDefBlock1(attributes, lines any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewIfNDefBlock(attr.names, attr.union), setElements[*asciidoc.IfNDefBlock](flat(lines.([]any))))
}

func (p *parser) callonIfNDefBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfNDefBlock1(stack["attributes"], stack["lines"])
}

func (c *current) onIfEvalBlock1(left, operand, right, lines any) (any, error) {
	return compose(c, asciidoc.NewIfEvalBlock(left.(asciidoc.IfEvalValue), operand.(asciidoc.ConditionalOperator), right.(asciidoc.IfEvalValue)), setElements[*asciidoc.IfEvalBlock](flat(lines.([]any))))

}

func (p *parser) callonIfEvalBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalBlock1(stack["left"], stack["operand"], stack["right"], stack["lines"])
}

func (c *current) onQuote1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewQuoteBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.QuoteBlock](join(lines.([]any))))

}

func (p *parser) callonQuote1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuote1(stack["start"], stack["lines"])
}

func (c *current) onQuoteStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeQuote, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonQuoteStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteStart6(stack["delimiter"])
}

func (c *current) onQuoteStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonQuoteStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteStart1(stack["delimiter"])
}

func (c *current) onQuoteEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeQuote)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeQuote)
		return true, nil
	}
	return false, nil
}

func (p *parser) callonQuoteEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteEnd6(stack["delimiter"])
}

func (c *current) onQuoteUnderlines8(underlines any) (bool, error) {
	return delimitedLength(underlines) >= 4, nil

}

func (p *parser) callonQuoteUnderlines8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteUnderlines8(stack["underlines"])
}

func (c *current) onQuoteUnderlines1(underlines any) (any, error) {

	return delimitedLength(underlines), nil

}

func (p *parser) callonQuoteUnderlines1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteUnderlines1(stack["underlines"])
}

func (c *current) onQuoteDelimiter1(underlines any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeQuote, Length: underlines.(int)}, nil

}

func (p *parser) callonQuoteDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteDelimiter1(stack["underlines"])
}

func (c *current) onListItemValue1(line, lines, attachedBlocks any) (any, error) {
	value := []any{line}
	if lines != nil {
		value = append(value, lines)
	}
	if attachedBlocks != nil {
		value = append(value, attachedBlocks.([]any))
	}
	return flat(value), nil
}

func (p *parser) callonListItemValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListItemValue1(stack["line"], stack["lines"], stack["attachedBlocks"])
}

func (c *current) onAttachedBlock1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonAttachedBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttachedBlock1(stack["element"])
}

func (c *current) onAttachedBlockElement1(value any) (any, error) {
	return asciidoc.NewAttachedBlock(value.(asciidoc.Element)), nil
}

func (p *parser) callonAttachedBlockElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttachedBlockElement1(stack["value"])
}

func (c *current) onListContinuation1(value any) (any, error) {
	return compose(c, asciidoc.NewListContinuation(value.(asciidoc.Element)))
}

func (p *parser) callonListContinuation1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListContinuation1(stack["value"])
}

func (c *current) onListItemLine1(element any) (any, error) {
	return []any{&asciidoc.NewLine{}, element}, nil
}

func (p *parser) callonListItemLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListItemLine1(stack["element"])
}

func (c *current) onAttachedBlocks1(blocks any) (any, error) {
	return blocks, nil
}

func (p *parser) callonAttachedBlocks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttachedBlocks1(stack["blocks"])
}

func (c *current) onThematicBreak1() (any, error) {
	debugPosition(c, "thematic break: %s\n", string(c.text))
	return compose(c, asciidoc.NewThematicBreak())
}

func (p *parser) callonThematicBreak1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onThematicBreak1()
}

func (c *current) onPageBreak1() (any, error) {
	debugPosition(c, "page break: %s\n", string(c.text))
	return compose(c, asciidoc.NewPageBreak())
}

func (p *parser) callonPageBreak1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPageBreak1()
}

func (c *current) onFenced1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewFencedBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.FencedBlock](join(lines.([]any))))

}

func (p *parser) callonFenced1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFenced1(stack["start"], stack["lines"])
}

func (c *current) onFencedStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeFenced, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonFencedStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedStart6(stack["delimiter"])
}

func (c *current) onFencedStart1(delimiter any) (any, error) {
	debugPosition(c, "matched fenced start: %s\n", string(c.text))
	return delimiter, nil

}

func (p *parser) callonFencedStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedStart1(stack["delimiter"])
}

func (c *current) onFencedEnd6(delimiter any) (bool, error) {
	debugPosition(c, "matched fenced end: %s\n", string(c.text))
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeFenced)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeFenced)
		return true, nil
	}
	debugPosition(c, "Fenced end wrong length: %s (%d vs. %d)\n", string(c.text), previous, delimiter.(asciidoc.Delimiter).Length)
	return false, nil

}

func (p *parser) callonFencedEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedEnd6(stack["delimiter"])
}

func (c *current) onFencedBackticks8(backticks any) (bool, error) {
	return delimitedLength(backticks) >= 4, nil

}

func (p *parser) callonFencedBackticks8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedBackticks8(stack["backticks"])
}

func (c *current) onFencedBackticks1(backticks any) (any, error) {

	debugPosition(c, "matched fenced backticks: %s\n", string(c.text))
	return delimitedLength(backticks), nil

}

func (p *parser) callonFencedBackticks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedBackticks1(stack["backticks"])
}

func (c *current) onFencedDelimiter1(hyphens any) (any, error) {
	debugPosition(c, "matched Fenced delimiter: %s\n", string(c.text))
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeFenced, Length: hyphens.(int)}, nil

}

func (p *parser) callonFencedDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedDelimiter1(stack["hyphens"])
}

func (c *current) onFencedLine1(line any) (any, error) {
	return line.(string), nil
}

func (p *parser) callonFencedLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedLine1(stack["line"])
}

func (c *current) onStem1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewStemBlock(start.(asciidoc.Delimiter)), setLines[*asciidoc.StemBlock](cast[any, string](lines.([]any))))

}

func (p *parser) callonStem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStem1(stack["start"], stack["lines"])
}

func (c *current) onStemStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeStem, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonStemStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemStart6(stack["delimiter"])
}

func (c *current) onStemStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonStemStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemStart1(stack["delimiter"])
}

func (c *current) onStemEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeStem)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeStem)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonStemEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemEnd6(stack["delimiter"])
}

func (c *current) onStemPluses8(pluses any) (bool, error) {
	return delimitedLength(pluses) >= 4, nil

}

func (p *parser) callonStemPluses8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemPluses8(stack["pluses"])
}

func (c *current) onStemPluses1(pluses any) (any, error) {

	return delimitedLength(pluses), nil

}

func (p *parser) callonStemPluses1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemPluses1(stack["pluses"])
}

func (c *current) onStemDelimiter1(pluses any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeStem, Length: pluses.(int)}, nil

}

func (p *parser) callonStemDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemDelimiter1(stack["pluses"])
}

func (c *current) onStemLine1(line any) (any, error) {
	return line.(string), nil
}

func (p *parser) callonStemLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemLine1(stack["line"])
}

func (c *current) onInternalCrossReference8(label any) (any, error) {
	return label, nil
}

func (p *parser) callonInternalCrossReference8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInternalCrossReference8(stack["label"])
}

func (c *current) onInternalCrossReference1(id, label any) (any, error) {
	var lbl asciidoc.Set
	if label != nil {
		lbl = join(label.([]any))
	}
	return compose(c, asciidoc.NewCrossReference(id.(string)), setElements[*asciidoc.CrossReference](lbl))
}

func (p *parser) callonInternalCrossReference1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInternalCrossReference1(stack["id"], stack["label"])
}

func (c *current) onCrossReferenceID1() (any, error) {

	debugPosition(c, "matched cross reference ID: %s\n", string(c.text))
	// See: https://docs.asciidoctor.org/asciidoc/latest/attributes/id/#valid-id-characters
	return string(c.text), nil
}

func (p *parser) callonCrossReferenceID1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceID1()
}

func (c *current) onCrossReferenceLabel3() (any, error) {
	return asciidoc.NewString(string(c.text)), nil

}

func (p *parser) callonCrossReferenceLabel3() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceLabel3()
}

func (c *current) onCrossReferenceLabel6(arv any) (any, error) {
	return arv, nil

}

func (p *parser) callonCrossReferenceLabel6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceLabel6(stack["arv"])
}

func (c *current) onCrossReferenceLabel9() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonCrossReferenceLabel9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceLabel9()
}

func (c *current) onDocumentCrossReference1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewDocumentCrossReference(path.(asciidoc.Set)), setAttributes[*asciidoc.DocumentCrossReference](attributes))
}

func (p *parser) callonDocumentCrossReference1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDocumentCrossReference1(stack["path"], stack["attributes"])
}

func (c *current) onUppercaseRoman15(thousands, hundreds, tens, ones any) (bool, error) {
	return thousands != nil || hundreds != nil || tens != nil || ones != nil, nil
}

func (p *parser) callonUppercaseRoman15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRoman15(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onUppercaseRoman1(thousands, hundreds, tens, ones any) (any, error) {
	return string(c.text), nil
}

func (p *parser) callonUppercaseRoman1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRoman1(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onUppercaseRomanHundreds9(hundreds any) (bool, error) {
	return len(hundreds.([]any)) < 4, nil
}

func (p *parser) callonUppercaseRomanHundreds9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRomanHundreds9(stack["hundreds"])
}

func (c *current) onUppercaseRomanTens10(tens any) (bool, error) {
	return len(tens.([]any)) < 4, nil
}

func (p *parser) callonUppercaseRomanTens10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRomanTens10(stack["tens"])
}

func (c *current) onUppercaseRomanOnes10(ones any) (bool, error) {
	return len(ones.([]any)) < 4, nil
}

func (p *parser) callonUppercaseRomanOnes10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRomanOnes10(stack["ones"])
}

func (c *current) onLowercaseRoman15(thousands, hundreds, tens, ones any) (bool, error) {
	return thousands != nil || hundreds != nil || tens != nil || ones != nil, nil
}

func (p *parser) callonLowercaseRoman15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRoman15(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onLowercaseRoman1(thousands, hundreds, tens, ones any) (any, error) {
	return string(c.text), nil
}

func (p *parser) callonLowercaseRoman1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRoman1(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onLowercaseRomanHundreds9(hundreds any) (bool, error) {
	return len(hundreds.([]any)) < 4, nil
}

func (p *parser) callonLowercaseRomanHundreds9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRomanHundreds9(stack["hundreds"])
}

func (c *current) onLowercaseRomanTens10(tens any) (bool, error) {
	return len(tens.([]any)) < 4, nil
}

func (p *parser) callonLowercaseRomanTens10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRomanTens10(stack["tens"])
}

func (c *current) onLowercaseRomanOnes10(ones any) (bool, error) {
	return len(ones.([]any)) < 4, nil
}

func (p *parser) callonLowercaseRomanOnes10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRomanOnes10(stack["ones"])
}

func (c *current) onOrderedListItem1(marker, value any) (any, error) {
	debugPosition(c, "found ordered list item: %v\n", marker)
	m := marker.(listMarker)
	return compose(c, asciidoc.NewOrderedListItem(m.indent, m.marker), setElements[*asciidoc.OrderedListItem](value.(asciidoc.Set)))
}

func (p *parser) callonOrderedListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListItem1(stack["marker"], stack["value"])
}

func (c *current) onOrderedListMarker10() (any, error) {
	debugPosition(c, "matched ordered list ordinal marker\n")
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker10()
}

func (c *current) onOrderedListMarker13(ordinal any) (bool, error) {
	debugPosition(c, "checking ordered list ordinal marker:%T\n", ordinal)
	return len(ordinal.(string)) <= 5, nil
}

func (p *parser) callonOrderedListMarker13() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker13(stack["ordinal"])
}

func (c *current) onOrderedListMarker7(ordinal any) (any, error) {
	debugPosition(c, "returning ordered list ordinal marker:%T\n", ordinal)

	return ordinal, nil
}

func (p *parser) callonOrderedListMarker7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker7(stack["ordinal"])
}

func (c *current) onOrderedListMarker14() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker14()
}

func (c *current) onOrderedListMarker19() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker19()
}

func (c *current) onOrderedListMarker23() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker23() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker23()
}

func (c *current) onOrderedListMarker27() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker27()
}

func (c *current) onOrderedListMarker31() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker31()
}

func (c *current) onOrderedListMarker1(indent, marker any) (any, error) {
	debugPosition(c, "matched ordered list marker\n")
	return listMarker{marker: marker.(string), indent: indent.(string)}, nil
}

func (p *parser) callonOrderedListMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker1(stack["indent"], stack["marker"])
}

func (c *current) onUnorderedListItem1(marker, checklist, value any) (any, error) {
	cl, _ := checklist.(asciidoc.Checklist)
	debug("found unordered list item: %s\n", marker.(listMarker).marker)
	m := marker.(listMarker)
	return compose(c, asciidoc.NewUnorderedListItem(m.indent, m.marker, cl), setElements[*asciidoc.UnorderedListItem](value.(asciidoc.Set)))
}

func (p *parser) callonUnorderedListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListItem1(stack["marker"], stack["checklist"], stack["value"])
}

func (c *current) onUnorderedListMarker6() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonUnorderedListMarker6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListMarker6()
}

func (c *current) onUnorderedListMarker12(indent, marker any) (bool, error) {
	return len(marker.(string)) <= 5, nil
}

func (p *parser) callonUnorderedListMarker12() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListMarker12(stack["indent"], stack["marker"])
}

func (c *current) onUnorderedListMarker1(indent, marker any) (any, error) {
	return listMarker{marker: marker.(string), indent: indent.(string)}, nil
}

func (p *parser) callonUnorderedListMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListMarker1(stack["indent"], stack["marker"])
}

func (c *current) onChecklist7() (any, error) {
	return asciidoc.ChecklistUnchecked, nil
}

func (p *parser) callonChecklist7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist7()
}

func (c *current) onChecklist9() (any, error) {
	return asciidoc.ChecklistChecked, nil
}

func (p *parser) callonChecklist9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist9()
}

func (c *current) onChecklist11() (any, error) {
	return asciidoc.ChecklistChecked, nil
}

func (p *parser) callonChecklist11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist11()
}

func (c *current) onChecklist1(checklist any) (any, error) {
	return checklist, nil

}

func (p *parser) callonChecklist1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist1(stack["checklist"])
}

func (c *current) onDescriptionListItem13() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonDescriptionListItem13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListItem13()
}

func (c *current) onDescriptionListItem1(inlineAnchor, term, marker, whitespace, value any) (any, error) {
	debugPosition(c, "found description list item: %s\n", marker.(string))
	dli := asciidoc.NewDescriptionListItem(marker.(string), term.(asciidoc.Set))
	values := cast[any, asciidoc.Element](whitespace.([]any))
	values = append(values, value.(asciidoc.Set)...)
	cos := []composeOption[*asciidoc.DescriptionListItem]{setElements[*asciidoc.DescriptionListItem](asciidoc.Set(values))}
	if inlineAnchor != nil {
		cos = append(cos, setAttributes[*asciidoc.DescriptionListItem](inlineAnchor))
	}
	return compose(c, dli, cos...)
}

func (p *parser) callonDescriptionListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListItem1(stack["inlineAnchor"], stack["term"], stack["marker"], stack["whitespace"], stack["value"])
}

func (c *current) onDescriptionListTerm1(term any) (any, error) {
	return flat(term.([]any)), nil
}

func (p *parser) callonDescriptionListTerm1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListTerm1(stack["term"])
}

func (c *current) onDescriptionListMarker6() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonDescriptionListMarker6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListMarker6()
}

func (c *current) onDescriptionListMarker11(marker any) (bool, error) {
	switch marker.(string) {
	case "::", ":::", "::::", ";;":
		return true, nil
	}
	return false, nil
}

func (p *parser) callonDescriptionListMarker11() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListMarker11(stack["marker"])
}

func (c *current) onDescriptionListMarker1(marker any) (any, error) {
	return marker.(string), nil
}

func (p *parser) callonDescriptionListMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListMarker1(stack["marker"])
}

func (c *current) onDescriptionListItemValue1(line, attachedBlocks any) (any, error) {
	value := []any{line}
	if attachedBlocks != nil {
		value = append(value, attachedBlocks.([]any))
	}
	return flat(value), nil
}

func (p *parser) callonDescriptionListItemValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListItemValue1(stack["line"], stack["attachedBlocks"])
}

func (c *current) onSingleLineComment1(comment any) (any, error) {
	debugPosition(c, "matched comment \"%s\" (%d)\n", comment.(string), len(comment.(string)))
	return compose(c, asciidoc.NewSingleLineComment(comment.(string)))
}

func (p *parser) callonSingleLineComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineComment1(stack["comment"])
}

func (c *current) onSingleLineCommentDelimiter1() (any, error) {
	debugPosition(c, "matched comment delimiter\n")
	return string(c.text), nil
}

func (p *parser) callonSingleLineCommentDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineCommentDelimiter1()
}

func (c *current) onSingleLineCommentContent1() (any, error) {
	debugPosition(c, "matched comment content\n")
	return string(c.text), nil
}

func (p *parser) callonSingleLineCommentContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineCommentContent1()
}

func (c *current) onMultiLineComment1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewMultiLineComment(start.(asciidoc.Delimiter)), setLines[*asciidoc.MultiLineComment](cast[any, string](lines.([]any))))

}

func (p *parser) callonMultiLineComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineComment1(stack["start"], stack["lines"])
}

func (c *current) onMultiLineCommentStart6(delimiter any) (bool, error) {
	debugPosition(c, "matched MultiLineComment start: %s\n", string(c.text))
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeMultiLineComment, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonMultiLineCommentStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentStart6(stack["delimiter"])
}

func (c *current) onMultiLineCommentStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonMultiLineCommentStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentStart1(stack["delimiter"])
}

func (c *current) onMultiLineCommentEnd6(delimiter any) (bool, error) {
	debugPosition(c, "matched MultiLineComment end: %s\n", string(c.text))
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeMultiLineComment)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeMultiLineComment)
		return true, nil
	}
	debugPosition(c, "MultiLineComment end wrong length: %s (%d vs. %d)\n", string(c.text), previous, delimiter.(asciidoc.Delimiter).Length)
	return false, nil

}

func (p *parser) callonMultiLineCommentEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentEnd6(stack["delimiter"])
}

func (c *current) onMultiLineCommentForwardSlashes8(forwardSlashes any) (bool, error) {
	debugPosition(c, "checking MultiLineComment slashes: %d\n", delimitedLength(forwardSlashes))
	return delimitedLength(forwardSlashes) >= 4, nil

}

func (p *parser) callonMultiLineCommentForwardSlashes8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentForwardSlashes8(stack["forwardSlashes"])
}

func (c *current) onMultiLineCommentForwardSlashes1(forwardSlashes any) (any, error) {

	debugPosition(c, "matched MultiLineComment slashes: %s\n", string(c.text))
	return delimitedLength(forwardSlashes), nil

}

func (p *parser) callonMultiLineCommentForwardSlashes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentForwardSlashes1(stack["forwardSlashes"])
}

func (c *current) onMultiLineCommentDelimiter1(forwardSlashes any) (any, error) {
	debugPosition(c, "matched MultiLineComment delimiter: %s\n", string(c.text))
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeMultiLineComment, Length: forwardSlashes.(int)}, nil

}

func (p *parser) callonMultiLineCommentDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentDelimiter1(stack["forwardSlashes"])
}

func (c *current) onMultiLineCommentLine1(line any) (any, error) {
	return line.(string), nil
}

func (p *parser) callonMultiLineCommentLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentLine1(stack["line"])
}

func (c *current) onCounterIncrement1(name, initialValue any) (any, error) {
	return populatePosition(c, asciidoc.NewCounter(name.(string), initialValue, true)), nil
}

func (p *parser) callonCounterIncrement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterIncrement1(stack["name"], stack["initialValue"])
}

func (c *current) onCounterSilentIncrement1(name, initialValue any) (any, error) {
	return populatePosition(c, asciidoc.NewCounter(name.(string), initialValue, false)), nil
}

func (p *parser) callonCounterSilentIncrement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterSilentIncrement1(stack["name"], stack["initialValue"])
}

func (c *current) onCounterInitialValue1(initializer any) (any, error) {
	return initializer, nil
}

func (p *parser) callonCounterInitialValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterInitialValue1(stack["initializer"])
}

func (c *current) onCounterInitializer2() (any, error) {

	return string(c.text), nil

}

func (p *parser) callonCounterInitializer2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterInitializer2()
}

func (c *current) onCounterInitializer4() (any, error) {

	return strconv.Atoi(string(c.text))

}

func (p *parser) callonCounterInitializer4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterInitializer4()
}

func (c *current) onInlinePassthrough1(attributes, text any) (any, error) {
	return compose(c, text.(asciidoc.AttributableElement), setAttributes[asciidoc.AttributableElement](attributes))
}

func (p *parser) callonInlinePassthrough1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlinePassthrough1(stack["attributes"], stack["text"])
}

func (c *current) onInlineSinglePassthrough1(value any) (any, error) {
	debugPosition(c, "match inline single Passthrough text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonInlineSinglePassthrough1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineSinglePassthrough1(stack["value"])
}

func (c *current) onSinglePassthroughTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSinglePassthroughTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSinglePassthroughTextValue7(stack["value"])
}

func (c *current) onSinglePassthroughTextValue1(value any) (any, error) {
	debugPosition(c, "match inline single Passthrough element %s\n", string(c.text))
	return compose(c, asciidoc.NewInlinePassthrough(), setElements[*asciidoc.InlinePassthrough](flat(value.([]any))))
}

func (p *parser) callonSinglePassthroughTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSinglePassthroughTextValue1(stack["value"])
}

func (c *current) onSinglePassthroughTextElement1(element any) (any, error) {
	debugPosition(c, "match inline single Passthrough text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonSinglePassthroughTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSinglePassthroughTextElement1(stack["element"])
}

func (c *current) onInlineDoublePassthrough1(value any) (any, error) {
	debugPosition(c, "match inline double Passthrough text %s\n", string(c.text))
	return value, nil
}

func (p *parser) callonInlineDoublePassthrough1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDoublePassthrough1(stack["value"])
}

func (c *current) onDoublePassthroughTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoublePassthroughTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoublePassthroughTextValue7(stack["value"])
}

func (c *current) onDoublePassthroughTextValue1(value any) (any, error) {
	debugPosition(c, "match inline single Passthrough element %s\n", string(c.text))
	return compose(c, asciidoc.NewInlineDoublePassthrough(), setElements[*asciidoc.InlineDoublePassthrough](flat(value.([]any))))
}

func (p *parser) callonDoublePassthroughTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoublePassthroughTextValue1(stack["value"])
}

func (c *current) onDoublePassthroughTextElement1(element any) (any, error) {
	debugPosition(c, "match inline double Passthrough text element %s\n", string(c.text))
	return element, nil
}

func (p *parser) callonDoublePassthroughTextElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoublePassthroughTextElement1(stack["element"])
}

func (c *current) onIfDef1(attributes any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return asciidoc.NewIfDef(attr.names, attr.union), nil
}

func (p *parser) callonIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfDef1(stack["attributes"])
}

func (c *current) onIfDefStatement1() (any, error) {
	debugPosition(c, "matched ifdef statement: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonIfDefStatement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfDefStatement1()
}

func (c *current) onIfNDef1(attributes any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return asciidoc.NewIfNDef(attr.names, attr.union), nil
}

func (p *parser) callonIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfNDef1(stack["attributes"])
}

func (c *current) onInlineIfDef1(attributes, content any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewInlineIfDef(attr.names), setElements[*asciidoc.InlineIfDef](content))
}

func (p *parser) callonInlineIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfDef1(stack["attributes"], stack["content"])
}

func (c *current) onInlineIfNDef1(attributes, content any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewInlineIfNDef(attr.names), setElements[*asciidoc.InlineIfNDef](content))
}

func (p *parser) callonInlineIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfNDef1(stack["attributes"], stack["content"])
}

func (c *current) onEndIfDef1(attributes any) (any, error) {
	var attr []asciidoc.AttributeName
	var union asciidoc.ConditionalUnion
	if attributes != nil {
		attr = attributes.(conditionalAttributes).names
		union = attributes.(conditionalAttributes).union
	}
	return asciidoc.NewEndIf(attr, union), nil
}

func (p *parser) callonEndIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEndIfDef1(stack["attributes"])
}

func (c *current) onEndIfDefStatement1() (any, error) {
	debugPosition(c, "matched endif statement: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonEndIfDefStatement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEndIfDefStatement1()
}

func (c *current) onConditionalAttributes1(attr any) (any, error) {
	debugPosition(c, "matched conditional attr: %s\n", string(c.text))
	return attr, nil
}

func (p *parser) callonConditionalAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributes1(stack["attr"])
}

func (c *current) onConditionalAttributesAny14(name any) (bool, error) {
	return len(name.(string)) > 0, nil

}

func (p *parser) callonConditionalAttributesAny14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAny14(stack["name"])
}

func (c *current) onConditionalAttributesAny4(name any) (any, error) {
	return asciidoc.AttributeName(name.(string)), nil

}

func (p *parser) callonConditionalAttributesAny4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAny4(stack["name"])
}

func (c *current) onConditionalAttributesAny1(names any) (any, error) {
	return conditionalAttributes{names: cast[any, asciidoc.AttributeName](names.([]any)), union: asciidoc.ConditionalUnionAny}, nil
}

func (p *parser) callonConditionalAttributesAny1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAny1(stack["names"])
}

func (c *current) onConditionalAttributesAll14(name any) (bool, error) {
	return len(name.(string)) > 0, nil

}

func (p *parser) callonConditionalAttributesAll14() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAll14(stack["name"])
}

func (c *current) onConditionalAttributesAll4(name any) (any, error) {
	return asciidoc.AttributeName(name.(string)), nil

}

func (p *parser) callonConditionalAttributesAll4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAll4(stack["name"])
}

func (c *current) onConditionalAttributesAll1(names any) (any, error) {
	return conditionalAttributes{names: cast[any, asciidoc.AttributeName](names.([]any)), union: asciidoc.ConditionalUnionAll}, nil
}

func (p *parser) callonConditionalAttributesAll1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAll1(stack["names"])
}

func (c *current) onInlineConditionalContent4(element any) (any, error) {
	return element, nil
}

func (p *parser) callonInlineConditionalContent4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineConditionalContent4(stack["element"])
}

func (c *current) onInlineConditionalContent1(content any) (any, error) {
	return content, nil
}

func (p *parser) callonInlineConditionalContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineConditionalContent1(stack["content"])
}

func (c *current) onIfEval1(left, operand, right any) (any, error) {
	debugPosition(c, "matched ifeval: %s\n", string(c.text))
	return asciidoc.NewIfEval(left.(asciidoc.IfEvalValue), operand.(asciidoc.ConditionalOperator), right.(asciidoc.IfEvalValue)), nil
}

func (p *parser) callonIfEval1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEval1(stack["left"], stack["operand"], stack["right"])
}

func (c *current) onIfEvalStatement1() (any, error) {
	debugPosition(c, "matched ifeval statement: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonIfEvalStatement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalStatement1()
}

func (c *current) onIfEvalValue1(val any) (any, error) {
	return asciidoc.IfEvalValue{Quote: val.(*attributeValue).quote, Value: val.(*attributeValue).value}, nil
}

func (p *parser) callonIfEvalValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalValue1(stack["val"])
}

func (c *current) onIfEvalOperator2() (any, error) {
	return asciidoc.ConditionalOperatorEqual, nil
}

func (p *parser) callonIfEvalOperator2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator2()
}

func (c *current) onIfEvalOperator4() (any, error) {
	return asciidoc.ConditionalOperatorNotEqual, nil
}

func (p *parser) callonIfEvalOperator4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator4()
}

func (c *current) onIfEvalOperator6() (any, error) {
	return asciidoc.ConditionalOperatorLessThan, nil
}

func (p *parser) callonIfEvalOperator6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator6()
}

func (c *current) onIfEvalOperator8() (any, error) {
	return asciidoc.ConditionalOperatorLessThanOrEqual, nil
}

func (p *parser) callonIfEvalOperator8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator8()
}

func (c *current) onIfEvalOperator10() (any, error) {
	return asciidoc.ConditionalOperatorGreaterThan, nil
}

func (p *parser) callonIfEvalOperator10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator10()
}

func (c *current) onIfEvalOperator12() (any, error) {
	return asciidoc.ConditionalOperatorGreaterThanOrEqual, nil
}

func (p *parser) callonIfEvalOperator12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator12()
}

func (c *current) onSpecialCharacter1() (any, error) {
	return asciidoc.NewSpecialCharacter(string(c.text)), nil
}

func (p *parser) callonSpecialCharacter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSpecialCharacter1()
}

func (c *current) onApostrophe2() (any, error) {
	return asciidoc.NewString("'"), nil

}

func (p *parser) callonApostrophe2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onApostrophe2()
}

func (c *current) onApostrophe7() (any, error) {
	return asciidoc.NewString("'"), nil

}

func (p *parser) callonApostrophe7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onApostrophe7()
}

func (c *current) onPunctuation1() (any, error) {
	debug("matched punctuation: %s\n", string(c.text))
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonPunctuation1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPunctuation1()
}

func (c *current) onLineBreak8() (bool, error) {
	debugPosition(c, "checking line continuation: %v\n", c.previousRuneIsWhitespace())
	return c.previousRuneIsWhitespace(), nil
}

func (p *parser) callonLineBreak8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLineBreak8()
}

func (c *current) onLineBreak1() (any, error) {
	debug("line continuation\n")
	return &asciidoc.LineBreak{}, nil
}

func (p *parser) callonLineBreak1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLineBreak1()
}

func (c *current) onDoubleCurvedQuote1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonDoubleCurvedQuote1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleCurvedQuote1()
}

func (c *current) onSingleCurvedQuote1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonSingleCurvedQuote1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleCurvedQuote1()
}

func (c *current) onEmptyLine1() (any, error) {
	debugPosition(c, "matched empty line %d chars \"%s\"\n", len(string(c.text)), string(c.text))
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))

}

func (p *parser) callonEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmptyLine1()
}

func (c *current) onNewLine1() (any, error) {
	debugPosition(c, "newline\n")
	return compose(c, &asciidoc.NewLine{})
}

func (p *parser) callonNewLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNewLine1()
}

func (c *current) onPercentage1(percentage any) (any, error) {
	return percentage, nil
}

func (p *parser) callonPercentage1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPercentage1(stack["percentage"])
}

func (c *current) onPositiveInteger5() (bool, error) {
	return len(string(c.text)) < 10, nil
}

func (p *parser) callonPositiveInteger5() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPositiveInteger5()
}

func (c *current) onPositiveInteger1() (any, error) {
	return strconv.Atoi(string(c.text))
}

func (p *parser) callonPositiveInteger1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPositiveInteger1()
}

func (c *current) onEndOfFile1() (any, error) {
	debugPosition(c, "endoffile\n")
	return string(c.text), nil
}

func (p *parser) callonEndOfFile1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEndOfFile1()
}

func (c *current) onOffsetCharacter3() (bool, error) {
	debugPosition(c, "checking offset character: \"%s\" column %d\n", string(c.text), c.currentColumn())
	return c.currentColumn() > 1, nil
}

func (p *parser) callonOffsetCharacter3() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOffsetCharacter3()
}

func (c *current) onIndent8() (bool, error) {
	debugPosition(c, "checking indent: %d\n", c.pos.col)
	return c.pos.col < 2, nil
}

func (p *parser) callonIndent8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndent8()
}

func (c *current) onIndent1() (any, error) {
	debugPosition(c, "indent\n")
	return nil, nil
}

func (p *parser) callonIndent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndent1()
}

func (c *current) onInlineText2() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonInlineText2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineText2()
}

func (c *current) onUnbrokenText1() (any, error) {
	debugPosition(c, "unbroken: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonUnbrokenText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnbrokenText1()
}

func (c *current) onAnyText1() (any, error) {
	debugPosition(c, "any: %s\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonAnyText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnyText1()
}

func (c *current) onAnySpaces1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonAnySpaces1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnySpaces1()
}

func (c *current) onCharacterClassAll1() (any, error) {
	debugPosition(c, "matched all: \"%s\"\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callonCharacterClassAll1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCharacterClassAll1()
}

func (c *current) onCharacterGroupWord1() (any, error) {
	debugPosition(c, "matched CharacterGroupWord: \"%s\"\n", string(c.text))
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonCharacterGroupWord1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCharacterGroupWord1()
}

func (c *current) on__1() (any, error) {
	debugPosition(c, "matched spaces: \"%s\"\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callon__1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on__1()
}

func (c *current) on_1() (any, error) {
	debugPosition(c, "matched space: \"%s\"\n", string(c.text))
	return string(c.text), nil
}

func (p *parser) callon_1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_1()
}

func (c *current) onEscape1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonEscape1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEscape1()
}

func (c *current) onDoubleEscape1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonDoubleEscape1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleEscape1()
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expressions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// Statistics adds a user provided Stats struct to the parser to allow
// the user to process the results after the parsing has finished.
// Also the key for the "no match" counter is set.
//
// Example usage:
//
//	input := "input"
//	stats := Stats{}
//	_, err := Parse("input-file", []byte(input), Statistics(&stats, "no match"))
//	if err != nil {
//	    log.Panicln(err)
//	}
//	b, err := json.MarshalIndent(stats.ChoiceAltCnt, "", "  ")
//	if err != nil {
//	    log.Panicln(err)
//	}
//	fmt.Println(string(b))
func Statistics(stats *Stats, choiceNoMatch string) Option {
	return func(p *parser) Option {
		oldStats := p.Stats
		p.Stats = stats
		oldChoiceNoMatch := p.choiceNoMatch
		p.choiceNoMatch = choiceNoMatch
		if p.Stats.ChoiceAltCnt == nil {
			p.Stats.ChoiceAltCnt = make(map[string]map[string]int)
		}
		return Statistics(oldStats, oldChoiceNoMatch)
	}
}

// Debug creates an Option to set the debug flag to b. When set to true,
// debugging information is printed to stdout while parsing.
//
// The default is false.
func Debug(b bool) Option {
	return func(p *parser) Option {
		old := p.debug
		p.debug = b
		return Debug(old)
	}
}

// Memoize creates an Option to set the memoize flag to b. When set to true,
// the parser will cache all results so each expression is evaluated only
// once. This guarantees linear parsing time even for pathological cases,
// at the expense of more memory and slower times for typical cases.
//
// The default is false.
func Memoize(b bool) Option {
	return func(p *parser) Option {
		old := p.memoize
		p.memoize = b
		return Memoize(old)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// InitState creates an Option to set a key to a certain value in
// the global "state" store.
func InitState(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.state[key]
		p.cur.state[key] = value
		return InitState(key, old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (i any, err error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (any, error) {
	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (any, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// state is a store for arbitrary key,value pairs that the user wants to be
	// tied to the backtracking of the parser.
	// This is always rolled back if a parsing rule fails.
	state storeDict

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict
	delimitedBlockState delimitedBlockState
	parser *parser
	tableColumnsAttribute *asciidoc.TableColumnsAttribute
}

type storeDict map[string]any

// the AST types...

type grammar struct {
	pos   position
	rules []*rule
}

type rule struct {
	pos         position
	name        string
	displayName string
	expr        any
}

type choiceExpr struct {
	pos          position
	alternatives []any
}

type actionExpr struct {
	pos  position
	expr any
	run  func(*parser) (any, error)
}

type recoveryExpr struct {
	pos          position
	expr         any
	recoverExpr  any
	failureLabel []string
}

type seqExpr struct {
	pos   position
	exprs []any
}

type throwExpr struct {
	pos   position
	label string
}

type labeledExpr struct {
	pos   position
	label string
	expr  any
}

type expr struct {
	pos  position
	expr any
}

type (
	andExpr        expr
	notExpr        expr
	zeroOrOneExpr  expr
	zeroOrMoreExpr expr
	oneOrMoreExpr  expr
)

type ruleRefExpr struct {
	pos  position
	name string
}

type stateCodeExpr struct {
	pos position
	run func(*parser) error
}

type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

type charClassMatcher struct {
	pos             position
	val             string
	basicLatinChars [128]bool
	chars           []rune
	ranges          []rune
	classes         []*unicode.RangeTable
	ignoreCase      bool
	inverted        bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			state:       make(storeDict),
			globalStore: make(storeDict),
			delimitedBlockState: make(delimitedBlockState),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)
	p.cur.parser = p

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

type resultTuple struct {
	v   any
	b   bool
	end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool
	debug   bool

	memoize bool
	// memoization table for the packrat algorithm:
	// map[offset in source] map[expression or rule] {value, match}
	memo map[int]map[any]resultTuple

	// rules table, maps the rule identifier to the rule node
	rules map[string]*rule
	// variables stack, map of label to value
	vstack []map[string]any
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]any
	offset position
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]any)
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]any, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) print(prefix, s string) string {
	if !p.debug {
		return s
	}

	fmt.Printf("%s %d:%d:%d: %s [%#U] %d\n",
		prefix, p.pt.line, p.pt.col, p.pt.offset, s, p.pt.rn, time.Now().Nanosecond())
	return s
}

func (p *parser) printIndent(mark string, s string) string {
	return p.print(strings.Repeat(" ", p.depth)+mark, s)
}

func (p *parser) in(s string) string {
	res := p.printIndent(">", s)
	p.depth++
	return res
}

func (p *parser) out(s string) string {
	p.depth--
	return p.printIndent("<", s)
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if p.debug {
		defer p.out(p.in("restore"))
	}
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// Cloner is implemented by any value that has a Clone method, which returns a
// copy of the value. This is mainly used for types which are not passed by
// value (e.g map, slice, chan) or structs that contain such types.
//
// This is used in conjunction with the global state feature to create proper
// copies of the state to allow the parser to properly restore the state in
// the case of backtracking.
type Cloner interface {
	Clone() any
}

var statePool = &sync.Pool{
	New: func() any { return make(storeDict) },
}

func (sd storeDict) Discard() {
	for k := range sd {
		delete(sd, k)
	}
	statePool.Put(sd)
}

// clone and return parser current state.
func (p *parser) cloneState() storeDict {
	if p.debug {
		defer p.out(p.in("cloneState"))
	}

	state := statePool.Get().(storeDict)
	for k, v := range p.cur.state {
		if c, ok := v.(Cloner); ok {
			state[k] = c.Clone()
		} else {
			state[k] = v
		}
	}
	return state
}

// restore parser current state to the state storeDict.
// every restoreState should applied only one time for every cloned state
func (p *parser) restoreState(state storeDict) {
	if p.debug {
		defer p.out(p.in("restoreState"))
	}
	p.cur.state.Discard()
	p.cur.state = state
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) getMemoized(node any) (resultTuple, bool) {
	if len(p.memo) == 0 {
		return resultTuple{}, false
	}
	m := p.memo[p.pt.offset]
	if len(m) == 0 {
		return resultTuple{}, false
	}
	res, ok := m[node]
	return res, ok
}

func (p *parser) setMemoized(pt savepoint, node any, tuple resultTuple) {
	if p.memo == nil {
		p.memo = make(map[int]map[any]resultTuple)
	}
	m := p.memo[pt.offset]
	if m == nil {
		m = make(map[any]resultTuple)
		p.memo[pt.offset] = m
	}
	m[node] = tuple
}

func (p *parser) buildRulesTable(g *grammar) {
	p.rules = make(map[string]*rule, len(g.rules))
	for _, r := range g.rules {
		p.rules[r.name] = r
	}
}

func (p *parser) parse(g *grammar) (val any, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.buildRulesTable(g)

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				if p.debug {
					defer p.out(p.in("panic handler"))
				}
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	startRule, ok := p.rules[p.entrypoint]
	if !ok {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	val, ok = p.parseRuleWrap(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRuleMemoize(rule *rule) (any, bool) {
	res, ok := p.getMemoized(rule)
	if ok {
		p.restore(res.end)
		return res.v, res.b
	}

	startMark := p.pt
	val, ok := p.parseRule(rule)
	p.setMemoized(startMark, rule, resultTuple{val, ok, p.pt})

	return val, ok
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseRule " + rule.name))
	}
	var (
		val       any
		ok        bool
		startMark = p.pt
	)

	if p.memoize {
		val, ok = p.parseRuleMemoize(rule)
	} else {
		val, ok = p.parseRule(rule)
	}

	if ok && p.debug {
		p.printIndent("MATCH", string(p.sliceFrom(startMark)))
	}
	return val, ok
}

func (p *parser) parseRule(rule *rule) (any, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExprWrap(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExprWrap(expr any) (any, bool) {
	var pt savepoint

	if p.memoize {
		res, ok := p.getMemoized(expr)
		if ok {
			p.restore(res.end)
			return res.v, res.b
		}
		pt = p.pt
	}

	val, ok := p.parseExpr(expr)

	if p.memoize {
		p.setMemoized(pt, expr, resultTuple{val, ok, p.pt})
	}
	return val, ok
}

func (p *parser) parseExpr(expr any) (any, bool) {
	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val any
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *stateCodeExpr:
		val, ok = p.parseStateCodeExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseActionExpr"))
	}

	start := p.pt
	val, ok := p.parseExprWrap(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		state := p.cloneState()
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}
		p.restoreState(state)

		val = actVal
	}
	if ok && p.debug {
		p.printIndent("MATCH", string(p.sliceFrom(start)))
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseAndCodeExpr"))
	}

	state := p.cloneState()

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseAndExpr"))
	}

	pt := p.pt
	state := p.cloneState()
	p.pushV()
	_, ok := p.parseExprWrap(and.expr)
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseAnyMatcher"))
	}

	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseCharClassMatcher"))
	}

	cur := p.pt.rn
	start := p.pt

	if cur < 128 {
		if chr.basicLatinChars[cur] != chr.inverted {
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) incChoiceAltCnt(ch *choiceExpr, altI int) {
	choiceIdent := fmt.Sprintf("%s %d:%d", p.rstack[len(p.rstack)-1].name, ch.pos.line, ch.pos.col)
	m := p.ChoiceAltCnt[choiceIdent]
	if m == nil {
		m = make(map[string]int)
		p.ChoiceAltCnt[choiceIdent] = m
	}
	// We increment altI by 1, so the keys do not start at 0
	alt := strconv.Itoa(altI + 1)
	if altI == choiceNoMatch {
		alt = p.choiceNoMatch
	}
	m[alt]++
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseChoiceExpr"))
	}

	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		state := p.cloneState()

		p.pushV()
		val, ok := p.parseExprWrap(alt)
		p.popV()
		if ok {
			p.incChoiceAltCnt(ch, altI)
			return val, ok
		}
		p.restoreState(state)
	}
	p.incChoiceAltCnt(ch, choiceNoMatch)
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseLabeledExpr"))
	}

	p.pushV()
	val, ok := p.parseExprWrap(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseLitMatcher"))
	}

	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseNotCodeExpr"))
	}

	state := p.cloneState()

	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}
	p.restoreState(state)

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseNotExpr"))
	}

	pt := p.pt
	state := p.cloneState()
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExprWrap(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restoreState(state)
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseOneOrMoreExpr"))
	}

	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseRecoveryExpr (" + strings.Join(recover.failureLabel, ",") + ")"))
	}

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExprWrap(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseRuleRefExpr " + ref.name))
	}

	if ref.name == "" {
		panic(fmt.Sprintf("%s: invalid rule: missing name", ref.pos))
	}

	rule := p.rules[ref.name]
	if rule == nil {
		p.addErr(fmt.Errorf("undefined rule: %s", ref.name))
		return nil, false
	}
	return p.parseRuleWrap(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseSeqExpr"))
	}

	vals := make([]any, 0, len(seq.exprs))

	pt := p.pt
	state := p.cloneState()
	for _, expr := range seq.exprs {
		val, ok := p.parseExprWrap(expr)
		if !ok {
			p.restoreState(state)
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseStateCodeExpr(state *stateCodeExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseStateCodeExpr"))
	}

	err := state.run(p)
	if err != nil {
		p.addErr(err)
	}
	return nil, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseThrowExpr"))
	}

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExprWrap(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseZeroOrMoreExpr"))
	}

	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) {
	if p.debug {
		defer p.out(p.in("parseZeroOrOneExpr"))
	}

	p.pushV()
	val, _ := p.parseExprWrap(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}

func rangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}
