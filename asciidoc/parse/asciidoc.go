// Code generated by pigeon; DO NOT EDIT.

package parse

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/project-chip/alchemy/asciidoc"
)

var g = &grammar{
	rules: []*rule{
		{
			name: "Document",
			pos:  position{line: 14, col: 1, offset: 99},
			expr: &actionExpr{
				pos: position{line: 14, col: 12, offset: 110},
				run: (*parser).callonDocument1,
				expr: &seqExpr{
					pos: position{line: 14, col: 12, offset: 110},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 14, col: 12, offset: 110},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 14, col: 20, offset: 118},
								expr: &ruleRefExpr{
									pos:    position{line: 14, col: 21, offset: 119},
									offset: 1,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 14, col: 31, offset: 129},
							offset: 324,
						},
					},
				},
			},
		},
		{
			name: "Element",
			pos:  position{line: 18, col: 1, offset: 184},
			expr: &choiceExpr{
				pos: position{line: 18, col: 12, offset: 195},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 18, col: 12, offset: 195},
						offset: 2,
					},
					&ruleRefExpr{
						pos:    position{line: 18, col: 27, offset: 210},
						offset: 88,
					},
				},
			},
		},
		{
			name: "BlockElement",
			pos:  position{line: 21, col: 1, offset: 225},
			expr: &actionExpr{
				pos: position{line: 21, col: 16, offset: 240},
				run: (*parser).callonBlockElement1,
				expr: &seqExpr{
					pos: position{line: 21, col: 16, offset: 240},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 21, col: 16, offset: 240},
							offset: 327,
						},
						&labeledExpr{
							pos:   position{line: 21, col: 32, offset: 256},
							label: "element",
							expr: &ruleRefExpr{
								pos:    position{line: 21, col: 41, offset: 265},
								offset: 3,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 21, col: 56, offset: 280},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 22, col: 1, offset: 290},
							run: (*parser).callonBlockElement7,
						},
					},
				},
			},
		},
		{
			name: "BlockElements",
			pos:  position{line: 28, col: 1, offset: 389},
			expr: &choiceExpr{
				pos: position{line: 29, col: 5, offset: 411},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 29, col: 5, offset: 411},
						offset: 15,
					},
					&ruleRefExpr{
						pos:    position{line: 30, col: 5, offset: 431},
						offset: 9,
					},
					&ruleRefExpr{
						pos:    position{line: 31, col: 5, offset: 452},
						offset: 5,
					},
					&ruleRefExpr{
						pos:    position{line: 32, col: 5, offset: 477},
						offset: 113,
					},
					&ruleRefExpr{
						pos:    position{line: 33, col: 5, offset: 489},
						offset: 4,
					},
					&ruleRefExpr{
						pos:    position{line: 34, col: 5, offset: 507},
						offset: 13,
					},
				},
			},
		},
		{
			name: "NakedBlocks",
			pos:  position{line: 37, col: 1, offset: 532},
			expr: &choiceExpr{
				pos: position{line: 38, col: 5, offset: 552},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 38, col: 5, offset: 552},
						offset: 272,
					},
					&ruleRefExpr{
						pos:    position{line: 39, col: 5, offset: 576},
						offset: 269,
					},
					&ruleRefExpr{
						pos:    position{line: 40, col: 5, offset: 600},
						offset: 22,
					},
					&ruleRefExpr{
						pos:    position{line: 41, col: 5, offset: 622},
						offset: 26,
					},
					&ruleRefExpr{
						pos:    position{line: 42, col: 5, offset: 643},
						offset: 291,
					},
					&ruleRefExpr{
						pos:    position{line: 43, col: 5, offset: 655},
						offset: 293,
					},
					&ruleRefExpr{
						pos:    position{line: 44, col: 5, offset: 669},
						offset: 302,
					},
					&ruleRefExpr{
						pos:    position{line: 45, col: 5, offset: 682},
						offset: 297,
					},
					&ruleRefExpr{
						pos:    position{line: 46, col: 5, offset: 697},
						offset: 102,
					},
					&ruleRefExpr{
						pos:    position{line: 47, col: 5, offset: 715},
						offset: 265,
					},
					&ruleRefExpr{
						pos:    position{line: 48, col: 5, offset: 741},
						offset: 317,
					},
				},
			},
		},
		{
			name: "AttributableBlocks",
			pos:  position{line: 51, col: 1, offset: 753},
			expr: &actionExpr{
				pos: position{line: 51, col: 22, offset: 774},
				run: (*parser).callonAttributableBlocks1,
				expr: &seqExpr{
					pos: position{line: 51, col: 22, offset: 774},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 51, col: 22, offset: 774},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 51, col: 33, offset: 785},
								expr: &ruleRefExpr{
									pos:    position{line: 51, col: 34, offset: 786},
									offset: 12,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 51, col: 59, offset: 811},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 52, col: 5, offset: 826},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 52, col: 5, offset: 826},
										offset: 170,
									},
									&ruleRefExpr{
										pos:    position{line: 53, col: 5, offset: 841},
										offset: 176,
									},
									&ruleRefExpr{
										pos:    position{line: 54, col: 5, offset: 852},
										offset: 188,
									},
									&ruleRefExpr{
										pos:    position{line: 55, col: 5, offset: 866},
										offset: 200,
									},
									&ruleRefExpr{
										pos:    position{line: 56, col: 5, offset: 880},
										offset: 212,
									},
									&ruleRefExpr{
										pos:    position{line: 57, col: 5, offset: 892},
										offset: 194,
									},
									&ruleRefExpr{
										pos:    position{line: 58, col: 5, offset: 906},
										offset: 226,
									},
									&ruleRefExpr{
										pos:    position{line: 59, col: 5, offset: 920},
										offset: 232,
									},
									&ruleRefExpr{
										pos:    position{line: 60, col: 5, offset: 931},
										offset: 19,
									},
									&ruleRefExpr{
										pos:    position{line: 61, col: 5, offset: 946},
										offset: 224,
									},
									&ruleRefExpr{
										pos:    position{line: 62, col: 5, offset: 966},
										offset: 225,
									},
									&ruleRefExpr{
										pos:    position{line: 63, col: 5, offset: 982},
										offset: 98,
									},
									&ruleRefExpr{
										pos:    position{line: 64, col: 5, offset: 999},
										offset: 260,
									},
									&ruleRefExpr{
										pos:    position{line: 65, col: 5, offset: 1022},
										offset: 262,
									},
									&ruleRefExpr{
										pos:    position{line: 66, col: 5, offset: 1047},
										offset: 265,
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 67, col: 9, offset: 1076},
							run: (*parser).callonAttributableBlocks23,
						},
					},
				},
			},
		},
		{
			name: "BlockAttributes",
			pos:  position{line: 80, col: 1, offset: 1475},
			expr: &choiceExpr{
				pos: position{line: 80, col: 19, offset: 1493},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 80, col: 19, offset: 1493},
						offset: 85,
					},
					&ruleRefExpr{
						pos:    position{line: 80, col: 37, offset: 1511},
						offset: 7,
					},
					&ruleRefExpr{
						pos:    position{line: 80, col: 50, offset: 1524},
						offset: 27,
					},
					&ruleRefExpr{
						pos:    position{line: 80, col: 63, offset: 1537},
						offset: 31,
					},
				},
			},
		},
		{
			name: "BlockTitle",
			pos:  position{line: 82, col: 1, offset: 1558},
			expr: &actionExpr{
				pos: position{line: 82, col: 14, offset: 1571},
				run: (*parser).callonBlockTitle1,
				expr: &seqExpr{
					pos: position{line: 82, col: 14, offset: 1571},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 82, col: 14, offset: 1571},
							offset: 327,
						},
						&litMatcher{
							pos:        position{line: 82, col: 30, offset: 1587},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&notExpr{
							pos: position{line: 82, col: 34, offset: 1591},
							expr: &charClassMatcher{
								pos:        position{line: 82, col: 35, offset: 1592},
								val:        "[ .]",
								chars:      []rune{' ', '.'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&labeledExpr{
							pos:   position{line: 82, col: 40, offset: 1597},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 82, col: 49, offset: 1606},
								offset: 8,
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTitleContent",
			pos:  position{line: 90, col: 1, offset: 1786},
			expr: &actionExpr{
				pos: position{line: 90, col: 21, offset: 1806},
				run: (*parser).callonBlockTitleContent1,
				expr: &labeledExpr{
					pos:   position{line: 90, col: 21, offset: 1806},
					label: "content",
					expr: &oneOrMoreExpr{
						pos: position{line: 90, col: 29, offset: 1814},
						expr: &choiceExpr{
							pos: position{line: 90, col: 30, offset: 1815},
							alternatives: []any{
								&ruleRefExpr{
									pos:    position{line: 90, col: 30, offset: 1815},
									offset: 91,
								},
								&ruleRefExpr{
									pos:    position{line: 90, col: 48, offset: 1833},
									offset: 323,
								},
								&ruleRefExpr{
									pos:    position{line: 90, col: 63, offset: 1848},
									offset: 339,
								},
								&ruleRefExpr{
									pos:    position{line: 90, col: 67, offset: 1852},
									offset: 310,
								},
								&ruleRefExpr{
									pos:    position{line: 90, col: 81, offset: 1866},
									offset: 53,
								},
								&ruleRefExpr{
									pos:    position{line: 90, col: 102, offset: 1887},
									offset: 336,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockEmptyLine",
			pos:  position{line: 94, col: 1, offset: 1954},
			expr: &actionExpr{
				pos: position{line: 94, col: 18, offset: 1971},
				run: (*parser).callonBlockEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 94, col: 18, offset: 1971},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 94, col: 18, offset: 1971},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 94, col: 28, offset: 1981},
							expr: &ruleRefExpr{
								pos:    position{line: 94, col: 29, offset: 1982},
								offset: 317,
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElementAttribute",
			pos:  position{line: 98, col: 1, offset: 2060},
			expr: &actionExpr{
				pos: position{line: 98, col: 25, offset: 2084},
				run: (*parser).callonBlockElementAttribute1,
				expr: &seqExpr{
					pos: position{line: 98, col: 25, offset: 2084},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 98, col: 25, offset: 2084},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 98, col: 37, offset: 2096},
								offset: 6,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 98, col: 54, offset: 2113},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 98, col: 64, offset: 2123},
							expr: &ruleRefExpr{
								pos:    position{line: 98, col: 65, offset: 2124},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElementAdditionalAttribute",
			pos:  position{line: 102, col: 1, offset: 2170},
			expr: &actionExpr{
				pos: position{line: 102, col: 35, offset: 2204},
				run: (*parser).callonBlockElementAdditionalAttribute1,
				expr: &seqExpr{
					pos: position{line: 102, col: 35, offset: 2204},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 102, col: 35, offset: 2204},
							offset: 317,
						},
						&labeledExpr{
							pos:   position{line: 102, col: 43, offset: 2212},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 102, col: 55, offset: 2224},
								offset: 6,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 102, col: 72, offset: 2241},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 102, col: 82, offset: 2251},
							expr: &ruleRefExpr{
								pos:    position{line: 102, col: 83, offset: 2252},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "BlockElementAttributes",
			pos:  position{line: 106, col: 1, offset: 2298},
			expr: &actionExpr{
				pos: position{line: 106, col: 26, offset: 2323},
				run: (*parser).callonBlockElementAttributes1,
				expr: &seqExpr{
					pos: position{line: 106, col: 26, offset: 2323},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 106, col: 26, offset: 2323},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:    position{line: 106, col: 37, offset: 2334},
								offset: 10,
							},
						},
						&labeledExpr{
							pos:   position{line: 106, col: 60, offset: 2357},
							label: "additionalAttributes",
							expr: &zeroOrMoreExpr{
								pos: position{line: 106, col: 81, offset: 2378},
								expr: &ruleRefExpr{
									pos:    position{line: 106, col: 82, offset: 2379},
									offset: 11,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 106, col: 116, offset: 2413},
							offset: 330,
						},
						&zeroOrMoreExpr{
							pos: position{line: 106, col: 126, offset: 2423},
							expr: &ruleRefExpr{
								pos:    position{line: 106, col: 126, offset: 2423},
								offset: 315,
							},
						},
					},
				},
			},
		},
		{
			name: "NakedBlockAttributes",
			pos:  position{line: 114, col: 1, offset: 2640},
			expr: &actionExpr{
				pos: position{line: 114, col: 24, offset: 2663},
				run: (*parser).callonNakedBlockAttributes1,
				expr: &seqExpr{
					pos: position{line: 114, col: 24, offset: 2663},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 114, col: 24, offset: 2663},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:    position{line: 114, col: 35, offset: 2674},
								offset: 10,
							},
						},
						&labeledExpr{
							pos:   position{line: 114, col: 58, offset: 2697},
							label: "additionalAttributes",
							expr: &zeroOrMoreExpr{
								pos: position{line: 114, col: 79, offset: 2718},
								expr: &ruleRefExpr{
									pos:    position{line: 114, col: 80, offset: 2719},
									offset: 11,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockDelimiters",
			pos:  position{line: 126, col: 1, offset: 3061},
			expr: &seqExpr{
				pos: position{line: 127, col: 5, offset: 3084},
				exprs: []any{
					&notExpr{
						pos: position{line: 127, col: 5, offset: 3084},
						expr: &ruleRefExpr{
							pos:    position{line: 127, col: 6, offset: 3085},
							offset: 323,
						},
					},
					&choiceExpr{
						pos: position{line: 129, col: 9, offset: 3115},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 129, col: 9, offset: 3115},
								offset: 275,
							},
							&ruleRefExpr{
								pos:    position{line: 130, col: 11, offset: 3156},
								offset: 191,
							},
							&ruleRefExpr{
								pos:    position{line: 131, col: 11, offset: 3180},
								offset: 229,
							},
							&ruleRefExpr{
								pos:    position{line: 132, col: 11, offset: 3206},
								offset: 173,
							},
							&ruleRefExpr{
								pos:    position{line: 133, col: 11, offset: 3231},
								offset: 197,
							},
							&ruleRefExpr{
								pos:    position{line: 134, col: 11, offset: 3253},
								offset: 235,
							},
							&ruleRefExpr{
								pos:    position{line: 135, col: 11, offset: 3274},
								offset: 215,
							},
							&ruleRefExpr{
								pos:    position{line: 136, col: 11, offset: 3300},
								offset: 203,
							},
						},
					},
				},
			},
		},
		{
			name: "AlchemyEscape",
			pos:  position{line: 140, col: 1, offset: 3325},
			expr: &actionExpr{
				pos: position{line: 141, col: 5, offset: 3345},
				run: (*parser).callonAlchemyEscape1,
				expr: &seqExpr{
					pos: position{line: 141, col: 5, offset: 3345},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 141, col: 5, offset: 3345},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 141, col: 12, offset: 3352},
								offset: 16,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 142, col: 5, offset: 3377},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 142, col: 15, offset: 3387},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 142, col: 22, offset: 3394},
								offset: 24,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 142, col: 46, offset: 3418},
							offset: 330,
						},
						&labeledExpr{
							pos:   position{line: 143, col: 5, offset: 3432},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 143, col: 11, offset: 3438},
								expr: &ruleRefExpr{
									pos:    position{line: 143, col: 12, offset: 3439},
									offset: 17,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 144, col: 5, offset: 3463},
							offset: 18,
						},
					},
				},
			},
		},
		{
			name: "AlchemyEscapeStart",
			pos:  position{line: 148, col: 1, offset: 3658},
			expr: &litMatcher{
				pos:        position{line: 148, col: 22, offset: 3679},
				val:        ":alchemy-escape:",
				ignoreCase: false,
				want:       "\":alchemy-escape:\"",
			},
		},
		{
			name: "AlchemyEscapeLine",
			pos:  position{line: 150, col: 1, offset: 3700},
			expr: &actionExpr{
				pos: position{line: 150, col: 21, offset: 3720},
				run: (*parser).callonAlchemyEscapeLine1,
				expr: &seqExpr{
					pos: position{line: 150, col: 22, offset: 3721},
					exprs: []any{
						&notExpr{
							pos: position{line: 150, col: 22, offset: 3721},
							expr: &ruleRefExpr{
								pos:    position{line: 150, col: 23, offset: 3722},
								offset: 18,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 150, col: 40, offset: 3739},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 150, col: 53, offset: 3752},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 150, col: 58, offset: 3757},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 150, col: 66, offset: 3765},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "AlchemyEscapeEnd",
			pos:  position{line: 154, col: 1, offset: 3812},
			expr: &choiceExpr{
				pos: position{line: 154, col: 20, offset: 3831},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 154, col: 20, offset: 3831},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 154, col: 20, offset: 3831},
								val:        ":!alchemy-escape:",
								ignoreCase: false,
								want:       "\":!alchemy-escape:\"",
							},
							&andExpr{
								pos: position{line: 154, col: 40, offset: 3851},
								expr: &ruleRefExpr{
									pos:    position{line: 154, col: 41, offset: 3852},
									offset: 330,
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 154, col: 53, offset: 3864},
						offset: 324,
					},
				},
			},
		},
		{
			name: "Section",
			pos:  position{line: 156, col: 1, offset: 3875},
			expr: &actionExpr{
				pos: position{line: 156, col: 11, offset: 3885},
				run: (*parser).callonSection1,
				expr: &seqExpr{
					pos: position{line: 156, col: 11, offset: 3885},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 156, col: 11, offset: 3885},
							label: "level",
							expr: &actionExpr{
								pos: position{line: 156, col: 18, offset: 3892},
								run: (*parser).callonSection4,
								expr: &oneOrMoreExpr{
									pos: position{line: 156, col: 18, offset: 3892},
									expr: &charClassMatcher{
										pos:        position{line: 156, col: 18, offset: 3892},
										val:        "[=]",
										chars:      []rune{'='},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 159, col: 5, offset: 3951},
							run: (*parser).callonSection7,
						},
						&ruleRefExpr{
							pos:    position{line: 162, col: 5, offset: 4008},
							offset: 338,
						},
						&labeledExpr{
							pos:   position{line: 162, col: 8, offset: 4011},
							label: "title",
							expr: &ruleRefExpr{
								pos:    position{line: 162, col: 15, offset: 4018},
								offset: 20,
							},
						},
						&andExpr{
							pos: position{line: 162, col: 29, offset: 4032},
							expr: &ruleRefExpr{
								pos:    position{line: 162, col: 30, offset: 4033},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "SectionTitle",
			pos:  position{line: 166, col: 1, offset: 4148},
			expr: &oneOrMoreExpr{
				pos: position{line: 166, col: 16, offset: 4163},
				expr: &ruleRefExpr{
					pos:    position{line: 166, col: 17, offset: 4164},
					offset: 21,
				},
			},
		},
		{
			name: "SectionTitleValue",
			pos:  position{line: 168, col: 1, offset: 4185},
			expr: &seqExpr{
				pos: position{line: 168, col: 21, offset: 4205},
				exprs: []any{
					&notExpr{
						pos: position{line: 168, col: 21, offset: 4205},
						expr: &ruleRefExpr{
							pos:    position{line: 168, col: 22, offset: 4206},
							offset: 330,
						},
					},
					&choiceExpr{
						pos: position{line: 169, col: 5, offset: 4222},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 169, col: 5, offset: 4222},
								offset: 108,
							},
							&ruleRefExpr{
								pos:    position{line: 170, col: 7, offset: 4234},
								offset: 332,
							},
							&ruleRefExpr{
								pos:    position{line: 171, col: 7, offset: 4254},
								offset: 338,
							},
							&ruleRefExpr{
								pos:    position{line: 172, col: 7, offset: 4264},
								offset: 309,
							},
							&ruleRefExpr{
								pos:    position{line: 173, col: 7, offset: 4282},
								offset: 310,
							},
							&ruleRefExpr{
								pos:    position{line: 174, col: 7, offset: 4302},
								offset: 95,
							},
							&ruleRefExpr{
								pos:    position{line: 175, col: 7, offset: 4322},
								offset: 283,
							},
							&ruleRefExpr{
								pos:    position{line: 176, col: 7, offset: 4346},
								offset: 307,
							},
							&ruleRefExpr{
								pos:    position{line: 177, col: 7, offset: 4370},
								offset: 101,
							},
							&ruleRefExpr{
								pos:    position{line: 178, col: 7, offset: 4382},
								offset: 53,
							},
							&ruleRefExpr{
								pos:    position{line: 179, col: 7, offset: 4408},
								offset: 84,
							},
							&ruleRefExpr{
								pos:    position{line: 181, col: 7, offset: 4437},
								offset: 336,
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeEntry",
			pos:  position{line: 184, col: 1, offset: 4462},
			expr: &actionExpr{
				pos: position{line: 184, col: 18, offset: 4479},
				run: (*parser).callonAttributeEntry1,
				expr: &seqExpr{
					pos: position{line: 184, col: 18, offset: 4479},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 184, col: 18, offset: 4479},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 184, col: 22, offset: 4483},
							label: "name",
							expr: &ruleRefExpr{
								pos:    position{line: 184, col: 28, offset: 4489},
								offset: 23,
							},
						},
						&litMatcher{
							pos:        position{line: 184, col: 48, offset: 4509},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&ruleRefExpr{
							pos:    position{line: 184, col: 52, offset: 4513},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 184, col: 62, offset: 4523},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 184, col: 69, offset: 4530},
								offset: 24,
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeEntryName",
			pos:  position{line: 188, col: 1, offset: 4674},
			expr: &actionExpr{
				pos: position{line: 188, col: 22, offset: 4695},
				run: (*parser).callonAttributeEntryName1,
				expr: &seqExpr{
					pos: position{line: 188, col: 22, offset: 4695},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 188, col: 22, offset: 4695},
							offset: 337,
						},
						&zeroOrMoreExpr{
							pos: position{line: 188, col: 41, offset: 4714},
							expr: &choiceExpr{
								pos: position{line: 188, col: 42, offset: 4715},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 188, col: 42, offset: 4715},
										offset: 337,
									},
									&litMatcher{
										pos:        position{line: 188, col: 63, offset: 4736},
										val:        "-",
										ignoreCase: false,
										want:       "\"-\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeEntryElements",
			pos:  position{line: 192, col: 1, offset: 4782},
			expr: &actionExpr{
				pos: position{line: 192, col: 26, offset: 4807},
				run: (*parser).callonAttributeEntryElements1,
				expr: &labeledExpr{
					pos:   position{line: 192, col: 26, offset: 4807},
					label: "value",
					expr: &zeroOrMoreExpr{
						pos: position{line: 192, col: 32, offset: 4813},
						expr: &ruleRefExpr{
							pos:    position{line: 192, col: 32, offset: 4813},
							offset: 25,
						},
					},
				},
			},
		},
		{
			name: "AttributeEntryElement",
			pos:  position{line: 196, col: 1, offset: 4889},
			expr: &choiceExpr{
				pos: position{line: 196, col: 26, offset: 4914},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 196, col: 26, offset: 4914},
						exprs: []any{
							&ruleRefExpr{
								pos:    position{line: 196, col: 26, offset: 4914},
								offset: 311,
							},
							&ruleRefExpr{
								pos:    position{line: 196, col: 36, offset: 4924},
								offset: 330,
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 196, col: 48, offset: 4936},
						offset: 336,
					},
				},
			},
		},
		{
			name: "AttributeReset",
			pos:  position{line: 198, col: 1, offset: 4960},
			expr: &choiceExpr{
				pos: position{line: 198, col: 18, offset: 4977},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 198, col: 18, offset: 4977},
						run: (*parser).callonAttributeReset2,
						expr: &seqExpr{
							pos: position{line: 198, col: 18, offset: 4977},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 198, col: 18, offset: 4977},
									val:        ":!",
									ignoreCase: false,
									want:       "\":!\"",
								},
								&labeledExpr{
									pos:   position{line: 198, col: 23, offset: 4982},
									label: "name",
									expr: &ruleRefExpr{
										pos:    position{line: 198, col: 29, offset: 4988},
										offset: 23,
									},
								},
								&litMatcher{
									pos:        position{line: 198, col: 49, offset: 5008},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&ruleRefExpr{
									pos:    position{line: 198, col: 53, offset: 5012},
									offset: 334,
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 200, col: 5, offset: 5094},
						run: (*parser).callonAttributeReset9,
						expr: &seqExpr{
							pos: position{line: 200, col: 5, offset: 5094},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 200, col: 5, offset: 5094},
									val:        ":",
									ignoreCase: false,
									want:       "\":\"",
								},
								&labeledExpr{
									pos:   position{line: 200, col: 9, offset: 5098},
									label: "name",
									expr: &ruleRefExpr{
										pos:    position{line: 200, col: 15, offset: 5104},
										offset: 23,
									},
								},
								&litMatcher{
									pos:        position{line: 200, col: 35, offset: 5124},
									val:        "!:",
									ignoreCase: false,
									want:       "\"!:\"",
								},
								&ruleRefExpr{
									pos:    position{line: 200, col: 40, offset: 5129},
									offset: 334,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Attributes",
			pos:  position{line: 205, col: 1, offset: 5289},
			expr: &actionExpr{
				pos: position{line: 205, col: 14, offset: 5302},
				run: (*parser).callonAttributes1,
				expr: &seqExpr{
					pos: position{line: 205, col: 14, offset: 5302},
					exprs: []any{
						&notExpr{
							pos: position{line: 205, col: 14, offset: 5302},
							expr: &litMatcher{
								pos:        position{line: 205, col: 15, offset: 5303},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 205, col: 20, offset: 5308},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&notExpr{
							pos: position{line: 205, col: 24, offset: 5312},
							expr: &litMatcher{
								pos:        position{line: 205, col: 25, offset: 5313},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 205, col: 29, offset: 5317},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 205, col: 41, offset: 5329},
								offset: 28,
							},
						},
						&litMatcher{
							pos:        position{line: 205, col: 56, offset: 5344},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "AttributeList",
			pos:  position{line: 210, col: 1, offset: 5386},
			expr: &actionExpr{
				pos: position{line: 210, col: 17, offset: 5402},
				run: (*parser).callonAttributeList1,
				expr: &labeledExpr{
					pos:   position{line: 210, col: 17, offset: 5402},
					label: "attributes",
					expr: &zeroOrMoreExpr{
						pos: position{line: 210, col: 28, offset: 5413},
						expr: &ruleRefExpr{
							pos:    position{line: 210, col: 29, offset: 5414},
							offset: 29,
						},
					},
				},
			},
		},
		{
			name: "AttributeListItem",
			pos:  position{line: 214, col: 1, offset: 5499},
			expr: &actionExpr{
				pos: position{line: 214, col: 21, offset: 5519},
				run: (*parser).callonAttributeListItem1,
				expr: &seqExpr{
					pos: position{line: 214, col: 21, offset: 5519},
					exprs: []any{
						&notExpr{
							pos: position{line: 214, col: 21, offset: 5519},
							expr: &litMatcher{
								pos:        position{line: 214, col: 22, offset: 5520},
								val:        "]",
								ignoreCase: false,
								want:       "\"]\"",
							},
						},
						&ruleRefExpr{
							pos:    position{line: 214, col: 26, offset: 5524},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 214, col: 36, offset: 5534},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:    position{line: 214, col: 47, offset: 5545},
								offset: 30,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 214, col: 58, offset: 5556},
							offset: 334,
						},
						&zeroOrOneExpr{
							pos: position{line: 214, col: 68, offset: 5566},
							expr: &litMatcher{
								pos:        position{line: 214, col: 68, offset: 5566},
								val:        ",",
								ignoreCase: false,
								want:       "\",\"",
							},
						},
					},
				},
			},
		},
		{
			name: "Attribute",
			pos:  position{line: 218, col: 1, offset: 5602},
			expr: &actionExpr{
				pos: position{line: 218, col: 13, offset: 5614},
				run: (*parser).callonAttribute1,
				expr: &seqExpr{
					pos: position{line: 218, col: 13, offset: 5614},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 218, col: 13, offset: 5614},
							label: "name",
							expr: &zeroOrOneExpr{
								pos: position{line: 218, col: 18, offset: 5619},
								expr: &actionExpr{
									pos: position{line: 218, col: 20, offset: 5621},
									run: (*parser).callonAttribute5,
									expr: &seqExpr{
										pos: position{line: 218, col: 21, offset: 5622},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 218, col: 21, offset: 5622},
												label: "name",
												expr: &ruleRefExpr{
													pos:    position{line: 218, col: 27, offset: 5628},
													offset: 52,
												},
											},
											&ruleRefExpr{
												pos:    position{line: 218, col: 47, offset: 5648},
												offset: 334,
											},
											&litMatcher{
												pos:        position{line: 218, col: 57, offset: 5658},
												val:        "=",
												ignoreCase: false,
												want:       "\"=\"",
											},
											&ruleRefExpr{
												pos:    position{line: 218, col: 61, offset: 5662},
												offset: 334,
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 218, col: 95, offset: 5696},
							label: "value",
							expr: &choiceExpr{
								pos: position{line: 218, col: 102, offset: 5703},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 218, col: 102, offset: 5703},
										offset: 38,
									},
									&ruleRefExpr{
										pos:    position{line: 218, col: 130, offset: 5731},
										offset: 43,
									},
									&ruleRefExpr{
										pos:    position{line: 218, col: 158, offset: 5759},
										offset: 47,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandAttributes",
			pos:  position{line: 225, col: 1, offset: 6015},
			expr: &actionExpr{
				pos: position{line: 225, col: 23, offset: 6037},
				run: (*parser).callonShorthandAttributes1,
				expr: &seqExpr{
					pos: position{line: 225, col: 23, offset: 6037},
					exprs: []any{
						&notExpr{
							pos: position{line: 225, col: 23, offset: 6037},
							expr: &litMatcher{
								pos:        position{line: 225, col: 24, offset: 6038},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 225, col: 29, offset: 6043},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&notExpr{
							pos: position{line: 225, col: 33, offset: 6047},
							expr: &litMatcher{
								pos:        position{line: 225, col: 34, offset: 6048},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 225, col: 38, offset: 6052},
							label: "attribute",
							expr: &ruleRefExpr{
								pos:    position{line: 225, col: 49, offset: 6063},
								offset: 32,
							},
						},
						&litMatcher{
							pos:        position{line: 225, col: 69, offset: 6083},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "ShorthandAttribute",
			pos:  position{line: 229, col: 1, offset: 6123},
			expr: &actionExpr{
				pos: position{line: 229, col: 22, offset: 6144},
				run: (*parser).callonShorthandAttribute1,
				expr: &seqExpr{
					pos: position{line: 229, col: 22, offset: 6144},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 229, col: 22, offset: 6144},
							label: "style",
							expr: &zeroOrOneExpr{
								pos: position{line: 229, col: 28, offset: 6150},
								expr: &ruleRefExpr{
									pos:    position{line: 229, col: 29, offset: 6151},
									offset: 37,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 229, col: 55, offset: 6177},
							label: "values",
							expr: &oneOrMoreExpr{
								pos: position{line: 229, col: 62, offset: 6184},
								expr: &choiceExpr{
									pos: position{line: 229, col: 63, offset: 6185},
									alternatives: []any{
										&ruleRefExpr{
											pos:    position{line: 229, col: 63, offset: 6185},
											offset: 34,
										},
										&ruleRefExpr{
											pos:    position{line: 229, col: 77, offset: 6199},
											offset: 35,
										},
										&ruleRefExpr{
											pos:    position{line: 229, col: 93, offset: 6215},
											offset: 36,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandStyle",
			pos:  position{line: 233, col: 1, offset: 6303},
			expr: &actionExpr{
				pos: position{line: 233, col: 18, offset: 6320},
				run: (*parser).callonShorthandStyle1,
				expr: &labeledExpr{
					pos:   position{line: 233, col: 18, offset: 6320},
					label: "value",
					expr: &ruleRefExpr{
						pos:    position{line: 233, col: 24, offset: 6326},
						offset: 37,
					},
				},
			},
		},
		{
			name: "ShorthandID",
			pos:  position{line: 237, col: 1, offset: 6425},
			expr: &actionExpr{
				pos: position{line: 237, col: 15, offset: 6439},
				run: (*parser).callonShorthandID1,
				expr: &seqExpr{
					pos: position{line: 237, col: 15, offset: 6439},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 237, col: 15, offset: 6439},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&labeledExpr{
							pos:   position{line: 237, col: 19, offset: 6443},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 237, col: 25, offset: 6449},
								offset: 37,
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandRole",
			pos:  position{line: 241, col: 1, offset: 6548},
			expr: &actionExpr{
				pos: position{line: 241, col: 17, offset: 6564},
				run: (*parser).callonShorthandRole1,
				expr: &seqExpr{
					pos: position{line: 241, col: 17, offset: 6564},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 241, col: 17, offset: 6564},
							val:        ".",
							ignoreCase: false,
							want:       "\".\"",
						},
						&labeledExpr{
							pos:   position{line: 241, col: 21, offset: 6568},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 241, col: 27, offset: 6574},
								offset: 37,
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandOption",
			pos:  position{line: 245, col: 1, offset: 6675},
			expr: &actionExpr{
				pos: position{line: 245, col: 19, offset: 6693},
				run: (*parser).callonShorthandOption1,
				expr: &seqExpr{
					pos: position{line: 245, col: 19, offset: 6693},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 245, col: 19, offset: 6693},
							val:        "%",
							ignoreCase: false,
							want:       "\"%\"",
						},
						&labeledExpr{
							pos:   position{line: 245, col: 23, offset: 6697},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 245, col: 29, offset: 6703},
								offset: 37,
							},
						},
					},
				},
			},
		},
		{
			name: "ShorthandAttributeValue",
			pos:  position{line: 249, col: 1, offset: 6806},
			expr: &choiceExpr{
				pos: position{line: 249, col: 28, offset: 6833},
				alternatives: []any{
					&seqExpr{
						pos: position{line: 249, col: 28, offset: 6833},
						exprs: []any{
							&notExpr{
								pos: position{line: 249, col: 28, offset: 6833},
								expr: &litMatcher{
									pos:        position{line: 249, col: 29, offset: 6834},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
							},
							&notExpr{
								pos: position{line: 249, col: 33, offset: 6838},
								expr: &litMatcher{
									pos:        position{line: 249, col: 34, offset: 6839},
									val:        ".",
									ignoreCase: false,
									want:       "\".\"",
								},
							},
							&notExpr{
								pos: position{line: 249, col: 38, offset: 6843},
								expr: &litMatcher{
									pos:        position{line: 249, col: 39, offset: 6844},
									val:        "%",
									ignoreCase: false,
									want:       "\"%\"",
								},
							},
							&ruleRefExpr{
								pos:    position{line: 249, col: 43, offset: 6848},
								offset: 38,
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 249, col: 71, offset: 6876},
						offset: 43,
					},
					&ruleRefExpr{
						pos:    position{line: 249, col: 99, offset: 6904},
						offset: 47,
					},
				},
			},
		},
		{
			name: "SingleQuoteAttributeValue",
			pos:  position{line: 251, col: 1, offset: 6926},
			expr: &actionExpr{
				pos: position{line: 251, col: 29, offset: 6954},
				run: (*parser).callonSingleQuoteAttributeValue1,
				expr: &seqExpr{
					pos: position{line: 251, col: 29, offset: 6954},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 251, col: 29, offset: 6954},
							val:        "'",
							ignoreCase: false,
							want:       "\"'\"",
						},
						&labeledExpr{
							pos:   position{line: 251, col: 33, offset: 6958},
							label: "value",
							expr: &zeroOrMoreExpr{
								pos: position{line: 251, col: 39, offset: 6964},
								expr: &ruleRefExpr{
									pos:    position{line: 251, col: 40, offset: 6965},
									offset: 39,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 251, col: 76, offset: 7001},
							val:        "'",
							ignoreCase: false,
							want:       "\"'\"",
						},
					},
				},
			},
		},
		{
			name: "SingleQuoteAttributeValueElements",
			pos:  position{line: 255, col: 1, offset: 7116},
			expr: &labeledExpr{
				pos:   position{line: 255, col: 37, offset: 7152},
				label: "content",
				expr: &oneOrMoreExpr{
					pos: position{line: 255, col: 45, offset: 7160},
					expr: &choiceExpr{
						pos: position{line: 255, col: 46, offset: 7161},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 255, col: 46, offset: 7161},
								offset: 53,
							},
							&ruleRefExpr{
								pos:    position{line: 255, col: 67, offset: 7182},
								offset: 40,
							},
						},
					},
				},
			},
		},
		{
			name: "SingleQuoteAttributeValueElement",
			pos:  position{line: 257, col: 1, offset: 7218},
			expr: &seqExpr{
				pos: position{line: 257, col: 37, offset: 7254},
				exprs: []any{
					&notExpr{
						pos: position{line: 257, col: 37, offset: 7254},
						expr: &ruleRefExpr{
							pos:    position{line: 257, col: 38, offset: 7255},
							offset: 53,
						},
					},
					&ruleRefExpr{
						pos:    position{line: 257, col: 57, offset: 7274},
						offset: 41,
					},
				},
			},
		},
		{
			name: "SingleQuoteAttributeValueCharacter",
			pos:  position{line: 259, col: 1, offset: 7311},
			expr: &choiceExpr{
				pos: position{line: 260, col: 5, offset: 7354},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 260, col: 6, offset: 7355},
						run: (*parser).callonSingleQuoteAttributeValueCharacter2,
						expr: &litMatcher{
							pos:        position{line: 260, col: 6, offset: 7355},
							val:        "\\'",
							ignoreCase: false,
							want:       "\"\\\\'\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 261, col: 5, offset: 7409},
						offset: 323,
					},
					&ruleRefExpr{
						pos:    position{line: 262, col: 5, offset: 7429},
						offset: 339,
					},
					&ruleRefExpr{
						pos:    position{line: 263, col: 5, offset: 7437},
						offset: 312,
					},
					&charClassMatcher{
						pos:        position{line: 264, col: 5, offset: 7456},
						val:        "[^\\r\\n\\\\' ]",
						chars:      []rune{'\r', '\n', '\\', '\'', ' '},
						ignoreCase: false,
						inverted:   true,
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValueElements",
			pos:  position{line: 267, col: 1, offset: 7472},
			expr: &choiceExpr{
				pos: position{line: 267, col: 38, offset: 7509},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 267, col: 38, offset: 7509},
						offset: 53,
					},
					&ruleRefExpr{
						pos:    position{line: 267, col: 59, offset: 7530},
						offset: 45,
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValue",
			pos:  position{line: 269, col: 1, offset: 7565},
			expr: &actionExpr{
				pos: position{line: 269, col: 29, offset: 7593},
				run: (*parser).callonDoubleQuoteAttributeValue1,
				expr: &seqExpr{
					pos: position{line: 269, col: 29, offset: 7593},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 269, col: 29, offset: 7593},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
						&labeledExpr{
							pos:   position{line: 269, col: 34, offset: 7598},
							label: "value",
							expr: &zeroOrMoreExpr{
								pos: position{line: 269, col: 40, offset: 7604},
								expr: &ruleRefExpr{
									pos:    position{line: 269, col: 41, offset: 7605},
									offset: 44,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 269, col: 77, offset: 7641},
							val:        "\"",
							ignoreCase: false,
							want:       "\"\\\"\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValueElements",
			pos:  position{line: 273, col: 1, offset: 7757},
			expr: &labeledExpr{
				pos:   position{line: 273, col: 37, offset: 7793},
				label: "content",
				expr: &oneOrMoreExpr{
					pos: position{line: 273, col: 45, offset: 7801},
					expr: &choiceExpr{
						pos: position{line: 273, col: 46, offset: 7802},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 273, col: 46, offset: 7802},
								offset: 53,
							},
							&ruleRefExpr{
								pos:    position{line: 273, col: 67, offset: 7823},
								offset: 45,
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValueElement",
			pos:  position{line: 275, col: 1, offset: 7859},
			expr: &seqExpr{
				pos: position{line: 275, col: 37, offset: 7895},
				exprs: []any{
					&notExpr{
						pos: position{line: 275, col: 37, offset: 7895},
						expr: &ruleRefExpr{
							pos:    position{line: 275, col: 38, offset: 7896},
							offset: 53,
						},
					},
					&ruleRefExpr{
						pos:    position{line: 275, col: 57, offset: 7915},
						offset: 46,
					},
				},
			},
		},
		{
			name: "DoubleQuoteAttributeValueCharacter",
			pos:  position{line: 277, col: 1, offset: 7952},
			expr: &choiceExpr{
				pos: position{line: 278, col: 5, offset: 7995},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 278, col: 6, offset: 7996},
						run: (*parser).callonDoubleQuoteAttributeValueCharacter2,
						expr: &litMatcher{
							pos:        position{line: 278, col: 6, offset: 7996},
							val:        "\\\"",
							ignoreCase: false,
							want:       "\"\\\\\\\"\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 279, col: 5, offset: 8051},
						offset: 323,
					},
					&ruleRefExpr{
						pos:    position{line: 280, col: 5, offset: 8071},
						offset: 339,
					},
					&ruleRefExpr{
						pos:    position{line: 281, col: 5, offset: 8079},
						offset: 312,
					},
					&charClassMatcher{
						pos:        position{line: 282, col: 5, offset: 8098},
						val:        "[^\\r\\n\\\\\" ]",
						chars:      []rune{'\r', '\n', '\\', '"', ' '},
						ignoreCase: false,
						inverted:   true,
					},
				},
			},
		},
		{
			name: "NakedAttributeValue",
			pos:  position{line: 285, col: 1, offset: 8113},
			expr: &actionExpr{
				pos: position{line: 285, col: 23, offset: 8135},
				run: (*parser).callonNakedAttributeValue1,
				expr: &seqExpr{
					pos: position{line: 285, col: 23, offset: 8135},
					exprs: []any{
						&notExpr{
							pos: position{line: 285, col: 23, offset: 8135},
							expr: &ruleRefExpr{
								pos:    position{line: 285, col: 24, offset: 8136},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 285, col: 26, offset: 8138},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 285, col: 33, offset: 8145},
								offset: 48,
							},
						},
					},
				},
			},
		},
		{
			name: "NakedAttributeValueElements",
			pos:  position{line: 289, col: 1, offset: 8248},
			expr: &labeledExpr{
				pos:   position{line: 289, col: 31, offset: 8278},
				label: "content",
				expr: &oneOrMoreExpr{
					pos: position{line: 289, col: 39, offset: 8286},
					expr: &choiceExpr{
						pos: position{line: 289, col: 40, offset: 8287},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 289, col: 40, offset: 8287},
								offset: 53,
							},
							&ruleRefExpr{
								pos:    position{line: 289, col: 61, offset: 8308},
								offset: 49,
							},
						},
					},
				},
			},
		},
		{
			name: "NakedAttributeValueElement",
			pos:  position{line: 291, col: 1, offset: 8338},
			expr: &seqExpr{
				pos: position{line: 291, col: 31, offset: 8368},
				exprs: []any{
					&notExpr{
						pos: position{line: 291, col: 31, offset: 8368},
						expr: &ruleRefExpr{
							pos:    position{line: 291, col: 32, offset: 8369},
							offset: 53,
						},
					},
					&ruleRefExpr{
						pos:    position{line: 291, col: 51, offset: 8388},
						offset: 50,
					},
				},
			},
		},
		{
			name: "NakedAttributeValueCharacter",
			pos:  position{line: 293, col: 1, offset: 8419},
			expr: &choiceExpr{
				pos: position{line: 294, col: 5, offset: 8456},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 294, col: 5, offset: 8456},
						offset: 339,
					},
					&charClassMatcher{
						pos:        position{line: 295, col: 5, offset: 8465},
						val:        "[^=\\], ]",
						chars:      []rune{'=', ']', ',', ' '},
						ignoreCase: false,
						inverted:   true,
					},
				},
			},
		},
		{
			name: "InlineAttributes",
			pos:  position{line: 298, col: 1, offset: 8477},
			expr: &actionExpr{
				pos: position{line: 298, col: 20, offset: 8496},
				run: (*parser).callonInlineAttributes1,
				expr: &seqExpr{
					pos: position{line: 298, col: 20, offset: 8496},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 298, col: 20, offset: 8496},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 298, col: 24, offset: 8500},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 298, col: 36, offset: 8512},
								offset: 28,
							},
						},
						&litMatcher{
							pos:        position{line: 298, col: 51, offset: 8527},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "NamedAttributeName",
			pos:  position{line: 302, col: 1, offset: 8567},
			expr: &actionExpr{
				pos: position{line: 302, col: 22, offset: 8588},
				run: (*parser).callonNamedAttributeName1,
				expr: &seqExpr{
					pos: position{line: 302, col: 22, offset: 8588},
					exprs: []any{
						&charClassMatcher{
							pos:        position{line: 302, col: 22, offset: 8588},
							val:        "[A-Za-z0-9_]",
							chars:      []rune{'_'},
							ranges:     []rune{'A', 'Z', 'a', 'z', '0', '9'},
							ignoreCase: false,
							inverted:   false,
						},
						&zeroOrMoreExpr{
							pos: position{line: 302, col: 35, offset: 8601},
							expr: &charClassMatcher{
								pos:        position{line: 302, col: 35, offset: 8601},
								val:        "[A-Za-z0-9_-]",
								chars:      []rune{'_', '-'},
								ranges:     []rune{'A', 'Z', 'a', 'z', '0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
						},
					},
				},
			},
		},
		{
			name: "AttributeReference",
			pos:  position{line: 306, col: 1, offset: 8656},
			expr: &choiceExpr{
				pos: position{line: 306, col: 22, offset: 8677},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 306, col: 22, offset: 8677},
						offset: 54,
					},
					&ruleRefExpr{
						pos:    position{line: 306, col: 48, offset: 8703},
						offset: 278,
					},
				},
			},
		},
		{
			name: "AttributeReferenceValue",
			pos:  position{line: 308, col: 1, offset: 8712},
			expr: &actionExpr{
				pos: position{line: 308, col: 27, offset: 8738},
				run: (*parser).callonAttributeReferenceValue1,
				expr: &seqExpr{
					pos: position{line: 308, col: 27, offset: 8738},
					exprs: []any{
						&notExpr{
							pos: position{line: 308, col: 27, offset: 8738},
							expr: &litMatcher{
								pos:        position{line: 308, col: 28, offset: 8739},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 308, col: 33, offset: 8744},
							val:        "{",
							ignoreCase: false,
							want:       "\"{\"",
						},
						&labeledExpr{
							pos:   position{line: 308, col: 37, offset: 8748},
							label: "name",
							expr: &ruleRefExpr{
								pos:    position{line: 308, col: 42, offset: 8753},
								offset: 23,
							},
						},
						&litMatcher{
							pos:        position{line: 308, col: 61, offset: 8772},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
					},
				},
			},
		},
		{
			name: "BoldText",
			pos:  position{line: 316, col: 1, offset: 8868},
			expr: &choiceExpr{
				pos: position{line: 316, col: 13, offset: 8880},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 316, col: 13, offset: 8880},
						offset: 56,
					},
					&ruleRefExpr{
						pos:    position{line: 316, col: 30, offset: 8897},
						offset: 59,
					},
				},
			},
		},
		{
			name: "SingleBoldText",
			pos:  position{line: 318, col: 1, offset: 8914},
			expr: &actionExpr{
				pos: position{line: 318, col: 18, offset: 8931},
				run: (*parser).callonSingleBoldText1,
				expr: &seqExpr{
					pos: position{line: 318, col: 18, offset: 8931},
					exprs: []any{
						&notExpr{
							pos: position{line: 318, col: 18, offset: 8931},
							expr: &ruleRefExpr{
								pos:    position{line: 318, col: 19, offset: 8932},
								offset: 340,
							},
						},
						&litMatcher{
							pos:        position{line: 318, col: 26, offset: 8939},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
						&andExpr{
							pos: position{line: 318, col: 30, offset: 8943},
							expr: &notExpr{
								pos: position{line: 318, col: 32, offset: 8945},
								expr: &litMatcher{
									pos:        position{line: 318, col: 33, offset: 8946},
									val:        "*",
									ignoreCase: false,
									want:       "\"*\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 318, col: 38, offset: 8951},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 318, col: 45, offset: 8958},
								offset: 57,
							},
						},
						&litMatcher{
							pos:        position{line: 318, col: 66, offset: 8979},
							val:        "*",
							ignoreCase: false,
							want:       "\"*\"",
						},
						&notExpr{
							pos: position{line: 318, col: 70, offset: 8983},
							expr: &litMatcher{
								pos:        position{line: 318, col: 71, offset: 8984},
								val:        "*",
								ignoreCase: false,
								want:       "\"*\"",
							},
						},
						&andExpr{
							pos: position{line: 318, col: 75, offset: 8988},
							expr: &notExpr{
								pos: position{line: 318, col: 77, offset: 8990},
								expr: &ruleRefExpr{
									pos:    position{line: 318, col: 78, offset: 8991},
									offset: 323,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleBoldTextValue",
			pos:  position{line: 322, col: 1, offset: 9036},
			expr: &actionExpr{
				pos: position{line: 322, col: 23, offset: 9058},
				run: (*parser).callonSingleBoldTextValue1,
				expr: &seqExpr{
					pos: position{line: 322, col: 23, offset: 9058},
					exprs: []any{
						&notExpr{
							pos: position{line: 322, col: 23, offset: 9058},
							expr: &ruleRefExpr{
								pos:    position{line: 322, col: 24, offset: 9059},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 322, col: 26, offset: 9061},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 322, col: 32, offset: 9067},
								expr: &actionExpr{
									pos: position{line: 322, col: 33, offset: 9068},
									run: (*parser).callonSingleBoldTextValue7,
									expr: &seqExpr{
										pos: position{line: 322, col: 33, offset: 9068},
										exprs: []any{
											&notExpr{
												pos: position{line: 322, col: 33, offset: 9068},
												expr: &ruleRefExpr{
													pos:    position{line: 322, col: 34, offset: 9069},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 322, col: 36, offset: 9071},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 322, col: 42, offset: 9077},
													expr: &ruleRefExpr{
														pos:    position{line: 322, col: 43, offset: 9078},
														offset: 58,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleBoldTextElement",
			pos:  position{line: 326, col: 1, offset: 9226},
			expr: &seqExpr{
				pos: position{line: 326, col: 25, offset: 9250},
				exprs: []any{
					&notExpr{
						pos: position{line: 326, col: 25, offset: 9250},
						expr: &seqExpr{
							pos: position{line: 326, col: 27, offset: 9252},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 326, col: 27, offset: 9252},
									val:        "*",
									ignoreCase: false,
									want:       "\"*\"",
								},
								&notExpr{
									pos: position{line: 326, col: 31, offset: 9256},
									expr: &litMatcher{
										pos:        position{line: 326, col: 32, offset: 9257},
										val:        "*",
										ignoreCase: false,
										want:       "\"*\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 326, col: 37, offset: 9262},
						offset: 96,
					},
				},
			},
		},
		{
			name: "DoubleBoldText",
			pos:  position{line: 328, col: 1, offset: 9284},
			expr: &actionExpr{
				pos: position{line: 328, col: 18, offset: 9301},
				run: (*parser).callonDoubleBoldText1,
				expr: &seqExpr{
					pos: position{line: 328, col: 18, offset: 9301},
					exprs: []any{
						&notExpr{
							pos: position{line: 328, col: 18, offset: 9301},
							expr: &ruleRefExpr{
								pos:    position{line: 328, col: 19, offset: 9302},
								offset: 341,
							},
						},
						&litMatcher{
							pos:        position{line: 328, col: 32, offset: 9315},
							val:        "**",
							ignoreCase: false,
							want:       "\"**\"",
						},
						&labeledExpr{
							pos:   position{line: 328, col: 37, offset: 9320},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 328, col: 44, offset: 9327},
								offset: 60,
							},
						},
						&litMatcher{
							pos:        position{line: 328, col: 65, offset: 9348},
							val:        "**",
							ignoreCase: false,
							want:       "\"**\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleBoldTextValue",
			pos:  position{line: 332, col: 1, offset: 9385},
			expr: &actionExpr{
				pos: position{line: 332, col: 23, offset: 9407},
				run: (*parser).callonDoubleBoldTextValue1,
				expr: &seqExpr{
					pos: position{line: 332, col: 23, offset: 9407},
					exprs: []any{
						&notExpr{
							pos: position{line: 332, col: 23, offset: 9407},
							expr: &ruleRefExpr{
								pos:    position{line: 332, col: 24, offset: 9408},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 332, col: 26, offset: 9410},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 332, col: 32, offset: 9416},
								expr: &actionExpr{
									pos: position{line: 332, col: 33, offset: 9417},
									run: (*parser).callonDoubleBoldTextValue7,
									expr: &seqExpr{
										pos: position{line: 332, col: 33, offset: 9417},
										exprs: []any{
											&notExpr{
												pos: position{line: 332, col: 33, offset: 9417},
												expr: &ruleRefExpr{
													pos:    position{line: 332, col: 34, offset: 9418},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 332, col: 36, offset: 9420},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 332, col: 42, offset: 9426},
													expr: &ruleRefExpr{
														pos:    position{line: 332, col: 43, offset: 9427},
														offset: 61,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleBoldTextElement",
			pos:  position{line: 336, col: 1, offset: 9587},
			expr: &seqExpr{
				pos: position{line: 336, col: 25, offset: 9611},
				exprs: []any{
					&notExpr{
						pos: position{line: 336, col: 25, offset: 9611},
						expr: &litMatcher{
							pos:        position{line: 336, col: 27, offset: 9613},
							val:        "**",
							ignoreCase: false,
							want:       "\"**\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 336, col: 33, offset: 9619},
						offset: 96,
					},
				},
			},
		},
		{
			name: "ItalicText",
			pos:  position{line: 339, col: 1, offset: 9642},
			expr: &choiceExpr{
				pos: position{line: 339, col: 15, offset: 9656},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 339, col: 15, offset: 9656},
						offset: 63,
					},
					&ruleRefExpr{
						pos:    position{line: 339, col: 34, offset: 9675},
						offset: 66,
					},
				},
			},
		},
		{
			name: "SingleItalicText",
			pos:  position{line: 341, col: 1, offset: 9694},
			expr: &actionExpr{
				pos: position{line: 341, col: 20, offset: 9713},
				run: (*parser).callonSingleItalicText1,
				expr: &seqExpr{
					pos: position{line: 341, col: 20, offset: 9713},
					exprs: []any{
						&notExpr{
							pos: position{line: 341, col: 20, offset: 9713},
							expr: &ruleRefExpr{
								pos:    position{line: 341, col: 21, offset: 9714},
								offset: 340,
							},
						},
						&litMatcher{
							pos:        position{line: 341, col: 28, offset: 9721},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
						&andExpr{
							pos: position{line: 341, col: 32, offset: 9725},
							expr: &notExpr{
								pos: position{line: 341, col: 34, offset: 9727},
								expr: &litMatcher{
									pos:        position{line: 341, col: 35, offset: 9728},
									val:        "_",
									ignoreCase: false,
									want:       "\"_\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 341, col: 40, offset: 9733},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 341, col: 47, offset: 9740},
								offset: 64,
							},
						},
						&litMatcher{
							pos:        position{line: 341, col: 70, offset: 9763},
							val:        "_",
							ignoreCase: false,
							want:       "\"_\"",
						},
						&notExpr{
							pos: position{line: 341, col: 74, offset: 9767},
							expr: &litMatcher{
								pos:        position{line: 341, col: 75, offset: 9768},
								val:        "_",
								ignoreCase: false,
								want:       "\"_\"",
							},
						},
						&andExpr{
							pos: position{line: 341, col: 79, offset: 9772},
							expr: &notExpr{
								pos: position{line: 341, col: 81, offset: 9774},
								expr: &ruleRefExpr{
									pos:    position{line: 341, col: 82, offset: 9775},
									offset: 323,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleItalicTextValue",
			pos:  position{line: 345, col: 1, offset: 9820},
			expr: &actionExpr{
				pos: position{line: 345, col: 25, offset: 9844},
				run: (*parser).callonSingleItalicTextValue1,
				expr: &seqExpr{
					pos: position{line: 345, col: 25, offset: 9844},
					exprs: []any{
						&notExpr{
							pos: position{line: 345, col: 25, offset: 9844},
							expr: &ruleRefExpr{
								pos:    position{line: 345, col: 26, offset: 9845},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 345, col: 28, offset: 9847},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 345, col: 34, offset: 9853},
								expr: &actionExpr{
									pos: position{line: 345, col: 35, offset: 9854},
									run: (*parser).callonSingleItalicTextValue7,
									expr: &seqExpr{
										pos: position{line: 345, col: 35, offset: 9854},
										exprs: []any{
											&notExpr{
												pos: position{line: 345, col: 35, offset: 9854},
												expr: &ruleRefExpr{
													pos:    position{line: 345, col: 36, offset: 9855},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 345, col: 38, offset: 9857},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 345, col: 44, offset: 9863},
													expr: &ruleRefExpr{
														pos:    position{line: 345, col: 45, offset: 9864},
														offset: 65,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleItalicTextElement",
			pos:  position{line: 349, col: 1, offset: 9978},
			expr: &seqExpr{
				pos: position{line: 349, col: 27, offset: 10004},
				exprs: []any{
					&notExpr{
						pos: position{line: 349, col: 27, offset: 10004},
						expr: &seqExpr{
							pos: position{line: 349, col: 29, offset: 10006},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 349, col: 29, offset: 10006},
									val:        "_",
									ignoreCase: false,
									want:       "\"_\"",
								},
								&notExpr{
									pos: position{line: 349, col: 33, offset: 10010},
									expr: &litMatcher{
										pos:        position{line: 349, col: 34, offset: 10011},
										val:        "_",
										ignoreCase: false,
										want:       "\"_\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 349, col: 39, offset: 10016},
						offset: 96,
					},
				},
			},
		},
		{
			name: "DoubleItalicText",
			pos:  position{line: 351, col: 1, offset: 10038},
			expr: &actionExpr{
				pos: position{line: 351, col: 20, offset: 10057},
				run: (*parser).callonDoubleItalicText1,
				expr: &seqExpr{
					pos: position{line: 351, col: 20, offset: 10057},
					exprs: []any{
						&notExpr{
							pos: position{line: 351, col: 20, offset: 10057},
							expr: &ruleRefExpr{
								pos:    position{line: 351, col: 21, offset: 10058},
								offset: 341,
							},
						},
						&litMatcher{
							pos:        position{line: 351, col: 34, offset: 10071},
							val:        "__",
							ignoreCase: false,
							want:       "\"__\"",
						},
						&labeledExpr{
							pos:   position{line: 351, col: 39, offset: 10076},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 351, col: 46, offset: 10083},
								offset: 67,
							},
						},
						&litMatcher{
							pos:        position{line: 351, col: 69, offset: 10106},
							val:        "__",
							ignoreCase: false,
							want:       "\"__\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleItalicTextValue",
			pos:  position{line: 355, col: 1, offset: 10143},
			expr: &actionExpr{
				pos: position{line: 355, col: 25, offset: 10167},
				run: (*parser).callonDoubleItalicTextValue1,
				expr: &seqExpr{
					pos: position{line: 355, col: 25, offset: 10167},
					exprs: []any{
						&notExpr{
							pos: position{line: 355, col: 25, offset: 10167},
							expr: &ruleRefExpr{
								pos:    position{line: 355, col: 26, offset: 10168},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 355, col: 28, offset: 10170},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 355, col: 34, offset: 10176},
								expr: &actionExpr{
									pos: position{line: 355, col: 35, offset: 10177},
									run: (*parser).callonDoubleItalicTextValue7,
									expr: &seqExpr{
										pos: position{line: 355, col: 35, offset: 10177},
										exprs: []any{
											&notExpr{
												pos: position{line: 355, col: 35, offset: 10177},
												expr: &ruleRefExpr{
													pos:    position{line: 355, col: 36, offset: 10178},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 355, col: 38, offset: 10180},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 355, col: 44, offset: 10186},
													expr: &ruleRefExpr{
														pos:    position{line: 355, col: 45, offset: 10187},
														offset: 68,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleItalicTextElement",
			pos:  position{line: 359, col: 1, offset: 10307},
			expr: &seqExpr{
				pos: position{line: 359, col: 27, offset: 10333},
				exprs: []any{
					&notExpr{
						pos: position{line: 359, col: 27, offset: 10333},
						expr: &litMatcher{
							pos:        position{line: 359, col: 29, offset: 10335},
							val:        "__",
							ignoreCase: false,
							want:       "\"__\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 359, col: 35, offset: 10341},
						offset: 96,
					},
				},
			},
		},
		{
			name: "SubscriptText",
			pos:  position{line: 364, col: 1, offset: 10366},
			expr: &actionExpr{
				pos: position{line: 364, col: 17, offset: 10382},
				run: (*parser).callonSubscriptText1,
				expr: &seqExpr{
					pos: position{line: 364, col: 17, offset: 10382},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 364, col: 17, offset: 10382},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
						&labeledExpr{
							pos:   position{line: 364, col: 22, offset: 10387},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 364, col: 29, offset: 10394},
								offset: 70,
							},
						},
						&litMatcher{
							pos:        position{line: 364, col: 49, offset: 10414},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
					},
				},
			},
		},
		{
			name: "SubscriptTextValue",
			pos:  position{line: 368, col: 1, offset: 10449},
			expr: &actionExpr{
				pos: position{line: 368, col: 22, offset: 10470},
				run: (*parser).callonSubscriptTextValue1,
				expr: &seqExpr{
					pos: position{line: 368, col: 22, offset: 10470},
					exprs: []any{
						&notExpr{
							pos: position{line: 368, col: 22, offset: 10470},
							expr: &ruleRefExpr{
								pos:    position{line: 368, col: 23, offset: 10471},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 368, col: 25, offset: 10473},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 368, col: 31, offset: 10479},
								expr: &actionExpr{
									pos: position{line: 368, col: 32, offset: 10480},
									run: (*parser).callonSubscriptTextValue7,
									expr: &seqExpr{
										pos: position{line: 368, col: 32, offset: 10480},
										exprs: []any{
											&notExpr{
												pos: position{line: 368, col: 32, offset: 10480},
												expr: &ruleRefExpr{
													pos:    position{line: 368, col: 33, offset: 10481},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 368, col: 35, offset: 10483},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 368, col: 41, offset: 10489},
													expr: &ruleRefExpr{
														pos:    position{line: 368, col: 42, offset: 10490},
														offset: 71,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SubscriptTextElement",
			pos:  position{line: 372, col: 1, offset: 10647},
			expr: &seqExpr{
				pos: position{line: 372, col: 24, offset: 10670},
				exprs: []any{
					&notExpr{
						pos: position{line: 372, col: 24, offset: 10670},
						expr: &litMatcher{
							pos:        position{line: 372, col: 26, offset: 10672},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 372, col: 32, offset: 10678},
						offset: 96,
					},
				},
			},
		},
		{
			name: "EscapedSubscript",
			pos:  position{line: 374, col: 1, offset: 10702},
			expr: &actionExpr{
				pos: position{line: 374, col: 20, offset: 10721},
				run: (*parser).callonEscapedSubscript1,
				expr: &seqExpr{
					pos: position{line: 374, col: 21, offset: 10722},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 374, col: 21, offset: 10722},
							offset: 340,
						},
						&litMatcher{
							pos:        position{line: 374, col: 28, offset: 10729},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
						&ruleRefExpr{
							pos:    position{line: 374, col: 32, offset: 10733},
							offset: 70,
						},
						&litMatcher{
							pos:        position{line: 374, col: 51, offset: 10752},
							val:        "~",
							ignoreCase: false,
							want:       "\"~\"",
						},
					},
				},
			},
		},
		{
			name: "SuperscriptText",
			pos:  position{line: 380, col: 1, offset: 10815},
			expr: &actionExpr{
				pos: position{line: 380, col: 19, offset: 10833},
				run: (*parser).callonSuperscriptText1,
				expr: &seqExpr{
					pos: position{line: 380, col: 19, offset: 10833},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 380, col: 19, offset: 10833},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
						&labeledExpr{
							pos:   position{line: 380, col: 24, offset: 10838},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 380, col: 31, offset: 10845},
								offset: 74,
							},
						},
						&litMatcher{
							pos:        position{line: 380, col: 53, offset: 10867},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
					},
				},
			},
		},
		{
			name: "SuperscriptTextValue",
			pos:  position{line: 384, col: 1, offset: 10902},
			expr: &actionExpr{
				pos: position{line: 384, col: 24, offset: 10925},
				run: (*parser).callonSuperscriptTextValue1,
				expr: &seqExpr{
					pos: position{line: 384, col: 24, offset: 10925},
					exprs: []any{
						&notExpr{
							pos: position{line: 384, col: 24, offset: 10925},
							expr: &ruleRefExpr{
								pos:    position{line: 384, col: 25, offset: 10926},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 384, col: 27, offset: 10928},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 384, col: 33, offset: 10934},
								expr: &actionExpr{
									pos: position{line: 384, col: 34, offset: 10935},
									run: (*parser).callonSuperscriptTextValue7,
									expr: &seqExpr{
										pos: position{line: 384, col: 34, offset: 10935},
										exprs: []any{
											&notExpr{
												pos: position{line: 384, col: 34, offset: 10935},
												expr: &ruleRefExpr{
													pos:    position{line: 384, col: 35, offset: 10936},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 384, col: 37, offset: 10938},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 384, col: 43, offset: 10944},
													expr: &ruleRefExpr{
														pos:    position{line: 384, col: 44, offset: 10945},
														offset: 75,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SuperscriptTextElement",
			pos:  position{line: 388, col: 1, offset: 11108},
			expr: &seqExpr{
				pos: position{line: 388, col: 26, offset: 11133},
				exprs: []any{
					&notExpr{
						pos: position{line: 388, col: 26, offset: 11133},
						expr: &litMatcher{
							pos:        position{line: 388, col: 28, offset: 11135},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 388, col: 34, offset: 11141},
						offset: 96,
					},
				},
			},
		},
		{
			name: "EscapedSuperscript",
			pos:  position{line: 390, col: 1, offset: 11165},
			expr: &actionExpr{
				pos: position{line: 390, col: 22, offset: 11186},
				run: (*parser).callonEscapedSuperscript1,
				expr: &seqExpr{
					pos: position{line: 390, col: 23, offset: 11187},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 390, col: 23, offset: 11187},
							offset: 340,
						},
						&litMatcher{
							pos:        position{line: 390, col: 30, offset: 11194},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
						&ruleRefExpr{
							pos:    position{line: 390, col: 34, offset: 11198},
							offset: 74,
						},
						&litMatcher{
							pos:        position{line: 390, col: 55, offset: 11219},
							val:        "^",
							ignoreCase: false,
							want:       "\"^\"",
						},
					},
				},
			},
		},
		{
			name: "MonospaceText",
			pos:  position{line: 395, col: 1, offset: 11281},
			expr: &choiceExpr{
				pos: position{line: 395, col: 18, offset: 11298},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 395, col: 18, offset: 11298},
						offset: 78,
					},
					&ruleRefExpr{
						pos:    position{line: 395, col: 40, offset: 11320},
						offset: 81,
					},
				},
			},
		},
		{
			name: "SingleMonospaceText",
			pos:  position{line: 397, col: 1, offset: 11342},
			expr: &actionExpr{
				pos: position{line: 397, col: 22, offset: 11363},
				run: (*parser).callonSingleMonospaceText1,
				expr: &seqExpr{
					pos: position{line: 397, col: 22, offset: 11363},
					exprs: []any{
						&notExpr{
							pos: position{line: 397, col: 22, offset: 11363},
							expr: &ruleRefExpr{
								pos:    position{line: 397, col: 23, offset: 11364},
								offset: 340,
							},
						},
						&litMatcher{
							pos:        position{line: 397, col: 30, offset: 11371},
							val:        "`",
							ignoreCase: false,
							want:       "\"`\"",
						},
						&andExpr{
							pos: position{line: 397, col: 34, offset: 11375},
							expr: &notExpr{
								pos: position{line: 397, col: 36, offset: 11377},
								expr: &litMatcher{
									pos:        position{line: 397, col: 37, offset: 11378},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 397, col: 42, offset: 11383},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 397, col: 49, offset: 11390},
								offset: 79,
							},
						},
						&litMatcher{
							pos:        position{line: 397, col: 75, offset: 11416},
							val:        "`",
							ignoreCase: false,
							want:       "\"`\"",
						},
						&notExpr{
							pos: position{line: 397, col: 79, offset: 11420},
							expr: &litMatcher{
								pos:        position{line: 397, col: 80, offset: 11421},
								val:        "`",
								ignoreCase: false,
								want:       "\"`\"",
							},
						},
						&andExpr{
							pos: position{line: 397, col: 84, offset: 11425},
							expr: &notExpr{
								pos: position{line: 397, col: 86, offset: 11427},
								expr: &ruleRefExpr{
									pos:    position{line: 397, col: 87, offset: 11428},
									offset: 323,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMonospaceTextValue",
			pos:  position{line: 401, col: 1, offset: 11473},
			expr: &actionExpr{
				pos: position{line: 401, col: 28, offset: 11500},
				run: (*parser).callonSingleMonospaceTextValue1,
				expr: &seqExpr{
					pos: position{line: 401, col: 28, offset: 11500},
					exprs: []any{
						&notExpr{
							pos: position{line: 401, col: 28, offset: 11500},
							expr: &ruleRefExpr{
								pos:    position{line: 401, col: 29, offset: 11501},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 401, col: 31, offset: 11503},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 401, col: 37, offset: 11509},
								expr: &actionExpr{
									pos: position{line: 401, col: 38, offset: 11510},
									run: (*parser).callonSingleMonospaceTextValue7,
									expr: &seqExpr{
										pos: position{line: 401, col: 38, offset: 11510},
										exprs: []any{
											&notExpr{
												pos: position{line: 401, col: 38, offset: 11510},
												expr: &ruleRefExpr{
													pos:    position{line: 401, col: 39, offset: 11511},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 401, col: 41, offset: 11513},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 401, col: 47, offset: 11519},
													expr: &ruleRefExpr{
														pos:    position{line: 401, col: 48, offset: 11520},
														offset: 80,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMonospaceTextElement",
			pos:  position{line: 405, col: 1, offset: 11640},
			expr: &seqExpr{
				pos: position{line: 405, col: 30, offset: 11669},
				exprs: []any{
					&notExpr{
						pos: position{line: 405, col: 30, offset: 11669},
						expr: &seqExpr{
							pos: position{line: 405, col: 32, offset: 11671},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 405, col: 32, offset: 11671},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
								&notExpr{
									pos: position{line: 405, col: 36, offset: 11675},
									expr: &litMatcher{
										pos:        position{line: 405, col: 37, offset: 11676},
										val:        "`",
										ignoreCase: false,
										want:       "\"`\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 405, col: 42, offset: 11681},
						offset: 96,
					},
				},
			},
		},
		{
			name: "DoubleMonospaceText",
			pos:  position{line: 407, col: 1, offset: 11703},
			expr: &actionExpr{
				pos: position{line: 407, col: 22, offset: 11724},
				run: (*parser).callonDoubleMonospaceText1,
				expr: &seqExpr{
					pos: position{line: 407, col: 22, offset: 11724},
					exprs: []any{
						&notExpr{
							pos: position{line: 407, col: 22, offset: 11724},
							expr: &ruleRefExpr{
								pos:    position{line: 407, col: 23, offset: 11725},
								offset: 341,
							},
						},
						&litMatcher{
							pos:        position{line: 407, col: 36, offset: 11738},
							val:        "``",
							ignoreCase: false,
							want:       "\"``\"",
						},
						&andExpr{
							pos: position{line: 407, col: 41, offset: 11743},
							expr: &notExpr{
								pos: position{line: 407, col: 43, offset: 11745},
								expr: &litMatcher{
									pos:        position{line: 407, col: 44, offset: 11746},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 407, col: 49, offset: 11751},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 407, col: 56, offset: 11758},
								offset: 82,
							},
						},
						&litMatcher{
							pos:        position{line: 407, col: 82, offset: 11784},
							val:        "``",
							ignoreCase: false,
							want:       "\"``\"",
						},
						&andExpr{
							pos: position{line: 407, col: 87, offset: 11789},
							expr: &notExpr{
								pos: position{line: 407, col: 89, offset: 11791},
								expr: &litMatcher{
									pos:        position{line: 407, col: 90, offset: 11792},
									val:        "`",
									ignoreCase: false,
									want:       "\"`\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMonospaceTextValue",
			pos:  position{line: 411, col: 1, offset: 11827},
			expr: &actionExpr{
				pos: position{line: 411, col: 28, offset: 11854},
				run: (*parser).callonDoubleMonospaceTextValue1,
				expr: &seqExpr{
					pos: position{line: 411, col: 28, offset: 11854},
					exprs: []any{
						&notExpr{
							pos: position{line: 411, col: 28, offset: 11854},
							expr: &ruleRefExpr{
								pos:    position{line: 411, col: 29, offset: 11855},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 411, col: 31, offset: 11857},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 411, col: 37, offset: 11863},
								expr: &actionExpr{
									pos: position{line: 411, col: 38, offset: 11864},
									run: (*parser).callonDoubleMonospaceTextValue7,
									expr: &seqExpr{
										pos: position{line: 411, col: 38, offset: 11864},
										exprs: []any{
											&notExpr{
												pos: position{line: 411, col: 38, offset: 11864},
												expr: &ruleRefExpr{
													pos:    position{line: 411, col: 39, offset: 11865},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 411, col: 41, offset: 11867},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 411, col: 47, offset: 11873},
													expr: &ruleRefExpr{
														pos:    position{line: 411, col: 48, offset: 11874},
														offset: 83,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMonospaceTextElement",
			pos:  position{line: 415, col: 1, offset: 12000},
			expr: &seqExpr{
				pos: position{line: 415, col: 30, offset: 12029},
				exprs: []any{
					&notExpr{
						pos: position{line: 415, col: 30, offset: 12029},
						expr: &litMatcher{
							pos:        position{line: 415, col: 32, offset: 12031},
							val:        "``",
							ignoreCase: false,
							want:       "\"``\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 415, col: 38, offset: 12037},
						offset: 96,
					},
				},
			},
		},
		{
			name: "Anchor",
			pos:  position{line: 418, col: 1, offset: 12060},
			expr: &actionExpr{
				pos: position{line: 418, col: 10, offset: 12069},
				run: (*parser).callonAnchor1,
				expr: &seqExpr{
					pos: position{line: 418, col: 10, offset: 12069},
					exprs: []any{
						&notExpr{
							pos: position{line: 418, col: 10, offset: 12069},
							expr: &litMatcher{
								pos:        position{line: 418, col: 11, offset: 12070},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 418, col: 16, offset: 12075},
							val:        "[[",
							ignoreCase: false,
							want:       "\"[[\"",
						},
						&labeledExpr{
							pos:   position{line: 418, col: 21, offset: 12080},
							label: "id",
							expr: &ruleRefExpr{
								pos:    position{line: 418, col: 25, offset: 12084},
								offset: 243,
							},
						},
						&labeledExpr{
							pos:   position{line: 418, col: 43, offset: 12102},
							label: "label",
							expr: &zeroOrOneExpr{
								pos: position{line: 418, col: 49, offset: 12108},
								expr: &actionExpr{
									pos: position{line: 418, col: 50, offset: 12109},
									run: (*parser).callonAnchor10,
									expr: &seqExpr{
										pos: position{line: 418, col: 50, offset: 12109},
										exprs: []any{
											&ruleRefExpr{
												pos:    position{line: 418, col: 50, offset: 12109},
												offset: 334,
											},
											&litMatcher{
												pos:        position{line: 418, col: 60, offset: 12119},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&labeledExpr{
												pos:   position{line: 418, col: 64, offset: 12123},
												label: "label",
												expr: &ruleRefExpr{
													pos:    position{line: 418, col: 71, offset: 12130},
													offset: 86,
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 418, col: 107, offset: 12166},
							val:        "]]",
							ignoreCase: false,
							want:       "\"]]\"",
						},
					},
				},
			},
		},
		{
			name: "AnchorAttribute",
			pos:  position{line: 426, col: 1, offset: 12343},
			expr: &actionExpr{
				pos: position{line: 426, col: 19, offset: 12361},
				run: (*parser).callonAnchorAttribute1,
				expr: &seqExpr{
					pos: position{line: 426, col: 19, offset: 12361},
					exprs: []any{
						&notExpr{
							pos: position{line: 426, col: 19, offset: 12361},
							expr: &litMatcher{
								pos:        position{line: 426, col: 20, offset: 12362},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 426, col: 25, offset: 12367},
							val:        "[[",
							ignoreCase: false,
							want:       "\"[[\"",
						},
						&labeledExpr{
							pos:   position{line: 426, col: 30, offset: 12372},
							label: "id",
							expr: &ruleRefExpr{
								pos:    position{line: 426, col: 34, offset: 12376},
								offset: 243,
							},
						},
						&labeledExpr{
							pos:   position{line: 426, col: 52, offset: 12394},
							label: "label",
							expr: &zeroOrOneExpr{
								pos: position{line: 426, col: 58, offset: 12400},
								expr: &actionExpr{
									pos: position{line: 426, col: 59, offset: 12401},
									run: (*parser).callonAnchorAttribute10,
									expr: &seqExpr{
										pos: position{line: 426, col: 59, offset: 12401},
										exprs: []any{
											&ruleRefExpr{
												pos:    position{line: 426, col: 59, offset: 12401},
												offset: 334,
											},
											&litMatcher{
												pos:        position{line: 426, col: 69, offset: 12411},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&labeledExpr{
												pos:   position{line: 426, col: 73, offset: 12415},
												label: "label",
												expr: &ruleRefExpr{
													pos:    position{line: 426, col: 80, offset: 12422},
													offset: 86,
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 426, col: 116, offset: 12458},
							val:        "]]",
							ignoreCase: false,
							want:       "\"]]\"",
						},
					},
				},
			},
		},
		{
			name: "AnchorLabel",
			pos:  position{line: 434, col: 1, offset: 12658},
			expr: &oneOrMoreExpr{
				pos: position{line: 434, col: 15, offset: 12672},
				expr: &seqExpr{
					pos: position{line: 434, col: 17, offset: 12674},
					exprs: []any{
						&notExpr{
							pos: position{line: 434, col: 17, offset: 12674},
							expr: &litMatcher{
								pos:        position{line: 434, col: 18, offset: 12675},
								val:        "]]",
								ignoreCase: false,
								want:       "\"]]\"",
							},
						},
						&choiceExpr{
							pos: position{line: 435, col: 6, offset: 12685},
							alternatives: []any{
								&oneOrMoreExpr{
									pos: position{line: 435, col: 6, offset: 12685},
									expr: &charClassMatcher{
										pos:        position{line: 435, col: 6, offset: 12685},
										val:        "[^\\r\\n{\\]]",
										chars:      []rune{'\r', '\n', '{', ']'},
										ignoreCase: false,
										inverted:   true,
									},
								},
								&ruleRefExpr{
									pos:    position{line: 436, col: 7, offset: 12704},
									offset: 53,
								},
								&litMatcher{
									pos:        position{line: 437, col: 7, offset: 12730},
									val:        "{",
									ignoreCase: false,
									want:       "\"{\"",
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Admonition",
			pos:  position{line: 443, col: 1, offset: 12743},
			expr: &choiceExpr{
				pos: position{line: 443, col: 14, offset: 12756},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 443, col: 14, offset: 12756},
						run: (*parser).callonAdmonition2,
						expr: &seqExpr{
							pos: position{line: 443, col: 14, offset: 12756},
							exprs: []any{
								&ruleRefExpr{
									pos:    position{line: 443, col: 14, offset: 12756},
									offset: 327,
								},
								&litMatcher{
									pos:        position{line: 444, col: 5, offset: 12777},
									val:        "NOTE: ",
									ignoreCase: false,
									want:       "\"NOTE: \"",
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 445, col: 7, offset: 12860},
						run: (*parser).callonAdmonition6,
						expr: &litMatcher{
							pos:        position{line: 445, col: 7, offset: 12860},
							val:        "TIP: ",
							ignoreCase: false,
							want:       "\"TIP: \"",
						},
					},
					&actionExpr{
						pos: position{line: 446, col: 7, offset: 12941},
						run: (*parser).callonAdmonition8,
						expr: &litMatcher{
							pos:        position{line: 446, col: 7, offset: 12941},
							val:        "IMPORTANT: ",
							ignoreCase: false,
							want:       "\"IMPORTANT: \"",
						},
					},
					&actionExpr{
						pos: position{line: 447, col: 7, offset: 13034},
						run: (*parser).callonAdmonition10,
						expr: &litMatcher{
							pos:        position{line: 447, col: 7, offset: 13034},
							val:        "CAUTON: ",
							ignoreCase: false,
							want:       "\"CAUTON: \"",
						},
					},
					&actionExpr{
						pos: position{line: 448, col: 7, offset: 13122},
						run: (*parser).callonAdmonition12,
						expr: &litMatcher{
							pos:        position{line: 448, col: 7, offset: 13122},
							val:        "WARNING: ",
							ignoreCase: false,
							want:       "\"WARNING: \"",
						},
					},
				},
			},
		},
		{
			name: "InlineBlock",
			pos:  position{line: 451, col: 1, offset: 13210},
			expr: &actionExpr{
				pos: position{line: 451, col: 15, offset: 13224},
				run: (*parser).callonInlineBlock1,
				expr: &seqExpr{
					pos: position{line: 451, col: 15, offset: 13224},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 451, col: 15, offset: 13224},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 451, col: 24, offset: 13233},
								offset: 89,
							},
						},
						&labeledExpr{
							pos:   position{line: 451, col: 40, offset: 13249},
							label: "eol",
							expr: &ruleRefExpr{
								pos:    position{line: 451, col: 44, offset: 13253},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "InlineElements",
			pos:  position{line: 459, col: 1, offset: 13416},
			expr: &actionExpr{
				pos: position{line: 459, col: 18, offset: 13433},
				run: (*parser).callonInlineElements1,
				expr: &labeledExpr{
					pos:   position{line: 459, col: 18, offset: 13433},
					label: "content",
					expr: &oneOrMoreExpr{
						pos: position{line: 459, col: 26, offset: 13441},
						expr: &ruleRefExpr{
							pos:    position{line: 459, col: 27, offset: 13442},
							offset: 90,
						},
					},
				},
			},
		},
		{
			name: "InlineElement",
			pos:  position{line: 463, col: 1, offset: 13505},
			expr: &choiceExpr{
				pos: position{line: 464, col: 5, offset: 13527},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 464, col: 5, offset: 13527},
						offset: 87,
					},
					&ruleRefExpr{
						pos:    position{line: 465, col: 5, offset: 13544},
						offset: 283,
					},
					&ruleRefExpr{
						pos:    position{line: 466, col: 5, offset: 13568},
						offset: 95,
					},
					&ruleRefExpr{
						pos:    position{line: 467, col: 5, offset: 13588},
						offset: 101,
					},
					&ruleRefExpr{
						pos:    position{line: 468, col: 5, offset: 13600},
						offset: 99,
					},
					&ruleRefExpr{
						pos:    position{line: 469, col: 5, offset: 13619},
						offset: 108,
					},
					&ruleRefExpr{
						pos:    position{line: 470, col: 5, offset: 13630},
						offset: 84,
					},
					&ruleRefExpr{
						pos:    position{line: 471, col: 5, offset: 13644},
						offset: 238,
					},
					&ruleRefExpr{
						pos:    position{line: 472, col: 5, offset: 13666},
						offset: 53,
					},
					&ruleRefExpr{
						pos:    position{line: 473, col: 5, offset: 13691},
						offset: 311,
					},
					&ruleRefExpr{
						pos:    position{line: 474, col: 5, offset: 13707},
						offset: 91,
					},
					&ruleRefExpr{
						pos:    position{line: 475, col: 5, offset: 13729},
						offset: 336,
					},
				},
			},
		},
		{
			name: "NakedInlineText",
			pos:  position{line: 478, col: 1, offset: 13760},
			expr: &actionExpr{
				pos: position{line: 478, col: 19, offset: 13778},
				run: (*parser).callonNakedInlineText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 478, col: 19, offset: 13778},
					expr: &seqExpr{
						pos: position{line: 478, col: 20, offset: 13779},
						exprs: []any{
							&notExpr{
								pos: position{line: 478, col: 20, offset: 13779},
								expr: &ruleRefExpr{
									pos:    position{line: 478, col: 21, offset: 13780},
									offset: 162,
								},
							},
							&notExpr{
								pos: position{line: 478, col: 31, offset: 13790},
								expr: &ruleRefExpr{
									pos:    position{line: 478, col: 32, offset: 13791},
									offset: 109,
								},
							},
							&notExpr{
								pos: position{line: 478, col: 42, offset: 13801},
								expr: &ruleRefExpr{
									pos:    position{line: 478, col: 43, offset: 13802},
									offset: 100,
								},
							},
							&notExpr{
								pos: position{line: 478, col: 64, offset: 13823},
								expr: &ruleRefExpr{
									pos:    position{line: 478, col: 65, offset: 13824},
									offset: 245,
								},
							},
							&charClassMatcher{
								pos:        position{line: 478, col: 90, offset: 13849},
								val:        "[A-Za-z ]",
								chars:      []rune{' '},
								ranges:     []rune{'A', 'Z', 'a', 'z'},
								ignoreCase: false,
								inverted:   false,
							},
						},
					},
				},
			},
		},
		{
			name: "Footnote",
			pos:  position{line: 483, col: 1, offset: 13923},
			expr: &actionExpr{
				pos: position{line: 483, col: 12, offset: 13934},
				run: (*parser).callonFootnote1,
				expr: &seqExpr{
					pos: position{line: 483, col: 12, offset: 13934},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 483, col: 12, offset: 13934},
							val:        "footnote:",
							ignoreCase: false,
							want:       "\"footnote:\"",
						},
						&labeledExpr{
							pos:   position{line: 483, col: 24, offset: 13946},
							label: "id",
							expr: &zeroOrOneExpr{
								pos: position{line: 483, col: 27, offset: 13949},
								expr: &ruleRefExpr{
									pos:    position{line: 483, col: 28, offset: 13950},
									offset: 93,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 483, col: 41, offset: 13963},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 483, col: 45, offset: 13967},
							label: "value",
							expr: &zeroOrMoreExpr{
								pos: position{line: 483, col: 51, offset: 13973},
								expr: &ruleRefExpr{
									pos:    position{line: 483, col: 52, offset: 13974},
									offset: 94,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 483, col: 68, offset: 13990},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "FootnoteId",
			pos:  position{line: 487, col: 1, offset: 14064},
			expr: &actionExpr{
				pos: position{line: 487, col: 14, offset: 14077},
				run: (*parser).callonFootnoteId1,
				expr: &oneOrMoreExpr{
					pos: position{line: 487, col: 14, offset: 14077},
					expr: &ruleRefExpr{
						pos:    position{line: 487, col: 14, offset: 14077},
						offset: 323,
					},
				},
			},
		},
		{
			name: "FootnoteValue",
			pos:  position{line: 491, col: 1, offset: 14127},
			expr: &seqExpr{
				pos: position{line: 491, col: 17, offset: 14143},
				exprs: []any{
					&notExpr{
						pos: position{line: 491, col: 17, offset: 14143},
						expr: &litMatcher{
							pos:        position{line: 491, col: 18, offset: 14144},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
					&choiceExpr{
						pos: position{line: 491, col: 24, offset: 14150},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 491, col: 24, offset: 14150},
								offset: 331,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 37, offset: 14163},
								offset: 338,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 42, offset: 14168},
								offset: 309,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 55, offset: 14181},
								offset: 212,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 63, offset: 14189},
								offset: 310,
							},
							&ruleRefExpr{
								pos: position{line: 491, col: 77, offset: 14203},
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 85, offset: 14211},
								offset: 311,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 97, offset: 14223},
								offset: 53,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 118, offset: 14244},
								offset: 307,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 137, offset: 14263},
								offset: 315,
							},
							&ruleRefExpr{
								pos:    position{line: 491, col: 149, offset: 14275},
								offset: 336,
							},
						},
					},
				},
			},
		},
		{
			name: "FormattedText",
			pos:  position{line: 495, col: 1, offset: 14301},
			expr: &actionExpr{
				pos: position{line: 495, col: 17, offset: 14317},
				run: (*parser).callonFormattedText1,
				expr: &seqExpr{
					pos: position{line: 495, col: 17, offset: 14317},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 495, col: 17, offset: 14317},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 495, col: 28, offset: 14328},
								expr: &ruleRefExpr{
									pos:    position{line: 495, col: 29, offset: 14329},
									offset: 31,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 495, col: 52, offset: 14352},
							label: "text",
							expr: &choiceExpr{
								pos: position{line: 496, col: 5, offset: 14363},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 496, col: 5, offset: 14363},
										offset: 55,
									},
									&ruleRefExpr{
										pos:    position{line: 497, col: 7, offset: 14379},
										offset: 62,
									},
									&ruleRefExpr{
										pos:    position{line: 498, col: 7, offset: 14397},
										offset: 77,
									},
									&ruleRefExpr{
										pos:    position{line: 499, col: 7, offset: 14418},
										offset: 181,
									},
									&ruleRefExpr{
										pos:    position{line: 500, col: 7, offset: 14435},
										offset: 73,
									},
									&ruleRefExpr{
										pos:    position{line: 501, col: 7, offset: 14457},
										offset: 69,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "FormattedTextElement",
			pos:  position{line: 506, col: 1, offset: 14606},
			expr: &choiceExpr{
				pos: position{line: 507, col: 5, offset: 14635},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 507, col: 5, offset: 14635},
						offset: 331,
					},
					&ruleRefExpr{
						pos:    position{line: 508, col: 5, offset: 14653},
						offset: 338,
					},
					&ruleRefExpr{
						pos:    position{line: 509, col: 5, offset: 14663},
						offset: 309,
					},
					&ruleRefExpr{
						pos:    position{line: 510, col: 5, offset: 14681},
						offset: 310,
					},
					&ruleRefExpr{
						pos:    position{line: 511, col: 5, offset: 14700},
						offset: 53,
					},
					&ruleRefExpr{
						pos:    position{line: 512, col: 5, offset: 14726},
						offset: 95,
					},
					&ruleRefExpr{
						pos:    position{line: 513, col: 5, offset: 14747},
						offset: 101,
					},
					&ruleRefExpr{
						pos:    position{line: 514, col: 5, offset: 14759},
						offset: 99,
					},
					&ruleRefExpr{
						pos:    position{line: 515, col: 5, offset: 14778},
						offset: 108,
					},
					&ruleRefExpr{
						pos:    position{line: 516, col: 5, offset: 14789},
						offset: 84,
					},
					&ruleRefExpr{
						pos:    position{line: 517, col: 5, offset: 14803},
						offset: 238,
					},
					&ruleRefExpr{
						pos:    position{line: 518, col: 5, offset: 14825},
						offset: 307,
					},
					&ruleRefExpr{
						pos:    position{line: 519, col: 5, offset: 14849},
						offset: 336,
					},
				},
			},
		},
		{
			name: "FormatAttributes",
			pos:  position{line: 522, col: 1, offset: 14873},
			expr: &actionExpr{
				pos: position{line: 522, col: 20, offset: 14892},
				run: (*parser).callonFormatAttributes1,
				expr: &seqExpr{
					pos: position{line: 522, col: 20, offset: 14892},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 522, col: 20, offset: 14892},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 522, col: 24, offset: 14896},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 522, col: 36, offset: 14908},
								offset: 32,
							},
						},
						&litMatcher{
							pos:        position{line: 522, col: 56, offset: 14928},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
				},
			},
		},
		{
			name: "BlockImage",
			pos:  position{line: 527, col: 1, offset: 14969},
			expr: &actionExpr{
				pos: position{line: 527, col: 14, offset: 14982},
				run: (*parser).callonBlockImage1,
				expr: &seqExpr{
					pos: position{line: 527, col: 14, offset: 14982},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 527, col: 14, offset: 14982},
							val:        "image::",
							ignoreCase: false,
							want:       "\"image::\"",
						},
						&labeledExpr{
							pos:   position{line: 527, col: 24, offset: 14992},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 527, col: 30, offset: 14998},
								offset: 165,
							},
						},
						&labeledExpr{
							pos:   position{line: 527, col: 36, offset: 15004},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 527, col: 48, offset: 15016},
								offset: 51,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 527, col: 66, offset: 15034},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "InlineImage",
			pos:  position{line: 531, col: 1, offset: 15171},
			expr: &actionExpr{
				pos: position{line: 531, col: 15, offset: 15185},
				run: (*parser).callonInlineImage1,
				expr: &seqExpr{
					pos: position{line: 531, col: 15, offset: 15185},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 531, col: 15, offset: 15185},
							offset: 100,
						},
						&notExpr{
							pos: position{line: 531, col: 36, offset: 15206},
							expr: &litMatcher{
								pos:        position{line: 531, col: 37, offset: 15207},
								val:        ":",
								ignoreCase: false,
								want:       "\":\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 531, col: 41, offset: 15211},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 531, col: 47, offset: 15217},
								offset: 165,
							},
						},
						&labeledExpr{
							pos:   position{line: 531, col: 53, offset: 15223},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 531, col: 65, offset: 15235},
								offset: 51,
							},
						},
					},
				},
			},
		},
		{
			name: "InlineImageDelimiter",
			pos:  position{line: 535, col: 1, offset: 15382},
			expr: &litMatcher{
				pos:        position{line: 535, col: 24, offset: 15405},
				val:        "image:",
				ignoreCase: false,
				want:       "\"image:\"",
			},
		},
		{
			name: "Icon",
			pos:  position{line: 539, col: 1, offset: 15417},
			expr: &actionExpr{
				pos: position{line: 539, col: 8, offset: 15424},
				run: (*parser).callonIcon1,
				expr: &seqExpr{
					pos: position{line: 539, col: 8, offset: 15424},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 539, col: 8, offset: 15424},
							val:        "icon:",
							ignoreCase: false,
							want:       "\"icon:\"",
						},
						&labeledExpr{
							pos:   position{line: 539, col: 16, offset: 15432},
							label: "path",
							expr: &actionExpr{
								pos: position{line: 539, col: 22, offset: 15438},
								run: (*parser).callonIcon5,
								expr: &oneOrMoreExpr{
									pos: position{line: 539, col: 22, offset: 15438},
									expr: &choiceExpr{
										pos: position{line: 539, col: 23, offset: 15439},
										alternatives: []any{
											&ruleRefExpr{
												pos:    position{line: 539, col: 23, offset: 15439},
												offset: 323,
											},
											&litMatcher{
												pos:        position{line: 539, col: 38, offset: 15454},
												val:        "_",
												ignoreCase: false,
												want:       "\"_\"",
											},
											&litMatcher{
												pos:        position{line: 539, col: 44, offset: 15460},
												val:        "-",
												ignoreCase: false,
												want:       "\"-\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 539, col: 81, offset: 15497},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 539, col: 93, offset: 15509},
								offset: 51,
							},
						},
					},
				},
			},
		},
		{
			name: "FileInclude",
			pos:  position{line: 544, col: 1, offset: 15631},
			expr: &actionExpr{
				pos: position{line: 544, col: 15, offset: 15645},
				run: (*parser).callonFileInclude1,
				expr: &seqExpr{
					pos: position{line: 544, col: 15, offset: 15645},
					exprs: []any{
						&notExpr{
							pos: position{line: 544, col: 15, offset: 15645},
							expr: &litMatcher{
								pos:        position{line: 544, col: 16, offset: 15646},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 544, col: 21, offset: 15651},
							val:        "include::",
							ignoreCase: false,
							want:       "\"include::\"",
						},
						&labeledExpr{
							pos:   position{line: 544, col: 33, offset: 15663},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 544, col: 39, offset: 15669},
								offset: 103,
							},
						},
						&labeledExpr{
							pos:   position{line: 544, col: 56, offset: 15686},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 544, col: 68, offset: 15698},
								offset: 51,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 544, col: 86, offset: 15716},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 544, col: 96, offset: 15726},
							expr: &ruleRefExpr{
								pos:    position{line: 544, col: 97, offset: 15727},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "FileIncludePath",
			pos:  position{line: 549, col: 1, offset: 15884},
			expr: &actionExpr{
				pos: position{line: 549, col: 19, offset: 15902},
				run: (*parser).callonFileIncludePath1,
				expr: &seqExpr{
					pos: position{line: 549, col: 19, offset: 15902},
					exprs: []any{
						&notExpr{
							pos: position{line: 549, col: 19, offset: 15902},
							expr: &ruleRefExpr{
								pos:    position{line: 549, col: 20, offset: 15903},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 549, col: 22, offset: 15905},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 549, col: 27, offset: 15910},
								offset: 165,
							},
						},
					},
				},
			},
		},
		{
			name: "IncludeParse",
			pos:  position{line: 554, col: 1, offset: 15942},
			expr: &actionExpr{
				pos: position{line: 554, col: 16, offset: 15957},
				run: (*parser).callonIncludeParse1,
				expr: &seqExpr{
					pos: position{line: 554, col: 16, offset: 15957},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 554, col: 16, offset: 15957},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 554, col: 24, offset: 15965},
								expr: &ruleRefExpr{
									pos:    position{line: 554, col: 25, offset: 15966},
									offset: 105,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 554, col: 47, offset: 15988},
							offset: 324,
						},
					},
				},
			},
		},
		{
			name: "IncludeParseElement",
			pos:  position{line: 558, col: 1, offset: 16045},
			expr: &actionExpr{
				pos: position{line: 558, col: 23, offset: 16067},
				run: (*parser).callonIncludeParseElement1,
				expr: &seqExpr{
					pos: position{line: 558, col: 23, offset: 16067},
					exprs: []any{
						&notExpr{
							pos: position{line: 558, col: 23, offset: 16067},
							expr: &ruleRefExpr{
								pos:    position{line: 558, col: 24, offset: 16068},
								offset: 324,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 558, col: 34, offset: 16078},
							offset: 327,
						},
						&labeledExpr{
							pos:   position{line: 558, col: 50, offset: 16094},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 558, col: 59, offset: 16103},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 558, col: 59, offset: 16103},
										offset: 102,
									},
									&ruleRefExpr{
										pos:    position{line: 558, col: 73, offset: 16117},
										offset: 106,
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 558, col: 91, offset: 16135},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "IncludeParseLine",
			pos:  position{line: 562, col: 1, offset: 16174},
			expr: &actionExpr{
				pos: position{line: 562, col: 20, offset: 16193},
				run: (*parser).callonIncludeParseLine1,
				expr: &seqExpr{
					pos: position{line: 562, col: 20, offset: 16193},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 562, col: 20, offset: 16193},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 562, col: 28, offset: 16201},
								expr: &charClassMatcher{
									pos:        position{line: 562, col: 28, offset: 16201},
									val:        "[^\\r\\n]",
									chars:      []rune{'\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
						&andExpr{
							pos: position{line: 562, col: 37, offset: 16210},
							expr: &ruleRefExpr{
								pos:    position{line: 562, col: 38, offset: 16211},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "IncludeParseLineElement",
			pos:  position{line: 566, col: 1, offset: 16298},
			expr: &oneOrMoreExpr{
				pos: position{line: 566, col: 28, offset: 16325},
				expr: &charClassMatcher{
					pos:        position{line: 566, col: 28, offset: 16325},
					val:        "[^\\r\\n]",
					chars:      []rune{'\r', '\n'},
					ignoreCase: false,
					inverted:   true,
				},
			},
		},
		{
			name: "Link",
			pos:  position{line: 571, col: 1, offset: 16340},
			expr: &actionExpr{
				pos: position{line: 571, col: 8, offset: 16347},
				run: (*parser).callonLink1,
				expr: &labeledExpr{
					pos:   position{line: 571, col: 8, offset: 16347},
					label: "link",
					expr: &choiceExpr{
						pos: position{line: 571, col: 14, offset: 16353},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 571, col: 14, offset: 16353},
								offset: 110,
							},
							&ruleRefExpr{
								pos:    position{line: 571, col: 25, offset: 16364},
								offset: 111,
							},
							&ruleRefExpr{
								pos:    position{line: 571, col: 40, offset: 16379},
								offset: 112,
							},
							&ruleRefExpr{
								pos:    position{line: 571, col: 55, offset: 16394},
								offset: 167,
							},
						},
					},
				},
			},
		},
		{
			name: "LinkMacro",
			pos:  position{line: 575, col: 1, offset: 16435},
			expr: &seqExpr{
				pos: position{line: 575, col: 13, offset: 16447},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 575, col: 13, offset: 16447},
						val:        "link:",
						ignoreCase: false,
						want:       "\"link:\"",
					},
					&zeroOrOneExpr{
						pos: position{line: 575, col: 21, offset: 16455},
						expr: &litMatcher{
							pos:        position{line: 575, col: 21, offset: 16455},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
					},
				},
			},
		},
		{
			name: "HTMLLink",
			pos:  position{line: 577, col: 1, offset: 16461},
			expr: &actionExpr{
				pos: position{line: 577, col: 12, offset: 16472},
				run: (*parser).callonHTMLLink1,
				expr: &seqExpr{
					pos: position{line: 577, col: 12, offset: 16472},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 577, col: 12, offset: 16472},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
						&labeledExpr{
							pos:   position{line: 577, col: 16, offset: 16476},
							label: "url",
							expr: &ruleRefExpr{
								pos:    position{line: 577, col: 21, offset: 16481},
								offset: 164,
							},
						},
						&litMatcher{
							pos:        position{line: 577, col: 30, offset: 16490},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
					},
				},
			},
		},
		{
			name: "PrefixedLink",
			pos:  position{line: 581, col: 1, offset: 16556},
			expr: &actionExpr{
				pos: position{line: 581, col: 16, offset: 16571},
				run: (*parser).callonPrefixedLink1,
				expr: &seqExpr{
					pos: position{line: 581, col: 16, offset: 16571},
					exprs: []any{
						&notExpr{
							pos: position{line: 581, col: 16, offset: 16571},
							expr: &litMatcher{
								pos:        position{line: 581, col: 17, offset: 16572},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&ruleRefExpr{
							pos:    position{line: 581, col: 22, offset: 16577},
							offset: 109,
						},
						&labeledExpr{
							pos:   position{line: 581, col: 32, offset: 16587},
							label: "url",
							expr: &ruleRefExpr{
								pos:    position{line: 581, col: 36, offset: 16591},
								offset: 163,
							},
						},
						&labeledExpr{
							pos:   position{line: 581, col: 40, offset: 16595},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 581, col: 52, offset: 16607},
								offset: 51,
							},
						},
					},
				},
			},
		},
		{
			name: "ExternalLink",
			pos:  position{line: 586, col: 1, offset: 16748},
			expr: &actionExpr{
				pos: position{line: 586, col: 16, offset: 16763},
				run: (*parser).callonExternalLink1,
				expr: &seqExpr{
					pos: position{line: 586, col: 16, offset: 16763},
					exprs: []any{
						&notExpr{
							pos: position{line: 586, col: 16, offset: 16763},
							expr: &litMatcher{
								pos:        position{line: 586, col: 17, offset: 16764},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 586, col: 22, offset: 16769},
							label: "url",
							expr: &ruleRefExpr{
								pos:    position{line: 586, col: 27, offset: 16774},
								offset: 164,
							},
						},
						&labeledExpr{
							pos:   position{line: 586, col: 36, offset: 16783},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 586, col: 47, offset: 16794},
								expr: &ruleRefExpr{
									pos:    position{line: 586, col: 48, offset: 16795},
									offset: 51,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Table",
			pos:  position{line: 592, col: 1, offset: 16928},
			expr: &actionExpr{
				pos: position{line: 592, col: 9, offset: 16936},
				run: (*parser).callonTable1,
				expr: &seqExpr{
					pos: position{line: 592, col: 9, offset: 16936},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 592, col: 9, offset: 16936},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 592, col: 20, offset: 16947},
								expr: &ruleRefExpr{
									pos:    position{line: 592, col: 21, offset: 16948},
									offset: 12,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 592, col: 46, offset: 16973},
							offset: 118,
						},
						&labeledExpr{
							pos:   position{line: 592, col: 57, offset: 16984},
							label: "cells",
							expr: &ruleRefExpr{
								pos:    position{line: 592, col: 64, offset: 16991},
								offset: 114,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 592, col: 79, offset: 17006},
							offset: 135,
						},
					},
				},
			},
		},
		{
			name: "TableElements",
			pos:  position{line: 600, col: 1, offset: 17163},
			expr: &zeroOrMoreExpr{
				pos: position{line: 600, col: 17, offset: 17179},
				expr: &ruleRefExpr{
					pos:    position{line: 600, col: 18, offset: 17180},
					offset: 115,
				},
			},
		},
		{
			name: "TableElement",
			pos:  position{line: 602, col: 1, offset: 17197},
			expr: &choiceExpr{
				pos: position{line: 603, col: 9, offset: 17222},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 603, col: 9, offset: 17222},
						offset: 119,
					},
					&ruleRefExpr{
						pos:    position{line: 604, col: 11, offset: 17248},
						offset: 121,
					},
					&ruleRefExpr{
						pos:    position{line: 605, col: 11, offset: 17270},
						offset: 131,
					},
					&ruleRefExpr{
						pos:    position{line: 606, col: 11, offset: 17297},
						offset: 136,
					},
				},
			},
		},
		{
			name: "IncludedTableElements",
			pos:  position{line: 609, col: 1, offset: 17318},
			expr: &actionExpr{
				pos: position{line: 609, col: 25, offset: 17342},
				run: (*parser).callonIncludedTableElements1,
				expr: &seqExpr{
					pos: position{line: 609, col: 25, offset: 17342},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 609, col: 25, offset: 17342},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 609, col: 33, offset: 17350},
								expr: &ruleRefExpr{
									pos:    position{line: 609, col: 34, offset: 17351},
									offset: 117,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 609, col: 57, offset: 17374},
							offset: 324,
						},
					},
				},
			},
		},
		{
			name: "IncludedTableElement",
			pos:  position{line: 614, col: 1, offset: 17493},
			expr: &choiceExpr{
				pos: position{line: 615, col: 9, offset: 17526},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 615, col: 9, offset: 17526},
						offset: 120,
					},
					&ruleRefExpr{
						pos:    position{line: 616, col: 11, offset: 17560},
						offset: 121,
					},
					&ruleRefExpr{
						pos:    position{line: 617, col: 11, offset: 17582},
						offset: 131,
					},
					&ruleRefExpr{
						pos:    position{line: 618, col: 11, offset: 17609},
						offset: 137,
					},
				},
			},
		},
		{
			name: "TableStart",
			pos:  position{line: 621, col: 1, offset: 17638},
			expr: &actionExpr{
				pos: position{line: 621, col: 14, offset: 17651},
				run: (*parser).callonTableStart1,
				expr: &seqExpr{
					pos: position{line: 621, col: 14, offset: 17651},
					exprs: []any{
						&notExpr{
							pos: position{line: 621, col: 14, offset: 17651},
							expr: &litMatcher{
								pos:        position{line: 621, col: 15, offset: 17652},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 621, col: 20, offset: 17657},
							val:        "|===",
							ignoreCase: false,
							want:       "\"|===\"",
						},
						&zeroOrMoreExpr{
							pos: position{line: 621, col: 27, offset: 17664},
							expr: &litMatcher{
								pos:        position{line: 621, col: 27, offset: 17664},
								val:        "=",
								ignoreCase: false,
								want:       "\"=\"",
							},
						},
						&ruleRefExpr{
							pos:    position{line: 621, col: 32, offset: 17669},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 621, col: 42, offset: 17679},
							expr: &ruleRefExpr{
								pos:    position{line: 621, col: 43, offset: 17680},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "TableEmptyLine",
			pos:  position{line: 625, col: 1, offset: 17751},
			expr: &actionExpr{
				pos: position{line: 625, col: 18, offset: 17768},
				run: (*parser).callonTableEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 625, col: 18, offset: 17768},
					exprs: []any{
						&notExpr{
							pos: position{line: 625, col: 18, offset: 17768},
							expr: &ruleRefExpr{
								pos:    position{line: 625, col: 19, offset: 17769},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 625, col: 28, offset: 17778},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 625, col: 36, offset: 17786},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 625, col: 46, offset: 17796},
							expr: &ruleRefExpr{
								pos:    position{line: 625, col: 48, offset: 17798},
								offset: 317,
							},
						},
					},
				},
			},
		},
		{
			name: "IncludedTableEmptyLine",
			pos:  position{line: 629, col: 1, offset: 17879},
			expr: &actionExpr{
				pos: position{line: 629, col: 26, offset: 17904},
				run: (*parser).callonIncludedTableEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 629, col: 26, offset: 17904},
					exprs: []any{
						&notExpr{
							pos: position{line: 629, col: 26, offset: 17904},
							expr: &ruleRefExpr{
								pos:    position{line: 629, col: 27, offset: 17905},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 629, col: 36, offset: 17914},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 629, col: 44, offset: 17922},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 629, col: 54, offset: 17932},
							expr: &choiceExpr{
								pos: position{line: 629, col: 56, offset: 17934},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 629, col: 56, offset: 17934},
										offset: 317,
									},
									&ruleRefExpr{
										pos:    position{line: 629, col: 66, offset: 17944},
										offset: 324,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TableMacros",
			pos:  position{line: 633, col: 1, offset: 18027},
			expr: &choiceExpr{
				pos: position{line: 633, col: 16, offset: 18042},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 633, col: 16, offset: 18042},
						offset: 123,
					},
					&ruleRefExpr{
						pos:    position{line: 633, col: 35, offset: 18061},
						offset: 125,
					},
					&ruleRefExpr{
						pos:    position{line: 633, col: 55, offset: 18081},
						offset: 122,
					},
					&ruleRefExpr{
						pos:    position{line: 633, col: 68, offset: 18094},
						offset: 124,
					},
					&ruleRefExpr{
						pos:    position{line: 633, col: 82, offset: 18108},
						offset: 128,
					},
					&ruleRefExpr{
						pos:    position{line: 633, col: 98, offset: 18124},
						offset: 129,
					},
					&ruleRefExpr{
						pos:    position{line: 633, col: 113, offset: 18139},
						offset: 130,
					},
				},
			},
		},
		{
			name: "TableIfDef",
			pos:  position{line: 635, col: 1, offset: 18165},
			expr: &actionExpr{
				pos: position{line: 635, col: 14, offset: 18178},
				run: (*parser).callonTableIfDef1,
				expr: &seqExpr{
					pos: position{line: 635, col: 14, offset: 18178},
					exprs: []any{
						&notExpr{
							pos: position{line: 635, col: 14, offset: 18178},
							expr: &ruleRefExpr{
								pos:    position{line: 635, col: 15, offset: 18179},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 635, col: 24, offset: 18188},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 635, col: 32, offset: 18196},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 635, col: 42, offset: 18206},
							label: "ifdef",
							expr: &ruleRefExpr{
								pos:    position{line: 635, col: 48, offset: 18212},
								offset: 291,
							},
						},
					},
				},
			},
		},
		{
			name: "TableInlineIfDef",
			pos:  position{line: 639, col: 1, offset: 18275},
			expr: &actionExpr{
				pos: position{line: 639, col: 20, offset: 18294},
				run: (*parser).callonTableInlineIfDef1,
				expr: &seqExpr{
					pos: position{line: 639, col: 20, offset: 18294},
					exprs: []any{
						&notExpr{
							pos: position{line: 639, col: 20, offset: 18294},
							expr: &ruleRefExpr{
								pos:    position{line: 639, col: 21, offset: 18295},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 639, col: 30, offset: 18304},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 639, col: 38, offset: 18312},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 639, col: 48, offset: 18322},
							label: "ifdef",
							expr: &ruleRefExpr{
								pos:    position{line: 639, col: 54, offset: 18328},
								offset: 291,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 639, col: 60, offset: 18334},
							offset: 317,
						},
						&notExpr{
							pos: position{line: 639, col: 68, offset: 18342},
							expr: &ruleRefExpr{
								pos:    position{line: 639, col: 69, offset: 18343},
								offset: 156,
							},
						},
						&labeledExpr{
							pos:   position{line: 639, col: 95, offset: 18369},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 639, col: 104, offset: 18378},
								offset: 141,
							},
						},
						&labeledExpr{
							pos:   position{line: 639, col: 122, offset: 18396},
							label: "endif",
							expr: &ruleRefExpr{
								pos:    position{line: 639, col: 128, offset: 18402},
								offset: 128,
							},
						},
					},
				},
			},
		},
		{
			name: "TableIfNDef",
			pos:  position{line: 653, col: 1, offset: 18753},
			expr: &actionExpr{
				pos: position{line: 653, col: 15, offset: 18767},
				run: (*parser).callonTableIfNDef1,
				expr: &seqExpr{
					pos: position{line: 653, col: 15, offset: 18767},
					exprs: []any{
						&notExpr{
							pos: position{line: 653, col: 15, offset: 18767},
							expr: &ruleRefExpr{
								pos:    position{line: 653, col: 16, offset: 18768},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 653, col: 25, offset: 18777},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 653, col: 33, offset: 18785},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 653, col: 43, offset: 18795},
							label: "ifndef",
							expr: &ruleRefExpr{
								pos:    position{line: 653, col: 50, offset: 18802},
								offset: 293,
							},
						},
					},
				},
			},
		},
		{
			name: "TableInlineIfNDef",
			pos:  position{line: 657, col: 1, offset: 18869},
			expr: &actionExpr{
				pos: position{line: 657, col: 21, offset: 18889},
				run: (*parser).callonTableInlineIfNDef1,
				expr: &seqExpr{
					pos: position{line: 657, col: 21, offset: 18889},
					exprs: []any{
						&notExpr{
							pos: position{line: 657, col: 21, offset: 18889},
							expr: &ruleRefExpr{
								pos:    position{line: 657, col: 22, offset: 18890},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 657, col: 31, offset: 18899},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 657, col: 39, offset: 18907},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 657, col: 49, offset: 18917},
							label: "ifndef",
							expr: &ruleRefExpr{
								pos:    position{line: 657, col: 56, offset: 18924},
								offset: 293,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 657, col: 63, offset: 18931},
							offset: 317,
						},
						&notExpr{
							pos: position{line: 657, col: 71, offset: 18939},
							expr: &ruleRefExpr{
								pos:    position{line: 657, col: 72, offset: 18940},
								offset: 156,
							},
						},
						&labeledExpr{
							pos:   position{line: 657, col: 98, offset: 18966},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 657, col: 107, offset: 18975},
								offset: 141,
							},
						},
						&labeledExpr{
							pos:   position{line: 657, col: 125, offset: 18993},
							label: "endif",
							expr: &ruleRefExpr{
								pos:    position{line: 657, col: 131, offset: 18999},
								offset: 128,
							},
						},
					},
				},
			},
		},
		{
			name: "TableIfEval",
			pos:  position{line: 671, col: 1, offset: 19352},
			expr: &actionExpr{
				pos: position{line: 671, col: 15, offset: 19366},
				run: (*parser).callonTableIfEval1,
				expr: &seqExpr{
					pos: position{line: 671, col: 15, offset: 19366},
					exprs: []any{
						&notExpr{
							pos: position{line: 671, col: 15, offset: 19366},
							expr: &ruleRefExpr{
								pos:    position{line: 671, col: 16, offset: 19367},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 671, col: 25, offset: 19376},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 671, col: 33, offset: 19384},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 671, col: 43, offset: 19394},
							label: "ifeval",
							expr: &ruleRefExpr{
								pos:    position{line: 671, col: 50, offset: 19401},
								offset: 302,
							},
						},
					},
				},
			},
		},
		{
			name: "TableInlineIfEval",
			pos:  position{line: 675, col: 1, offset: 19468},
			expr: &actionExpr{
				pos: position{line: 675, col: 21, offset: 19488},
				run: (*parser).callonTableInlineIfEval1,
				expr: &seqExpr{
					pos: position{line: 675, col: 21, offset: 19488},
					exprs: []any{
						&notExpr{
							pos: position{line: 675, col: 21, offset: 19488},
							expr: &ruleRefExpr{
								pos:    position{line: 675, col: 22, offset: 19489},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 675, col: 31, offset: 19498},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 675, col: 39, offset: 19506},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 675, col: 49, offset: 19516},
							label: "ifeval",
							expr: &ruleRefExpr{
								pos:    position{line: 675, col: 56, offset: 19523},
								offset: 302,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 675, col: 63, offset: 19530},
							offset: 317,
						},
						&notExpr{
							pos: position{line: 675, col: 71, offset: 19538},
							expr: &ruleRefExpr{
								pos:    position{line: 675, col: 72, offset: 19539},
								offset: 156,
							},
						},
						&labeledExpr{
							pos:   position{line: 675, col: 98, offset: 19565},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 675, col: 107, offset: 19574},
								offset: 141,
							},
						},
						&labeledExpr{
							pos:   position{line: 675, col: 125, offset: 19592},
							label: "endif",
							expr: &ruleRefExpr{
								pos:    position{line: 675, col: 131, offset: 19598},
								offset: 128,
							},
						},
					},
				},
			},
		},
		{
			name: "TableEndIfDef",
			pos:  position{line: 689, col: 1, offset: 19951},
			expr: &actionExpr{
				pos: position{line: 689, col: 17, offset: 19967},
				run: (*parser).callonTableEndIfDef1,
				expr: &seqExpr{
					pos: position{line: 689, col: 17, offset: 19967},
					exprs: []any{
						&notExpr{
							pos: position{line: 689, col: 17, offset: 19967},
							expr: &ruleRefExpr{
								pos:    position{line: 689, col: 18, offset: 19968},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 689, col: 27, offset: 19977},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 689, col: 35, offset: 19985},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 689, col: 45, offset: 19995},
							label: "endifdef",
							expr: &ruleRefExpr{
								pos:    position{line: 689, col: 54, offset: 20004},
								offset: 297,
							},
						},
					},
				},
			},
		},
		{
			name: "TableComment",
			pos:  position{line: 693, col: 1, offset: 20074},
			expr: &actionExpr{
				pos: position{line: 693, col: 16, offset: 20089},
				run: (*parser).callonTableComment1,
				expr: &seqExpr{
					pos: position{line: 693, col: 16, offset: 20089},
					exprs: []any{
						&notExpr{
							pos: position{line: 693, col: 16, offset: 20089},
							expr: &ruleRefExpr{
								pos:    position{line: 693, col: 17, offset: 20090},
								offset: 135,
							},
						},
						&choiceExpr{
							pos: position{line: 693, col: 27, offset: 20100},
							alternatives: []any{
								&ruleRefExpr{
									pos:    position{line: 693, col: 27, offset: 20100},
									offset: 317,
								},
								&ruleRefExpr{
									pos:    position{line: 693, col: 37, offset: 20110},
									offset: 326,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 693, col: 54, offset: 20127},
							label: "comment",
							expr: &ruleRefExpr{
								pos:    position{line: 693, col: 63, offset: 20136},
								offset: 269,
							},
						},
					},
				},
			},
		},
		{
			name: "TableMultiLineComment",
			pos:  position{line: 697, col: 1, offset: 20227},
			expr: &actionExpr{
				pos: position{line: 697, col: 25, offset: 20251},
				run: (*parser).callonTableMultiLineComment1,
				expr: &seqExpr{
					pos: position{line: 697, col: 25, offset: 20251},
					exprs: []any{
						&notExpr{
							pos: position{line: 697, col: 25, offset: 20251},
							expr: &ruleRefExpr{
								pos:    position{line: 697, col: 26, offset: 20252},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 697, col: 35, offset: 20261},
							offset: 317,
						},
						&labeledExpr{
							pos:   position{line: 697, col: 43, offset: 20269},
							label: "comment",
							expr: &ruleRefExpr{
								pos:    position{line: 697, col: 52, offset: 20278},
								offset: 272,
							},
						},
					},
				},
			},
		},
		{
			name: "TableFileInclude",
			pos:  position{line: 701, col: 1, offset: 20367},
			expr: &actionExpr{
				pos: position{line: 701, col: 20, offset: 20386},
				run: (*parser).callonTableFileInclude1,
				expr: &seqExpr{
					pos: position{line: 701, col: 20, offset: 20386},
					exprs: []any{
						&notExpr{
							pos: position{line: 701, col: 20, offset: 20386},
							expr: &ruleRefExpr{
								pos:    position{line: 701, col: 21, offset: 20387},
								offset: 135,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 701, col: 30, offset: 20396},
							offset: 317,
						},
						&notExpr{
							pos: position{line: 701, col: 38, offset: 20404},
							expr: &litMatcher{
								pos:        position{line: 701, col: 39, offset: 20405},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 701, col: 44, offset: 20410},
							val:        "include::",
							ignoreCase: false,
							want:       "\"include::\"",
						},
						&labeledExpr{
							pos:   position{line: 701, col: 56, offset: 20422},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 701, col: 62, offset: 20428},
								offset: 103,
							},
						},
						&labeledExpr{
							pos:   position{line: 701, col: 79, offset: 20445},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 701, col: 91, offset: 20457},
								offset: 51,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 701, col: 109, offset: 20475},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 701, col: 119, offset: 20485},
							expr: &ruleRefExpr{
								pos:    position{line: 701, col: 120, offset: 20486},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "TableEmptyLines",
			pos:  position{line: 705, col: 1, offset: 20642},
			expr: &oneOrMoreExpr{
				pos: position{line: 705, col: 19, offset: 20660},
				expr: &ruleRefExpr{
					pos:    position{line: 705, col: 19, offset: 20660},
					offset: 119,
				},
			},
		},
		{
			name: "TableCellInlineContent",
			pos:  position{line: 707, col: 1, offset: 20677},
			expr: &actionExpr{
				pos: position{line: 707, col: 26, offset: 20702},
				run: (*parser).callonTableCellInlineContent1,
				expr: &seqExpr{
					pos: position{line: 707, col: 26, offset: 20702},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 707, col: 26, offset: 20702},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 707, col: 34, offset: 20710},
								expr: &ruleRefExpr{
									pos:    position{line: 707, col: 35, offset: 20711},
									offset: 134,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 707, col: 67, offset: 20743},
							offset: 324,
						},
					},
				},
			},
		},
		{
			name: "TableCellInlineContentElement",
			pos:  position{line: 711, col: 1, offset: 20821},
			expr: &choiceExpr{
				pos: position{line: 712, col: 5, offset: 20859},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 712, col: 5, offset: 20859},
						offset: 95,
					},
					&ruleRefExpr{
						pos:    position{line: 713, col: 5, offset: 20879},
						offset: 101,
					},
					&ruleRefExpr{
						pos:    position{line: 714, col: 5, offset: 20891},
						offset: 99,
					},
					&ruleRefExpr{
						pos:    position{line: 715, col: 5, offset: 20910},
						offset: 108,
					},
					&ruleRefExpr{
						pos:    position{line: 716, col: 5, offset: 20921},
						offset: 84,
					},
					&ruleRefExpr{
						pos:    position{line: 717, col: 5, offset: 20936},
						offset: 238,
					},
					&ruleRefExpr{
						pos:    position{line: 718, col: 5, offset: 20957},
						offset: 53,
					},
					&ruleRefExpr{
						pos:    position{line: 719, col: 5, offset: 20982},
						offset: 311,
					},
					&ruleRefExpr{
						pos:    position{line: 720, col: 5, offset: 20998},
						offset: 153,
					},
					&ruleRefExpr{
						pos:    position{line: 721, col: 5, offset: 21029},
						offset: 336,
					},
					&ruleRefExpr{
						pos:    position{line: 722, col: 5, offset: 21056},
						offset: 317,
					},
				},
			},
		},
		{
			name: "TableEnd",
			pos:  position{line: 725, col: 1, offset: 21069},
			expr: &seqExpr{
				pos: position{line: 725, col: 12, offset: 21080},
				exprs: []any{
					&ruleRefExpr{
						pos:    position{line: 725, col: 12, offset: 21080},
						offset: 317,
					},
					&notExpr{
						pos: position{line: 725, col: 20, offset: 21088},
						expr: &litMatcher{
							pos:        position{line: 725, col: 21, offset: 21089},
							val:        "\\",
							ignoreCase: false,
							want:       "\"\\\\\"",
						},
					},
					&litMatcher{
						pos:        position{line: 725, col: 26, offset: 21094},
						val:        "|===",
						ignoreCase: false,
						want:       "\"|===\"",
					},
					&zeroOrMoreExpr{
						pos: position{line: 725, col: 33, offset: 21101},
						expr: &litMatcher{
							pos:        position{line: 725, col: 33, offset: 21101},
							val:        "=",
							ignoreCase: false,
							want:       "\"=\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 725, col: 38, offset: 21106},
						offset: 334,
					},
					&andExpr{
						pos: position{line: 725, col: 48, offset: 21116},
						expr: &ruleRefExpr{
							pos:    position{line: 725, col: 49, offset: 21117},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "TableRow",
			pos:  position{line: 727, col: 1, offset: 21130},
			expr: &actionExpr{
				pos: position{line: 727, col: 12, offset: 21141},
				run: (*parser).callonTableRow1,
				expr: &seqExpr{
					pos: position{line: 727, col: 12, offset: 21141},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 727, col: 12, offset: 21141},
							label: "initial",
							expr: &ruleRefExpr{
								pos:    position{line: 727, col: 21, offset: 21150},
								offset: 139,
							},
						},
						&labeledExpr{
							pos:   position{line: 727, col: 46, offset: 21175},
							label: "additional",
							expr: &zeroOrMoreExpr{
								pos: position{line: 727, col: 57, offset: 21186},
								expr: &ruleRefExpr{
									pos:    position{line: 727, col: 58, offset: 21187},
									offset: 140,
								},
							},
						},
						&andExpr{
							pos: position{line: 727, col: 86, offset: 21215},
							expr: &choiceExpr{
								pos: position{line: 727, col: 88, offset: 21217},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 727, col: 88, offset: 21217},
										offset: 135,
									},
									&ruleRefExpr{
										pos:    position{line: 727, col: 99, offset: 21228},
										offset: 138,
									},
									&ruleRefExpr{
										pos:    position{line: 727, col: 121, offset: 21250},
										offset: 317,
									},
									&ruleRefExpr{
										pos:    position{line: 727, col: 131, offset: 21260},
										offset: 324,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "IncludedTableRow",
			pos:  position{line: 736, col: 1, offset: 21501},
			expr: &actionExpr{
				pos: position{line: 736, col: 20, offset: 21520},
				run: (*parser).callonIncludedTableRow1,
				expr: &seqExpr{
					pos: position{line: 736, col: 20, offset: 21520},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 736, col: 20, offset: 21520},
							label: "initial",
							expr: &ruleRefExpr{
								pos:    position{line: 736, col: 29, offset: 21529},
								offset: 139,
							},
						},
						&labeledExpr{
							pos:   position{line: 736, col: 54, offset: 21554},
							label: "additional",
							expr: &zeroOrMoreExpr{
								pos: position{line: 736, col: 65, offset: 21565},
								expr: &ruleRefExpr{
									pos:    position{line: 736, col: 66, offset: 21566},
									offset: 140,
								},
							},
						},
						&andExpr{
							pos: position{line: 736, col: 94, offset: 21594},
							expr: &choiceExpr{
								pos: position{line: 736, col: 96, offset: 21596},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 736, col: 96, offset: 21596},
										offset: 324,
									},
									&ruleRefExpr{
										pos:    position{line: 736, col: 108, offset: 21608},
										offset: 138,
									},
									&ruleRefExpr{
										pos:    position{line: 736, col: 130, offset: 21630},
										offset: 317,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "TableCellDelimiter",
			pos:  position{line: 745, col: 1, offset: 21870},
			expr: &choiceExpr{
				pos: position{line: 745, col: 23, offset: 21892},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 745, col: 23, offset: 21892},
						offset: 157,
					},
					&ruleRefExpr{
						pos:    position{line: 745, col: 54, offset: 21923},
						offset: 156,
					},
				},
			},
		},
		{
			name: "InitialInlineTableCell",
			pos:  position{line: 747, col: 1, offset: 21951},
			expr: &actionExpr{
				pos: position{line: 747, col: 26, offset: 21976},
				run: (*parser).callonInitialInlineTableCell1,
				expr: &seqExpr{
					pos: position{line: 747, col: 26, offset: 21976},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 747, col: 26, offset: 21976},
							label: "format",
							expr: &ruleRefExpr{
								pos:    position{line: 747, col: 34, offset: 21984},
								offset: 156,
							},
						},
						&labeledExpr{
							pos:   position{line: 747, col: 61, offset: 22011},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 747, col: 70, offset: 22020},
								offset: 141,
							},
						},
						&andExpr{
							pos: position{line: 747, col: 88, offset: 22038},
							expr: &choiceExpr{
								pos: position{line: 747, col: 90, offset: 22040},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 747, col: 90, offset: 22040},
										offset: 135,
									},
									&ruleRefExpr{
										pos:    position{line: 747, col: 101, offset: 22051},
										offset: 132,
									},
									&ruleRefExpr{
										pos:    position{line: 747, col: 119, offset: 22069},
										offset: 121,
									},
									&ruleRefExpr{
										pos:    position{line: 747, col: 133, offset: 22083},
										offset: 138,
									},
									&ruleRefExpr{
										pos:    position{line: 747, col: 155, offset: 22105},
										offset: 317,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "AdditionalInlineTableCell",
			pos:  position{line: 752, col: 1, offset: 22237},
			expr: &actionExpr{
				pos: position{line: 752, col: 30, offset: 22266},
				run: (*parser).callonAdditionalInlineTableCell1,
				expr: &seqExpr{
					pos: position{line: 752, col: 30, offset: 22266},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 752, col: 30, offset: 22266},
							label: "format",
							expr: &ruleRefExpr{
								pos:    position{line: 752, col: 38, offset: 22274},
								offset: 157,
							},
						},
						&labeledExpr{
							pos:   position{line: 752, col: 68, offset: 22304},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 752, col: 77, offset: 22313},
								offset: 141,
							},
						},
						&andExpr{
							pos: position{line: 752, col: 95, offset: 22331},
							expr: &choiceExpr{
								pos: position{line: 752, col: 97, offset: 22333},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 752, col: 97, offset: 22333},
										offset: 135,
									},
									&ruleRefExpr{
										pos:    position{line: 752, col: 108, offset: 22344},
										offset: 132,
									},
									&ruleRefExpr{
										pos:    position{line: 752, col: 126, offset: 22362},
										offset: 121,
									},
									&ruleRefExpr{
										pos:    position{line: 752, col: 140, offset: 22376},
										offset: 138,
									},
									&ruleRefExpr{
										pos:    position{line: 752, col: 162, offset: 22398},
										offset: 317,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableLines",
			pos:  position{line: 757, col: 1, offset: 22526},
			expr: &actionExpr{
				pos: position{line: 757, col: 20, offset: 22545},
				run: (*parser).callonInlineTableLines1,
				expr: &labeledExpr{
					pos:   position{line: 757, col: 20, offset: 22545},
					label: "content",
					expr: &choiceExpr{
						pos: position{line: 757, col: 29, offset: 22554},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 757, col: 29, offset: 22554},
								offset: 145,
							},
							&ruleRefExpr{
								pos:    position{line: 757, col: 50, offset: 22575},
								offset: 150,
							},
							&ruleRefExpr{
								pos:    position{line: 757, col: 72, offset: 22597},
								offset: 142,
							},
						},
					},
				},
			},
		},
		{
			name: "EmptyCell",
			pos:  position{line: 761, col: 1, offset: 22641},
			expr: &actionExpr{
				pos: position{line: 761, col: 13, offset: 22653},
				run: (*parser).callonEmptyCell1,
				expr: &andExpr{
					pos: position{line: 761, col: 13, offset: 22653},
					expr: &choiceExpr{
						pos: position{line: 761, col: 15, offset: 22655},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 761, col: 15, offset: 22655},
								offset: 135,
							},
							&ruleRefExpr{
								pos:    position{line: 761, col: 26, offset: 22666},
								offset: 138,
							},
							&ruleRefExpr{
								pos:    position{line: 761, col: 48, offset: 22688},
								offset: 317,
							},
						},
					},
				},
			},
		},
		{
			name: "ValidTableCellPrefix",
			pos:  position{line: 765, col: 1, offset: 22742},
			expr: &seqExpr{
				pos: position{line: 765, col: 24, offset: 22765},
				exprs: []any{
					&notExpr{
						pos: position{line: 765, col: 24, offset: 22765},
						expr: &ruleRefExpr{
							pos:    position{line: 765, col: 25, offset: 22766},
							offset: 135,
						},
					},
					&notExpr{
						pos: position{line: 765, col: 34, offset: 22775},
						expr: &ruleRefExpr{
							pos:    position{line: 765, col: 35, offset: 22776},
							offset: 138,
						},
					},
					&notExpr{
						pos: position{line: 765, col: 54, offset: 22795},
						expr: &ruleRefExpr{
							pos:    position{line: 765, col: 55, offset: 22796},
							offset: 121,
						},
					},
				},
			},
		},
		{
			name: "ValidMultilineTableCellPrefix",
			pos:  position{line: 767, col: 1, offset: 22809},
			expr: &notExpr{
				pos: position{line: 767, col: 33, offset: 22841},
				expr: &ruleRefExpr{
					pos:    position{line: 767, col: 34, offset: 22842},
					offset: 121,
				},
			},
		},
		{
			name: "MultiLineTableCell",
			pos:  position{line: 769, col: 1, offset: 22855},
			expr: &actionExpr{
				pos: position{line: 769, col: 22, offset: 22876},
				run: (*parser).callonMultiLineTableCell1,
				expr: &seqExpr{
					pos: position{line: 769, col: 22, offset: 22876},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 769, col: 22, offset: 22876},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 769, col: 28, offset: 22882},
								expr: &ruleRefExpr{
									pos:    position{line: 769, col: 29, offset: 22883},
									offset: 146,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 769, col: 51, offset: 22905},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 769, col: 60, offset: 22914},
								offset: 149,
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellLine",
			pos:  position{line: 779, col: 1, offset: 23177},
			expr: &choiceExpr{
				pos: position{line: 779, col: 23, offset: 23199},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 779, col: 23, offset: 23199},
						offset: 148,
					},
					&ruleRefExpr{
						pos:    position{line: 779, col: 50, offset: 23226},
						offset: 147,
					},
				},
			},
		},
		{
			name: "InlineTableCellIntermediateLine",
			pos:  position{line: 781, col: 1, offset: 23260},
			expr: &actionExpr{
				pos: position{line: 781, col: 35, offset: 23294},
				run: (*parser).callonInlineTableCellIntermediateLine1,
				expr: &seqExpr{
					pos: position{line: 781, col: 35, offset: 23294},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 781, col: 35, offset: 23294},
							offset: 143,
						},
						&labeledExpr{
							pos:   position{line: 781, col: 56, offset: 23315},
							label: "newline",
							expr: &zeroOrOneExpr{
								pos: position{line: 781, col: 64, offset: 23323},
								expr: &ruleRefExpr{
									pos:    position{line: 781, col: 64, offset: 23323},
									offset: 317,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 781, col: 73, offset: 23332},
							offset: 144,
						},
						&labeledExpr{
							pos:   position{line: 781, col: 103, offset: 23362},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 781, col: 111, offset: 23370},
								expr: &ruleRefExpr{
									pos:    position{line: 781, col: 112, offset: 23371},
									offset: 151,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 781, col: 133, offset: 23392},
							label: "newlineBeforeEmptyLine",
							expr: &zeroOrOneExpr{
								pos: position{line: 781, col: 156, offset: 23415},
								expr: &actionExpr{
									pos: position{line: 781, col: 157, offset: 23416},
									run: (*parser).callonInlineTableCellIntermediateLine13,
									expr: &seqExpr{
										pos: position{line: 781, col: 157, offset: 23416},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 781, col: 157, offset: 23416},
												label: "nl",
												expr: &ruleRefExpr{
													pos:    position{line: 781, col: 160, offset: 23419},
													offset: 317,
												},
											},
											&ruleRefExpr{
												pos:    position{line: 781, col: 168, offset: 23427},
												offset: 334,
											},
											&andExpr{
												pos: position{line: 781, col: 178, offset: 23437},
												expr: &ruleRefExpr{
													pos:    position{line: 781, col: 180, offset: 23439},
													offset: 317,
												},
											},
										},
									},
								},
							},
						},
						&andExpr{
							pos: position{line: 781, col: 209, offset: 23468},
							expr: &ruleRefExpr{
								pos:    position{line: 781, col: 210, offset: 23469},
								offset: 317,
							},
						},
						&notExpr{
							pos: position{line: 781, col: 218, offset: 23477},
							expr: &choiceExpr{
								pos: position{line: 781, col: 220, offset: 23479},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 781, col: 220, offset: 23479},
										offset: 121,
									},
									&ruleRefExpr{
										pos:    position{line: 781, col: 234, offset: 23493},
										offset: 135,
									},
									&ruleRefExpr{
										pos:    position{line: 781, col: 245, offset: 23504},
										offset: 138,
									},
								},
							},
						},
						&andExpr{
							pos: position{line: 781, col: 267, offset: 23526},
							expr: &choiceExpr{
								pos: position{line: 781, col: 269, offset: 23528},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 781, col: 269, offset: 23528},
										offset: 146,
									},
									&ruleRefExpr{
										pos:    position{line: 781, col: 291, offset: 23550},
										offset: 149,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellEmptyLine",
			pos:  position{line: 794, col: 1, offset: 23907},
			expr: &actionExpr{
				pos: position{line: 794, col: 28, offset: 23934},
				run: (*parser).callonInlineTableCellEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 794, col: 28, offset: 23934},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 794, col: 28, offset: 23934},
							offset: 143,
						},
						&ruleRefExpr{
							pos:    position{line: 794, col: 49, offset: 23955},
							offset: 317,
						},
						&ruleRefExpr{
							pos:    position{line: 794, col: 57, offset: 23963},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 794, col: 67, offset: 23973},
							expr: &ruleRefExpr{
								pos:    position{line: 794, col: 69, offset: 23975},
								offset: 317,
							},
						},
						&notExpr{
							pos: position{line: 794, col: 78, offset: 23984},
							expr: &ruleRefExpr{
								pos:    position{line: 794, col: 79, offset: 23985},
								offset: 135,
							},
						},
						&notExpr{
							pos: position{line: 794, col: 88, offset: 23994},
							expr: &ruleRefExpr{
								pos:    position{line: 794, col: 89, offset: 23995},
								offset: 138,
							},
						},
						&notExpr{
							pos: position{line: 794, col: 108, offset: 24014},
							expr: &ruleRefExpr{
								pos:    position{line: 794, col: 109, offset: 24015},
								offset: 121,
							},
						},
						&andExpr{
							pos: position{line: 794, col: 121, offset: 24027},
							expr: &choiceExpr{
								pos: position{line: 794, col: 123, offset: 24029},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 794, col: 123, offset: 24029},
										offset: 146,
									},
									&ruleRefExpr{
										pos:    position{line: 794, col: 145, offset: 24051},
										offset: 149,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellLastLine",
			pos:  position{line: 799, col: 1, offset: 24181},
			expr: &actionExpr{
				pos: position{line: 799, col: 27, offset: 24207},
				run: (*parser).callonInlineTableCellLastLine1,
				expr: &seqExpr{
					pos: position{line: 799, col: 27, offset: 24207},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 799, col: 27, offset: 24207},
							offset: 143,
						},
						&labeledExpr{
							pos:   position{line: 799, col: 48, offset: 24228},
							label: "nl",
							expr: &ruleRefExpr{
								pos:    position{line: 799, col: 51, offset: 24231},
								offset: 317,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 799, col: 59, offset: 24239},
							offset: 144,
						},
						&labeledExpr{
							pos:   position{line: 799, col: 89, offset: 24269},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 799, col: 97, offset: 24277},
								expr: &ruleRefExpr{
									pos:    position{line: 799, col: 98, offset: 24278},
									offset: 151,
								},
							},
						},
						&andExpr{
							pos: position{line: 799, col: 119, offset: 24299},
							expr: &choiceExpr{
								pos: position{line: 799, col: 121, offset: 24301},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 799, col: 121, offset: 24301},
										offset: 135,
									},
									&ruleRefExpr{
										pos:    position{line: 799, col: 132, offset: 24312},
										offset: 132,
									},
									&ruleRefExpr{
										pos:    position{line: 799, col: 150, offset: 24330},
										offset: 121,
									},
									&ruleRefExpr{
										pos:    position{line: 799, col: 164, offset: 24344},
										offset: 138,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableElements",
			pos:  position{line: 806, col: 1, offset: 24519},
			expr: &actionExpr{
				pos: position{line: 806, col: 23, offset: 24541},
				run: (*parser).callonInlineTableElements1,
				expr: &seqExpr{
					pos: position{line: 806, col: 23, offset: 24541},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 806, col: 23, offset: 24541},
							offset: 143,
						},
						&labeledExpr{
							pos:   position{line: 806, col: 44, offset: 24562},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 806, col: 52, offset: 24570},
								expr: &ruleRefExpr{
									pos:    position{line: 806, col: 53, offset: 24571},
									offset: 151,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableElement",
			pos:  position{line: 811, col: 1, offset: 24658},
			expr: &actionExpr{
				pos: position{line: 811, col: 22, offset: 24679},
				run: (*parser).callonInlineTableElement1,
				expr: &seqExpr{
					pos: position{line: 811, col: 22, offset: 24679},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 811, col: 22, offset: 24679},
							offset: 143,
						},
						&labeledExpr{
							pos:   position{line: 811, col: 44, offset: 24701},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 812, col: 4, offset: 24714},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 812, col: 4, offset: 24714},
										offset: 95,
									},
									&ruleRefExpr{
										pos:    position{line: 813, col: 5, offset: 24734},
										offset: 101,
									},
									&ruleRefExpr{
										pos:    position{line: 814, col: 5, offset: 24746},
										offset: 99,
									},
									&ruleRefExpr{
										pos:    position{line: 815, col: 5, offset: 24765},
										offset: 108,
									},
									&ruleRefExpr{
										pos:    position{line: 816, col: 5, offset: 24776},
										offset: 84,
									},
									&ruleRefExpr{
										pos:    position{line: 817, col: 5, offset: 24791},
										offset: 238,
									},
									&ruleRefExpr{
										pos:    position{line: 818, col: 5, offset: 24812},
										offset: 53,
									},
									&ruleRefExpr{
										pos:    position{line: 819, col: 5, offset: 24837},
										offset: 311,
									},
									&ruleRefExpr{
										pos:    position{line: 820, col: 5, offset: 24853},
										offset: 154,
									},
									&ruleRefExpr{
										pos:    position{line: 821, col: 5, offset: 24882},
										offset: 153,
									},
									&ruleRefExpr{
										pos:    position{line: 822, col: 5, offset: 24913},
										offset: 155,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "BlockTableElement",
			pos:  position{line: 827, col: 1, offset: 24978},
			expr: &actionExpr{
				pos: position{line: 827, col: 21, offset: 24998},
				run: (*parser).callonBlockTableElement1,
				expr: &seqExpr{
					pos: position{line: 827, col: 21, offset: 24998},
					exprs: []any{
						&notExpr{
							pos: position{line: 827, col: 21, offset: 24998},
							expr: &ruleRefExpr{
								pos:    position{line: 827, col: 22, offset: 24999},
								offset: 156,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 827, col: 48, offset: 25025},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 827, col: 59, offset: 25036},
							label: "element",
							expr: &ruleRefExpr{
								pos:    position{line: 827, col: 68, offset: 25045},
								offset: 2,
							},
						},
						&notExpr{
							pos: position{line: 827, col: 82, offset: 25059},
							expr: &ruleRefExpr{
								pos:    position{line: 827, col: 83, offset: 25060},
								offset: 138,
							},
						},
						&notExpr{
							pos: position{line: 827, col: 103, offset: 25080},
							expr: &ruleRefExpr{
								pos:    position{line: 827, col: 104, offset: 25081},
								offset: 135,
							},
						},
					},
				},
			},
		},
		{
			name: "NakedInlineTableCellText",
			pos:  position{line: 832, col: 1, offset: 25126},
			expr: &actionExpr{
				pos: position{line: 832, col: 28, offset: 25153},
				run: (*parser).callonNakedInlineTableCellText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 832, col: 28, offset: 25153},
					expr: &seqExpr{
						pos: position{line: 832, col: 29, offset: 25154},
						exprs: []any{
							&notExpr{
								pos: position{line: 832, col: 29, offset: 25154},
								expr: &ruleRefExpr{
									pos:    position{line: 832, col: 30, offset: 25155},
									offset: 162,
								},
							},
							&notExpr{
								pos: position{line: 832, col: 40, offset: 25165},
								expr: &ruleRefExpr{
									pos:    position{line: 832, col: 41, offset: 25166},
									offset: 109,
								},
							},
							&notExpr{
								pos: position{line: 832, col: 51, offset: 25176},
								expr: &ruleRefExpr{
									pos:    position{line: 832, col: 52, offset: 25177},
									offset: 100,
								},
							},
							&notExpr{
								pos: position{line: 832, col: 73, offset: 25198},
								expr: &ruleRefExpr{
									pos:    position{line: 832, col: 74, offset: 25199},
									offset: 245,
								},
							},
							&charClassMatcher{
								pos:        position{line: 832, col: 99, offset: 25224},
								val:        "[A-Za-z ]",
								chars:      []rune{' '},
								ranges:     []rune{'A', 'Z', 'a', 'z'},
								ignoreCase: false,
								inverted:   false,
							},
							&notExpr{
								pos: position{line: 832, col: 109, offset: 25234},
								expr: &ruleRefExpr{
									pos:    position{line: 832, col: 110, offset: 25235},
									offset: 138,
								},
							},
							&notExpr{
								pos: position{line: 832, col: 129, offset: 25254},
								expr: &ruleRefExpr{
									pos:    position{line: 832, col: 130, offset: 25255},
									offset: 135,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineTableCellSpaces",
			pos:  position{line: 836, col: 1, offset: 25327},
			expr: &actionExpr{
				pos: position{line: 836, col: 25, offset: 25351},
				run: (*parser).callonInlineTableCellSpaces1,
				expr: &oneOrMoreExpr{
					pos: position{line: 836, col: 25, offset: 25351},
					expr: &seqExpr{
						pos: position{line: 836, col: 26, offset: 25352},
						exprs: []any{
							&ruleRefExpr{
								pos:    position{line: 836, col: 26, offset: 25352},
								offset: 339,
							},
							&notExpr{
								pos: position{line: 836, col: 28, offset: 25354},
								expr: &ruleRefExpr{
									pos:    position{line: 836, col: 29, offset: 25355},
									offset: 138,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CharacterClassTableCell",
			pos:  position{line: 840, col: 1, offset: 25436},
			expr: &actionExpr{
				pos: position{line: 840, col: 27, offset: 25462},
				run: (*parser).callonCharacterClassTableCell1,
				expr: &seqExpr{
					pos: position{line: 840, col: 27, offset: 25462},
					exprs: []any{
						&notExpr{
							pos: position{line: 840, col: 27, offset: 25462},
							expr: &ruleRefExpr{
								pos:    position{line: 840, col: 28, offset: 25463},
								offset: 138,
							},
						},
						&choiceExpr{
							pos: position{line: 840, col: 48, offset: 25483},
							alternatives: []any{
								&litMatcher{
									pos:        position{line: 840, col: 48, offset: 25483},
									val:        "\\|",
									ignoreCase: false,
									want:       "\"\\\\|\"",
								},
								&charClassMatcher{
									pos:        position{line: 840, col: 56, offset: 25491},
									val:        "[^|\\r\\n]",
									chars:      []rune{'|', '\r', '\n'},
									ignoreCase: false,
									inverted:   true,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InitialTableCellDelimiter",
			pos:  position{line: 846, col: 1, offset: 25611},
			expr: &actionExpr{
				pos: position{line: 846, col: 29, offset: 25639},
				run: (*parser).callonInitialTableCellDelimiter1,
				expr: &seqExpr{
					pos: position{line: 846, col: 29, offset: 25639},
					exprs: []any{
						&notExpr{
							pos: position{line: 846, col: 29, offset: 25639},
							expr: &ruleRefExpr{
								pos:    position{line: 846, col: 30, offset: 25640},
								offset: 135,
							},
						},
						&choiceExpr{
							pos: position{line: 846, col: 40, offset: 25650},
							alternatives: []any{
								&ruleRefExpr{
									pos:    position{line: 846, col: 40, offset: 25650},
									offset: 326,
								},
								&ruleRefExpr{
									pos:    position{line: 846, col: 58, offset: 25668},
									offset: 317,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 846, col: 67, offset: 25677},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 846, col: 77, offset: 25687},
							label: "format",
							expr: &zeroOrOneExpr{
								pos: position{line: 846, col: 84, offset: 25694},
								expr: &ruleRefExpr{
									pos:    position{line: 846, col: 85, offset: 25695},
									offset: 161,
								},
							},
						},
						&notExpr{
							pos: position{line: 846, col: 103, offset: 25713},
							expr: &litMatcher{
								pos:        position{line: 846, col: 104, offset: 25714},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 846, col: 109, offset: 25719},
							val:        "|",
							ignoreCase: false,
							want:       "\"|\"",
						},
					},
				},
			},
		},
		{
			name: "AdditionalTableCellDelimiter",
			pos:  position{line: 853, col: 1, offset: 25835},
			expr: &actionExpr{
				pos: position{line: 853, col: 32, offset: 25866},
				run: (*parser).callonAdditionalTableCellDelimiter1,
				expr: &seqExpr{
					pos: position{line: 853, col: 32, offset: 25866},
					exprs: []any{
						&notExpr{
							pos: position{line: 853, col: 32, offset: 25866},
							expr: &ruleRefExpr{
								pos:    position{line: 853, col: 33, offset: 25867},
								offset: 135,
							},
						},
						&labeledExpr{
							pos:   position{line: 853, col: 42, offset: 25876},
							label: "format",
							expr: &zeroOrOneExpr{
								pos: position{line: 853, col: 49, offset: 25883},
								expr: &ruleRefExpr{
									pos:    position{line: 853, col: 50, offset: 25884},
									offset: 159,
								},
							},
						},
						&notExpr{
							pos: position{line: 853, col: 78, offset: 25912},
							expr: &litMatcher{
								pos:        position{line: 853, col: 79, offset: 25913},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 853, col: 84, offset: 25918},
							val:        "|",
							ignoreCase: false,
							want:       "\"|\"",
						},
					},
				},
			},
		},
		{
			name: "InitialTableCellFormat",
			pos:  position{line: 858, col: 1, offset: 26023},
			expr: &actionExpr{
				pos: position{line: 858, col: 26, offset: 26048},
				run: (*parser).callonInitialTableCellFormat1,
				expr: &seqExpr{
					pos: position{line: 858, col: 26, offset: 26048},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 858, col: 26, offset: 26048},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 858, col: 36, offset: 26058},
							label: "format",
							expr: &ruleRefExpr{
								pos:    position{line: 858, col: 44, offset: 26066},
								offset: 161,
							},
						},
						&andCodeExpr{
							pos: position{line: 858, col: 61, offset: 26083},
							run: (*parser).callonInitialTableCellFormat6,
						},
					},
				},
			},
		},
		{
			name: "AdditionalTableCellFormat",
			pos:  position{line: 865, col: 1, offset: 26209},
			expr: &actionExpr{
				pos: position{line: 865, col: 29, offset: 26237},
				run: (*parser).callonAdditionalTableCellFormat1,
				expr: &seqExpr{
					pos: position{line: 865, col: 29, offset: 26237},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 865, col: 29, offset: 26237},
							label: "lead",
							expr: &ruleRefExpr{
								pos:    position{line: 865, col: 35, offset: 26243},
								offset: 338,
							},
						},
						&labeledExpr{
							pos:   position{line: 865, col: 39, offset: 26247},
							label: "format",
							expr: &ruleRefExpr{
								pos:    position{line: 865, col: 47, offset: 26255},
								offset: 161,
							},
						},
						&andCodeExpr{
							pos: position{line: 865, col: 64, offset: 26272},
							run: (*parser).callonAdditionalTableCellFormat7,
						},
					},
				},
			},
		},
		{
			name: "TableCellSpan",
			pos:  position{line: 871, col: 1, offset: 26358},
			expr: &actionExpr{
				pos: position{line: 871, col: 17, offset: 26374},
				run: (*parser).callonTableCellSpan1,
				expr: &seqExpr{
					pos: position{line: 871, col: 17, offset: 26374},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 871, col: 17, offset: 26374},
							label: "column",
							expr: &zeroOrOneExpr{
								pos: position{line: 871, col: 24, offset: 26381},
								expr: &actionExpr{
									pos: position{line: 871, col: 25, offset: 26382},
									run: (*parser).callonTableCellSpan5,
									expr: &labeledExpr{
										pos:   position{line: 871, col: 25, offset: 26382},
										label: "n",
										expr: &ruleRefExpr{
											pos:    position{line: 871, col: 27, offset: 26384},
											offset: 319,
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 873, col: 12, offset: 26455},
							label: "row",
							expr: &zeroOrOneExpr{
								pos: position{line: 873, col: 17, offset: 26460},
								expr: &actionExpr{
									pos: position{line: 873, col: 18, offset: 26461},
									run: (*parser).callonTableCellSpan10,
									expr: &seqExpr{
										pos: position{line: 873, col: 18, offset: 26461},
										exprs: []any{
											&litMatcher{
												pos:        position{line: 873, col: 18, offset: 26461},
												val:        ".",
												ignoreCase: false,
												want:       "\".\"",
											},
											&labeledExpr{
												pos:   position{line: 873, col: 22, offset: 26465},
												label: "n",
												expr: &ruleRefExpr{
													pos:    position{line: 873, col: 24, offset: 26467},
													offset: 319,
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 876, col: 11, offset: 26545},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
					},
				},
			},
		},
		{
			name: "TableCellFormat",
			pos:  position{line: 884, col: 1, offset: 26773},
			expr: &actionExpr{
				pos: position{line: 885, col: 5, offset: 26797},
				run: (*parser).callonTableCellFormat1,
				expr: &seqExpr{
					pos: position{line: 885, col: 5, offset: 26797},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 885, col: 5, offset: 26797},
							label: "multiplier",
							expr: &zeroOrOneExpr{
								pos: position{line: 885, col: 16, offset: 26808},
								expr: &actionExpr{
									pos: position{line: 886, col: 9, offset: 26818},
									run: (*parser).callonTableCellFormat5,
									expr: &seqExpr{
										pos: position{line: 886, col: 9, offset: 26818},
										exprs: []any{
											&labeledExpr{
												pos:   position{line: 886, col: 9, offset: 26818},
												label: "multiplier",
												expr: &actionExpr{
													pos: position{line: 886, col: 21, offset: 26830},
													run: (*parser).callonTableCellFormat8,
													expr: &seqExpr{
														pos: position{line: 886, col: 21, offset: 26830},
														exprs: []any{
															&charClassMatcher{
																pos:        position{line: 886, col: 21, offset: 26830},
																val:        "[1-9]",
																ranges:     []rune{'1', '9'},
																ignoreCase: false,
																inverted:   false,
															},
															&zeroOrMoreExpr{
																pos: position{line: 886, col: 26, offset: 26835},
																expr: &charClassMatcher{
																	pos:        position{line: 886, col: 26, offset: 26835},
																	val:        "[0-9]",
																	ranges:     []rune{'0', '9'},
																	ignoreCase: false,
																	inverted:   false,
																},
															},
														},
													},
												},
											},
											&litMatcher{
												pos:        position{line: 886, col: 63, offset: 26872},
												val:        "*",
												ignoreCase: false,
												want:       "\"*\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 890, col: 5, offset: 26954},
							label: "span",
							expr: &zeroOrOneExpr{
								pos: position{line: 890, col: 10, offset: 26959},
								expr: &actionExpr{
									pos: position{line: 891, col: 9, offset: 26969},
									run: (*parser).callonTableCellFormat16,
									expr: &labeledExpr{
										pos:   position{line: 891, col: 9, offset: 26969},
										label: "span",
										expr: &ruleRefExpr{
											pos:    position{line: 891, col: 15, offset: 26975},
											offset: 160,
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 895, col: 5, offset: 27046},
							label: "horizontalAlign",
							expr: &zeroOrOneExpr{
								pos: position{line: 895, col: 21, offset: 27062},
								expr: &choiceExpr{
									pos: position{line: 896, col: 9, offset: 27072},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 896, col: 9, offset: 27072},
											run: (*parser).callonTableCellFormat22,
											expr: &litMatcher{
												pos:        position{line: 896, col: 9, offset: 27072},
												val:        "<",
												ignoreCase: false,
												want:       "\"<\"",
											},
										},
										&actionExpr{
											pos: position{line: 897, col: 11, offset: 27140},
											run: (*parser).callonTableCellFormat24,
											expr: &litMatcher{
												pos:        position{line: 897, col: 11, offset: 27140},
												val:        ">",
												ignoreCase: false,
												want:       "\">\"",
											},
										},
										&actionExpr{
											pos: position{line: 898, col: 11, offset: 27209},
											run: (*parser).callonTableCellFormat26,
											expr: &litMatcher{
												pos:        position{line: 898, col: 11, offset: 27209},
												val:        "^",
												ignoreCase: false,
												want:       "\"^\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 900, col: 5, offset: 27281},
							label: "verticalAlign",
							expr: &zeroOrOneExpr{
								pos: position{line: 900, col: 19, offset: 27295},
								expr: &choiceExpr{
									pos: position{line: 901, col: 9, offset: 27305},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 901, col: 9, offset: 27305},
											run: (*parser).callonTableCellFormat31,
											expr: &litMatcher{
												pos:        position{line: 901, col: 9, offset: 27305},
												val:        ".<",
												ignoreCase: false,
												want:       "\".<\"",
											},
										},
										&actionExpr{
											pos: position{line: 902, col: 11, offset: 27371},
											run: (*parser).callonTableCellFormat33,
											expr: &litMatcher{
												pos:        position{line: 902, col: 11, offset: 27371},
												val:        ".>",
												ignoreCase: false,
												want:       "\".>\"",
											},
										},
										&actionExpr{
											pos: position{line: 903, col: 11, offset: 27440},
											run: (*parser).callonTableCellFormat35,
											expr: &litMatcher{
												pos:        position{line: 903, col: 11, offset: 27440},
												val:        ".^",
												ignoreCase: false,
												want:       "\".^\"",
											},
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 905, col: 5, offset: 27510},
							label: "style",
							expr: &zeroOrOneExpr{
								pos: position{line: 905, col: 11, offset: 27516},
								expr: &choiceExpr{
									pos: position{line: 906, col: 9, offset: 27526},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 906, col: 9, offset: 27526},
											run: (*parser).callonTableCellFormat40,
											expr: &litMatcher{
												pos:        position{line: 906, col: 9, offset: 27526},
												val:        "a",
												ignoreCase: false,
												want:       "\"a\"",
											},
										},
										&actionExpr{
											pos: position{line: 907, col: 11, offset: 27588},
											run: (*parser).callonTableCellFormat42,
											expr: &litMatcher{
												pos:        position{line: 907, col: 11, offset: 27588},
												val:        "d",
												ignoreCase: false,
												want:       "\"d\"",
											},
										},
										&actionExpr{
											pos: position{line: 908, col: 11, offset: 27649},
											run: (*parser).callonTableCellFormat44,
											expr: &litMatcher{
												pos:        position{line: 908, col: 11, offset: 27649},
												val:        "e",
												ignoreCase: false,
												want:       "\"e\"",
											},
										},
										&actionExpr{
											pos: position{line: 909, col: 11, offset: 27712},
											run: (*parser).callonTableCellFormat46,
											expr: &litMatcher{
												pos:        position{line: 909, col: 11, offset: 27712},
												val:        "h",
												ignoreCase: false,
												want:       "\"h\"",
											},
										},
										&actionExpr{
											pos: position{line: 910, col: 11, offset: 27773},
											run: (*parser).callonTableCellFormat48,
											expr: &litMatcher{
												pos:        position{line: 910, col: 11, offset: 27773},
												val:        "l",
												ignoreCase: false,
												want:       "\"l\"",
											},
										},
										&actionExpr{
											pos: position{line: 911, col: 11, offset: 27835},
											run: (*parser).callonTableCellFormat50,
											expr: &litMatcher{
												pos:        position{line: 911, col: 11, offset: 27835},
												val:        "m",
												ignoreCase: false,
												want:       "\"m\"",
											},
										},
										&actionExpr{
											pos: position{line: 912, col: 11, offset: 27899},
											run: (*parser).callonTableCellFormat52,
											expr: &litMatcher{
												pos:        position{line: 912, col: 11, offset: 27899},
												val:        "s",
												ignoreCase: false,
												want:       "\"s\"",
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 914, col: 6, offset: 27962},
							run: (*parser).callonTableCellFormat54,
						},
					},
				},
			},
		},
		{
			name: "URLScheme",
			pos:  position{line: 931, col: 1, offset: 28567},
			expr: &choiceExpr{
				pos: position{line: 931, col: 14, offset: 28580},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 931, col: 14, offset: 28580},
						val:        "https://",
						ignoreCase: false,
						want:       "\"https://\"",
					},
					&litMatcher{
						pos:        position{line: 931, col: 27, offset: 28593},
						val:        "http://",
						ignoreCase: false,
						want:       "\"http://\"",
					},
					&litMatcher{
						pos:        position{line: 931, col: 39, offset: 28605},
						val:        "ftp://",
						ignoreCase: false,
						want:       "\"ftp://\"",
					},
					&litMatcher{
						pos:        position{line: 931, col: 50, offset: 28616},
						val:        "irc://",
						ignoreCase: false,
						want:       "\"irc://\"",
					},
					&litMatcher{
						pos:        position{line: 931, col: 61, offset: 28627},
						val:        "mailto:",
						ignoreCase: false,
						want:       "\"mailto:\"",
					},
				},
			},
		},
		{
			name: "URL",
			pos:  position{line: 933, col: 1, offset: 28640},
			expr: &actionExpr{
				pos: position{line: 933, col: 7, offset: 28646},
				run: (*parser).callonURL1,
				expr: &seqExpr{
					pos: position{line: 933, col: 7, offset: 28646},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 933, col: 7, offset: 28646},
							label: "scheme",
							expr: &zeroOrOneExpr{
								pos: position{line: 933, col: 14, offset: 28653},
								expr: &ruleRefExpr{
									pos:    position{line: 933, col: 15, offset: 28654},
									offset: 162,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 933, col: 27, offset: 28666},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 933, col: 33, offset: 28672},
								offset: 165,
							},
						},
					},
				},
			},
		},
		{
			name: "FullURL",
			pos:  position{line: 937, col: 1, offset: 28770},
			expr: &actionExpr{
				pos: position{line: 937, col: 11, offset: 28780},
				run: (*parser).callonFullURL1,
				expr: &seqExpr{
					pos: position{line: 937, col: 11, offset: 28780},
					exprs: []any{
						&notExpr{
							pos: position{line: 937, col: 11, offset: 28780},
							expr: &litMatcher{
								pos:        position{line: 937, col: 12, offset: 28781},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 937, col: 16, offset: 28785},
							label: "scheme",
							expr: &ruleRefExpr{
								pos:    position{line: 937, col: 24, offset: 28793},
								offset: 162,
							},
						},
						&labeledExpr{
							pos:   position{line: 937, col: 35, offset: 28804},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 937, col: 41, offset: 28810},
								offset: 165,
							},
						},
					},
				},
			},
		},
		{
			name: "Path",
			pos:  position{line: 944, col: 1, offset: 28911},
			expr: &actionExpr{
				pos: position{line: 944, col: 8, offset: 28918},
				run: (*parser).callonPath1,
				expr: &seqExpr{
					pos: position{line: 944, col: 8, offset: 28918},
					exprs: []any{
						&notExpr{
							pos: position{line: 944, col: 8, offset: 28918},
							expr: &litMatcher{
								pos:        position{line: 944, col: 9, offset: 28919},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 944, col: 13, offset: 28923},
							label: "elements",
							expr: &oneOrMoreExpr{
								pos: position{line: 944, col: 24, offset: 28934},
								expr: &ruleRefExpr{
									pos:    position{line: 944, col: 24, offset: 28934},
									offset: 166,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "PathElement",
			pos:  position{line: 948, col: 1, offset: 29005},
			expr: &choiceExpr{
				pos: position{line: 948, col: 16, offset: 29020},
				alternatives: []any{
					&oneOrMoreExpr{
						pos: position{line: 948, col: 16, offset: 29020},
						expr: &charClassMatcher{
							pos:        position{line: 948, col: 17, offset: 29021},
							val:        "[^\\n{.<>!?,;[\\] ]",
							chars:      []rune{'\n', '{', '.', '<', '>', '!', '?', ',', ';', '[', ']', ' '},
							ignoreCase: false,
							inverted:   true,
						},
					},
					&seqExpr{
						pos: position{line: 949, col: 5, offset: 29046},
						exprs: []any{
							&charClassMatcher{
								pos:        position{line: 949, col: 5, offset: 29046},
								val:        "[.?!;,]",
								chars:      []rune{'.', '?', '!', ';', ','},
								ignoreCase: false,
								inverted:   false,
							},
							&andExpr{
								pos: position{line: 949, col: 13, offset: 29054},
								expr: &seqExpr{
									pos: position{line: 949, col: 15, offset: 29056},
									exprs: []any{
										&notExpr{
											pos: position{line: 949, col: 15, offset: 29056},
											expr: &ruleRefExpr{
												pos:    position{line: 949, col: 16, offset: 29057},
												offset: 339,
											},
										},
										&notExpr{
											pos: position{line: 949, col: 18, offset: 29059},
											expr: &ruleRefExpr{
												pos:    position{line: 949, col: 19, offset: 29060},
												offset: 324,
											},
										},
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 950, col: 4, offset: 29075},
						offset: 53,
					},
				},
			},
		},
		{
			name: "Email",
			pos:  position{line: 954, col: 1, offset: 29099},
			expr: &actionExpr{
				pos: position{line: 954, col: 9, offset: 29107},
				run: (*parser).callonEmail1,
				expr: &seqExpr{
					pos: position{line: 954, col: 9, offset: 29107},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 954, col: 9, offset: 29107},
							label: "name",
							expr: &ruleRefExpr{
								pos:    position{line: 954, col: 15, offset: 29113},
								offset: 168,
							},
						},
						&litMatcher{
							pos:        position{line: 954, col: 26, offset: 29124},
							val:        "@",
							ignoreCase: false,
							want:       "\"@\"",
						},
						&labeledExpr{
							pos:   position{line: 954, col: 30, offset: 29128},
							label: "domain",
							expr: &ruleRefExpr{
								pos:    position{line: 954, col: 38, offset: 29136},
								offset: 169,
							},
						},
					},
				},
			},
		},
		{
			name: "EmailName",
			pos:  position{line: 958, col: 1, offset: 29234},
			expr: &actionExpr{
				pos: position{line: 958, col: 13, offset: 29246},
				run: (*parser).callonEmailName1,
				expr: &seqExpr{
					pos: position{line: 958, col: 13, offset: 29246},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 958, col: 13, offset: 29246},
							label: "name",
							expr: &actionExpr{
								pos: position{line: 958, col: 19, offset: 29252},
								run: (*parser).callonEmailName4,
								expr: &oneOrMoreExpr{
									pos: position{line: 958, col: 19, offset: 29252},
									expr: &choiceExpr{
										pos: position{line: 958, col: 20, offset: 29253},
										alternatives: []any{
											&ruleRefExpr{
												pos:    position{line: 958, col: 20, offset: 29253},
												offset: 323,
											},
											&charClassMatcher{
												pos:        position{line: 958, col: 35, offset: 29268},
												val:        "[!#$%&'*+-/=?^_`{|}~.]",
												chars:      []rune{'!', '#', '$', '%', '&', '\'', '*', '=', '?', '^', '_', '`', '{', '|', '}', '~', '.'},
												ranges:     []rune{'+', '/'},
												ignoreCase: false,
												inverted:   false,
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 960, col: 4, offset: 29396},
							run: (*parser).callonEmailName9,
						},
					},
				},
			},
		},
		{
			name: "EmailDomain",
			pos:  position{line: 967, col: 1, offset: 29562},
			expr: &actionExpr{
				pos: position{line: 967, col: 15, offset: 29576},
				run: (*parser).callonEmailDomain1,
				expr: &seqExpr{
					pos: position{line: 967, col: 15, offset: 29576},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 967, col: 15, offset: 29576},
							label: "domain",
							expr: &actionExpr{
								pos: position{line: 967, col: 23, offset: 29584},
								run: (*parser).callonEmailDomain4,
								expr: &seqExpr{
									pos: position{line: 967, col: 24, offset: 29585},
									exprs: []any{
										&oneOrMoreExpr{
											pos: position{line: 967, col: 24, offset: 29585},
											expr: &ruleRefExpr{
												pos:    position{line: 967, col: 25, offset: 29586},
												offset: 323,
											},
										},
										&zeroOrMoreExpr{
											pos: position{line: 967, col: 40, offset: 29601},
											expr: &seqExpr{
												pos: position{line: 967, col: 41, offset: 29602},
												exprs: []any{
													&litMatcher{
														pos:        position{line: 967, col: 41, offset: 29602},
														val:        ".",
														ignoreCase: false,
														want:       "\".\"",
													},
													&oneOrMoreExpr{
														pos: position{line: 967, col: 45, offset: 29606},
														expr: &choiceExpr{
															pos: position{line: 967, col: 46, offset: 29607},
															alternatives: []any{
																&ruleRefExpr{
																	pos:    position{line: 967, col: 46, offset: 29607},
																	offset: 323,
																},
																&litMatcher{
																	pos:        position{line: 967, col: 61, offset: 29622},
																	val:        "-",
																	ignoreCase: false,
																	want:       "\"-\"",
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 969, col: 4, offset: 29667},
							run: (*parser).callonEmailDomain15,
						},
					},
				},
			},
		},
		{
			name: "Listing",
			pos:  position{line: 977, col: 1, offset: 29809},
			expr: &actionExpr{
				pos: position{line: 978, col: 5, offset: 29823},
				run: (*parser).callonListing1,
				expr: &seqExpr{
					pos: position{line: 978, col: 5, offset: 29823},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 978, col: 5, offset: 29823},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 978, col: 12, offset: 29830},
								offset: 171,
							},
						},
						&labeledExpr{
							pos:   position{line: 979, col: 5, offset: 29848},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 979, col: 11, offset: 29854},
								expr: &ruleRefExpr{
									pos:    position{line: 979, col: 12, offset: 29855},
									offset: 175,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 980, col: 5, offset: 29873},
							offset: 172,
						},
					},
				},
			},
		},
		{
			name: "ListingStart",
			pos:  position{line: 984, col: 1, offset: 30031},
			expr: &actionExpr{
				pos: position{line: 984, col: 16, offset: 30046},
				run: (*parser).callonListingStart1,
				expr: &seqExpr{
					pos: position{line: 984, col: 16, offset: 30046},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 984, col: 16, offset: 30046},
							offset: 327,
						},
						&labeledExpr{
							pos:   position{line: 984, col: 32, offset: 30062},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 984, col: 42, offset: 30072},
								offset: 174,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 984, col: 59, offset: 30089},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 984, col: 69, offset: 30099},
							run: (*parser).callonListingStart7,
						},
					},
				},
			},
		},
		{
			name: "ListingEnd",
			pos:  position{line: 991, col: 1, offset: 30276},
			expr: &seqExpr{
				pos: position{line: 991, col: 14, offset: 30289},
				exprs: []any{
					&ruleRefExpr{
						pos:    position{line: 991, col: 14, offset: 30289},
						offset: 327,
					},
					&labeledExpr{
						pos:   position{line: 991, col: 30, offset: 30305},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 991, col: 40, offset: 30315},
							offset: 174,
						},
					},
					&andExpr{
						pos: position{line: 991, col: 57, offset: 30332},
						expr: &ruleRefExpr{
							pos:    position{line: 991, col: 58, offset: 30333},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 991, col: 68, offset: 30343},
						run: (*parser).callonListingEnd7,
					},
				},
			},
		},
		{
			name: "ListingHyphens",
			pos:  position{line: 1000, col: 1, offset: 30603},
			expr: &actionExpr{
				pos: position{line: 1000, col: 18, offset: 30620},
				run: (*parser).callonListingHyphens1,
				expr: &seqExpr{
					pos: position{line: 1000, col: 18, offset: 30620},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1000, col: 18, offset: 30620},
							label: "hyphens",
							expr: &seqExpr{
								pos: position{line: 1000, col: 27, offset: 30629},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1000, col: 27, offset: 30629},
										val:        "----",
										ignoreCase: false,
										want:       "\"----\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1000, col: 34, offset: 30636},
										expr: &litMatcher{
											pos:        position{line: 1000, col: 34, offset: 30636},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1000, col: 40, offset: 30642},
							run: (*parser).callonListingHyphens8,
						},
					},
				},
			},
		},
		{
			name: "ListingDelimiter",
			pos:  position{line: 1007, col: 1, offset: 30761},
			expr: &actionExpr{
				pos: position{line: 1007, col: 20, offset: 30780},
				run: (*parser).callonListingDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1007, col: 20, offset: 30780},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1007, col: 20, offset: 30780},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:    position{line: 1007, col: 29, offset: 30789},
								offset: 173,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1008, col: 5, offset: 30810},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "ListingLine",
			pos:  position{line: 1013, col: 1, offset: 30937},
			expr: &actionExpr{
				pos: position{line: 1013, col: 15, offset: 30951},
				run: (*parser).callonListingLine1,
				expr: &seqExpr{
					pos: position{line: 1013, col: 16, offset: 30952},
					exprs: []any{
						&notExpr{
							pos: position{line: 1013, col: 16, offset: 30952},
							expr: &ruleRefExpr{
								pos:    position{line: 1013, col: 17, offset: 30953},
								offset: 174,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1013, col: 34, offset: 30970},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 1013, col: 47, offset: 30983},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 1013, col: 52, offset: 30988},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1013, col: 60, offset: 30996},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "Open",
			pos:  position{line: 1017, col: 1, offset: 31047},
			expr: &actionExpr{
				pos: position{line: 1018, col: 5, offset: 31058},
				run: (*parser).callonOpen1,
				expr: &seqExpr{
					pos: position{line: 1018, col: 5, offset: 31058},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1018, col: 5, offset: 31058},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1018, col: 12, offset: 31065},
								offset: 177,
							},
						},
						&labeledExpr{
							pos:   position{line: 1019, col: 5, offset: 31080},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1019, col: 11, offset: 31086},
								expr: &seqExpr{
									pos: position{line: 1019, col: 12, offset: 31087},
									exprs: []any{
										&notExpr{
											pos: position{line: 1019, col: 12, offset: 31087},
											expr: &ruleRefExpr{
												pos:    position{line: 1019, col: 13, offset: 31088},
												offset: 180,
											},
										},
										&ruleRefExpr{
											pos:    position{line: 1019, col: 27, offset: 31102},
											offset: 1,
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1020, col: 5, offset: 31116},
							offset: 178,
						},
					},
				},
			},
		},
		{
			name: "OpenStart",
			pos:  position{line: 1024, col: 1, offset: 31265},
			expr: &actionExpr{
				pos: position{line: 1024, col: 13, offset: 31277},
				run: (*parser).callonOpenStart1,
				expr: &seqExpr{
					pos: position{line: 1024, col: 13, offset: 31277},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1024, col: 13, offset: 31277},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1024, col: 23, offset: 31287},
								offset: 180,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1024, col: 37, offset: 31301},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1024, col: 47, offset: 31311},
							run: (*parser).callonOpenStart6,
						},
					},
				},
			},
		},
		{
			name: "OpenEnd",
			pos:  position{line: 1031, col: 1, offset: 31485},
			expr: &seqExpr{
				pos: position{line: 1031, col: 11, offset: 31495},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1031, col: 11, offset: 31495},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1031, col: 21, offset: 31505},
							offset: 180,
						},
					},
					&andExpr{
						pos: position{line: 1031, col: 35, offset: 31519},
						expr: &ruleRefExpr{
							pos:    position{line: 1031, col: 36, offset: 31520},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1031, col: 46, offset: 31530},
						run: (*parser).callonOpenEnd6,
					},
				},
			},
		},
		{
			name: "OpenEquals",
			pos:  position{line: 1040, col: 1, offset: 31784},
			expr: &actionExpr{
				pos: position{line: 1040, col: 14, offset: 31797},
				run: (*parser).callonOpenEquals1,
				expr: &labeledExpr{
					pos:   position{line: 1040, col: 14, offset: 31797},
					label: "hyphens",
					expr: &litMatcher{
						pos:        position{line: 1040, col: 23, offset: 31806},
						val:        "--",
						ignoreCase: false,
						want:       "\"--\"",
					},
				},
			},
		},
		{
			name: "OpenDelimiter",
			pos:  position{line: 1045, col: 1, offset: 31862},
			expr: &actionExpr{
				pos: position{line: 1045, col: 17, offset: 31878},
				run: (*parser).callonOpenDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1045, col: 17, offset: 31878},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1045, col: 17, offset: 31878},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:    position{line: 1045, col: 26, offset: 31887},
								offset: 179,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1046, col: 5, offset: 31904},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "MarkedText",
			pos:  position{line: 1052, col: 1, offset: 32037},
			expr: &choiceExpr{
				pos: position{line: 1052, col: 15, offset: 32051},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1052, col: 15, offset: 32051},
						offset: 182,
					},
					&ruleRefExpr{
						pos:    position{line: 1052, col: 34, offset: 32070},
						offset: 185,
					},
				},
			},
		},
		{
			name: "SingleMarkedText",
			pos:  position{line: 1054, col: 1, offset: 32089},
			expr: &actionExpr{
				pos: position{line: 1054, col: 20, offset: 32108},
				run: (*parser).callonSingleMarkedText1,
				expr: &seqExpr{
					pos: position{line: 1054, col: 20, offset: 32108},
					exprs: []any{
						&notExpr{
							pos: position{line: 1054, col: 20, offset: 32108},
							expr: &ruleRefExpr{
								pos:    position{line: 1054, col: 21, offset: 32109},
								offset: 340,
							},
						},
						&litMatcher{
							pos:        position{line: 1054, col: 28, offset: 32116},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&andExpr{
							pos: position{line: 1054, col: 32, offset: 32120},
							expr: &notExpr{
								pos: position{line: 1054, col: 34, offset: 32122},
								expr: &litMatcher{
									pos:        position{line: 1054, col: 35, offset: 32123},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1054, col: 40, offset: 32128},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1054, col: 47, offset: 32135},
								offset: 183,
							},
						},
						&litMatcher{
							pos:        position{line: 1054, col: 70, offset: 32158},
							val:        "#",
							ignoreCase: false,
							want:       "\"#\"",
						},
						&notExpr{
							pos: position{line: 1054, col: 74, offset: 32162},
							expr: &litMatcher{
								pos:        position{line: 1054, col: 75, offset: 32163},
								val:        "#",
								ignoreCase: false,
								want:       "\"#\"",
							},
						},
						&andExpr{
							pos: position{line: 1054, col: 79, offset: 32167},
							expr: &notExpr{
								pos: position{line: 1054, col: 81, offset: 32169},
								expr: &ruleRefExpr{
									pos:    position{line: 1054, col: 82, offset: 32170},
									offset: 323,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMarkedTextValue",
			pos:  position{line: 1058, col: 1, offset: 32215},
			expr: &actionExpr{
				pos: position{line: 1058, col: 25, offset: 32239},
				run: (*parser).callonSingleMarkedTextValue1,
				expr: &seqExpr{
					pos: position{line: 1058, col: 25, offset: 32239},
					exprs: []any{
						&notExpr{
							pos: position{line: 1058, col: 25, offset: 32239},
							expr: &ruleRefExpr{
								pos:    position{line: 1058, col: 26, offset: 32240},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 1058, col: 28, offset: 32242},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1058, col: 34, offset: 32248},
								expr: &actionExpr{
									pos: position{line: 1058, col: 35, offset: 32249},
									run: (*parser).callonSingleMarkedTextValue7,
									expr: &seqExpr{
										pos: position{line: 1058, col: 35, offset: 32249},
										exprs: []any{
											&notExpr{
												pos: position{line: 1058, col: 35, offset: 32249},
												expr: &ruleRefExpr{
													pos:    position{line: 1058, col: 36, offset: 32250},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 1058, col: 38, offset: 32252},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1058, col: 44, offset: 32258},
													expr: &ruleRefExpr{
														pos:    position{line: 1058, col: 45, offset: 32259},
														offset: 184,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SingleMarkedTextElement",
			pos:  position{line: 1062, col: 1, offset: 32413},
			expr: &seqExpr{
				pos: position{line: 1062, col: 27, offset: 32439},
				exprs: []any{
					&notExpr{
						pos: position{line: 1062, col: 27, offset: 32439},
						expr: &seqExpr{
							pos: position{line: 1062, col: 29, offset: 32441},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1062, col: 29, offset: 32441},
									val:        "#",
									ignoreCase: false,
									want:       "\"#\"",
								},
								&notExpr{
									pos: position{line: 1062, col: 33, offset: 32445},
									expr: &litMatcher{
										pos:        position{line: 1062, col: 34, offset: 32446},
										val:        "#",
										ignoreCase: false,
										want:       "\"#\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 1062, col: 39, offset: 32451},
						offset: 96,
					},
				},
			},
		},
		{
			name: "DoubleMarkedText",
			pos:  position{line: 1064, col: 1, offset: 32473},
			expr: &actionExpr{
				pos: position{line: 1064, col: 20, offset: 32492},
				run: (*parser).callonDoubleMarkedText1,
				expr: &seqExpr{
					pos: position{line: 1064, col: 20, offset: 32492},
					exprs: []any{
						&notExpr{
							pos: position{line: 1064, col: 20, offset: 32492},
							expr: &ruleRefExpr{
								pos:    position{line: 1064, col: 21, offset: 32493},
								offset: 341,
							},
						},
						&litMatcher{
							pos:        position{line: 1064, col: 34, offset: 32506},
							val:        "##",
							ignoreCase: false,
							want:       "\"##\"",
						},
						&labeledExpr{
							pos:   position{line: 1064, col: 39, offset: 32511},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1064, col: 46, offset: 32518},
								offset: 186,
							},
						},
						&litMatcher{
							pos:        position{line: 1064, col: 69, offset: 32541},
							val:        "##",
							ignoreCase: false,
							want:       "\"##\"",
						},
					},
				},
			},
		},
		{
			name: "DoubleMarkedTextValue",
			pos:  position{line: 1068, col: 1, offset: 32578},
			expr: &actionExpr{
				pos: position{line: 1068, col: 25, offset: 32602},
				run: (*parser).callonDoubleMarkedTextValue1,
				expr: &seqExpr{
					pos: position{line: 1068, col: 25, offset: 32602},
					exprs: []any{
						&notExpr{
							pos: position{line: 1068, col: 25, offset: 32602},
							expr: &ruleRefExpr{
								pos:    position{line: 1068, col: 26, offset: 32603},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 1068, col: 28, offset: 32605},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1068, col: 34, offset: 32611},
								expr: &actionExpr{
									pos: position{line: 1068, col: 35, offset: 32612},
									run: (*parser).callonDoubleMarkedTextValue7,
									expr: &seqExpr{
										pos: position{line: 1068, col: 35, offset: 32612},
										exprs: []any{
											&notExpr{
												pos: position{line: 1068, col: 35, offset: 32612},
												expr: &ruleRefExpr{
													pos:    position{line: 1068, col: 36, offset: 32613},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 1068, col: 38, offset: 32615},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1068, col: 44, offset: 32621},
													expr: &ruleRefExpr{
														pos:    position{line: 1068, col: 45, offset: 32622},
														offset: 187,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoubleMarkedTextElement",
			pos:  position{line: 1072, col: 1, offset: 32788},
			expr: &seqExpr{
				pos: position{line: 1072, col: 27, offset: 32814},
				exprs: []any{
					&notExpr{
						pos: position{line: 1072, col: 27, offset: 32814},
						expr: &litMatcher{
							pos:        position{line: 1072, col: 29, offset: 32816},
							val:        "##",
							ignoreCase: false,
							want:       "\"##\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 1072, col: 35, offset: 32822},
						offset: 96,
					},
				},
			},
		},
		{
			name: "Example",
			pos:  position{line: 1075, col: 1, offset: 32845},
			expr: &actionExpr{
				pos: position{line: 1076, col: 5, offset: 32859},
				run: (*parser).callonExample1,
				expr: &seqExpr{
					pos: position{line: 1076, col: 5, offset: 32859},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1076, col: 5, offset: 32859},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1076, col: 12, offset: 32866},
								offset: 189,
							},
						},
						&labeledExpr{
							pos:   position{line: 1077, col: 5, offset: 32884},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1077, col: 11, offset: 32890},
								expr: &seqExpr{
									pos: position{line: 1077, col: 12, offset: 32891},
									exprs: []any{
										&notExpr{
											pos: position{line: 1077, col: 12, offset: 32891},
											expr: &ruleRefExpr{
												pos:    position{line: 1077, col: 13, offset: 32892},
												offset: 192,
											},
										},
										&ruleRefExpr{
											pos:    position{line: 1077, col: 30, offset: 32909},
											offset: 1,
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1078, col: 5, offset: 32923},
							offset: 190,
						},
					},
				},
			},
		},
		{
			name: "ExampleStart",
			pos:  position{line: 1082, col: 1, offset: 33081},
			expr: &actionExpr{
				pos: position{line: 1082, col: 16, offset: 33096},
				run: (*parser).callonExampleStart1,
				expr: &seqExpr{
					pos: position{line: 1082, col: 16, offset: 33096},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1082, col: 16, offset: 33096},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1082, col: 26, offset: 33106},
								offset: 192,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1082, col: 43, offset: 33123},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1082, col: 53, offset: 33133},
							run: (*parser).callonExampleStart6,
						},
					},
				},
			},
		},
		{
			name: "ExampleEnd",
			pos:  position{line: 1089, col: 1, offset: 33318},
			expr: &seqExpr{
				pos: position{line: 1089, col: 14, offset: 33331},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1089, col: 14, offset: 33331},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1089, col: 24, offset: 33341},
							offset: 192,
						},
					},
					&andExpr{
						pos: position{line: 1089, col: 41, offset: 33358},
						expr: &ruleRefExpr{
							pos:    position{line: 1089, col: 42, offset: 33359},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1089, col: 52, offset: 33369},
						run: (*parser).callonExampleEnd6,
					},
				},
			},
		},
		{
			name: "ExampleEquals",
			pos:  position{line: 1098, col: 1, offset: 33637},
			expr: &actionExpr{
				pos: position{line: 1098, col: 17, offset: 33653},
				run: (*parser).callonExampleEquals1,
				expr: &seqExpr{
					pos: position{line: 1098, col: 17, offset: 33653},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1098, col: 17, offset: 33653},
							label: "hyphens",
							expr: &seqExpr{
								pos: position{line: 1098, col: 26, offset: 33662},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1098, col: 26, offset: 33662},
										val:        "====",
										ignoreCase: false,
										want:       "\"====\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1098, col: 33, offset: 33669},
										expr: &litMatcher{
											pos:        position{line: 1098, col: 33, offset: 33669},
											val:        "=",
											ignoreCase: false,
											want:       "\"=\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1098, col: 39, offset: 33675},
							run: (*parser).callonExampleEquals8,
						},
					},
				},
			},
		},
		{
			name: "ExampleDelimiter",
			pos:  position{line: 1105, col: 1, offset: 33798},
			expr: &actionExpr{
				pos: position{line: 1105, col: 20, offset: 33817},
				run: (*parser).callonExampleDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1105, col: 20, offset: 33817},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1105, col: 20, offset: 33817},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:    position{line: 1105, col: 29, offset: 33826},
								offset: 191,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1106, col: 5, offset: 33846},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "ExampleLine",
			pos:  position{line: 1111, col: 1, offset: 33977},
			expr: &actionExpr{
				pos: position{line: 1111, col: 15, offset: 33991},
				run: (*parser).callonExampleLine1,
				expr: &seqExpr{
					pos: position{line: 1111, col: 16, offset: 33992},
					exprs: []any{
						&notExpr{
							pos: position{line: 1111, col: 16, offset: 33992},
							expr: &ruleRefExpr{
								pos:    position{line: 1111, col: 17, offset: 33993},
								offset: 192,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1111, col: 34, offset: 34010},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 1111, col: 47, offset: 34023},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 1111, col: 52, offset: 34028},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1111, col: 60, offset: 34036},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "Literal",
			pos:  position{line: 1117, col: 1, offset: 34085},
			expr: &actionExpr{
				pos: position{line: 1118, col: 5, offset: 34099},
				run: (*parser).callonLiteral1,
				expr: &seqExpr{
					pos: position{line: 1118, col: 5, offset: 34099},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1118, col: 5, offset: 34099},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1118, col: 12, offset: 34106},
								offset: 195,
							},
						},
						&labeledExpr{
							pos:   position{line: 1119, col: 5, offset: 34124},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1119, col: 11, offset: 34130},
								expr: &ruleRefExpr{
									pos:    position{line: 1119, col: 12, offset: 34131},
									offset: 199,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1120, col: 5, offset: 34149},
							offset: 196,
						},
					},
				},
			},
		},
		{
			name: "LiteralStart",
			pos:  position{line: 1124, col: 1, offset: 34316},
			expr: &actionExpr{
				pos: position{line: 1124, col: 16, offset: 34331},
				run: (*parser).callonLiteralStart1,
				expr: &seqExpr{
					pos: position{line: 1124, col: 16, offset: 34331},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1124, col: 16, offset: 34331},
							offset: 327,
						},
						&labeledExpr{
							pos:   position{line: 1124, col: 32, offset: 34347},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1124, col: 42, offset: 34357},
								offset: 198,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1124, col: 59, offset: 34374},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1124, col: 69, offset: 34384},
							run: (*parser).callonLiteralStart7,
						},
					},
				},
			},
		},
		{
			name: "LiteralEnd",
			pos:  position{line: 1131, col: 1, offset: 34561},
			expr: &seqExpr{
				pos: position{line: 1131, col: 14, offset: 34574},
				exprs: []any{
					&ruleRefExpr{
						pos:    position{line: 1131, col: 14, offset: 34574},
						offset: 327,
					},
					&labeledExpr{
						pos:   position{line: 1131, col: 30, offset: 34590},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1131, col: 40, offset: 34600},
							offset: 198,
						},
					},
					&andExpr{
						pos: position{line: 1131, col: 57, offset: 34617},
						expr: &ruleRefExpr{
							pos:    position{line: 1131, col: 58, offset: 34618},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1131, col: 68, offset: 34628},
						run: (*parser).callonLiteralEnd7,
					},
				},
			},
		},
		{
			name: "LiteralDots",
			pos:  position{line: 1140, col: 1, offset: 34888},
			expr: &actionExpr{
				pos: position{line: 1140, col: 15, offset: 34902},
				run: (*parser).callonLiteralDots1,
				expr: &seqExpr{
					pos: position{line: 1140, col: 15, offset: 34902},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1140, col: 15, offset: 34902},
							label: "dots",
							expr: &seqExpr{
								pos: position{line: 1140, col: 21, offset: 34908},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1140, col: 21, offset: 34908},
										val:        "....",
										ignoreCase: false,
										want:       "\"....\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1140, col: 28, offset: 34915},
										expr: &litMatcher{
											pos:        position{line: 1140, col: 28, offset: 34915},
											val:        ".",
											ignoreCase: false,
											want:       "\".\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1140, col: 34, offset: 34921},
							run: (*parser).callonLiteralDots8,
						},
					},
				},
			},
		},
		{
			name: "LiteralDelimiter",
			pos:  position{line: 1147, col: 1, offset: 35034},
			expr: &actionExpr{
				pos: position{line: 1147, col: 20, offset: 35053},
				run: (*parser).callonLiteralDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1147, col: 20, offset: 35053},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1147, col: 20, offset: 35053},
							label: "dots",
							expr: &ruleRefExpr{
								pos:    position{line: 1147, col: 26, offset: 35059},
								offset: 197,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1148, col: 5, offset: 35077},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "LiteralLine",
			pos:  position{line: 1153, col: 1, offset: 35201},
			expr: &actionExpr{
				pos: position{line: 1153, col: 15, offset: 35215},
				run: (*parser).callonLiteralLine1,
				expr: &seqExpr{
					pos: position{line: 1153, col: 16, offset: 35216},
					exprs: []any{
						&notExpr{
							pos: position{line: 1153, col: 16, offset: 35216},
							expr: &ruleRefExpr{
								pos:    position{line: 1153, col: 17, offset: 35217},
								offset: 198,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1153, col: 34, offset: 35234},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 1153, col: 47, offset: 35247},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 1153, col: 52, offset: 35252},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1153, col: 60, offset: 35260},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "Sidebar",
			pos:  position{line: 1157, col: 1, offset: 35307},
			expr: &actionExpr{
				pos: position{line: 1158, col: 5, offset: 35321},
				run: (*parser).callonSidebar1,
				expr: &seqExpr{
					pos: position{line: 1158, col: 5, offset: 35321},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1158, col: 5, offset: 35321},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1158, col: 12, offset: 35328},
								offset: 201,
							},
						},
						&labeledExpr{
							pos:   position{line: 1159, col: 5, offset: 35346},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1159, col: 11, offset: 35352},
								expr: &seqExpr{
									pos: position{line: 1159, col: 12, offset: 35353},
									exprs: []any{
										&notExpr{
											pos: position{line: 1159, col: 12, offset: 35353},
											expr: &ruleRefExpr{
												pos:    position{line: 1159, col: 13, offset: 35354},
												offset: 204,
											},
										},
										&ruleRefExpr{
											pos:    position{line: 1159, col: 30, offset: 35371},
											offset: 1,
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1160, col: 5, offset: 35385},
							offset: 202,
						},
					},
				},
			},
		},
		{
			name: "SidebarStart",
			pos:  position{line: 1164, col: 1, offset: 35543},
			expr: &actionExpr{
				pos: position{line: 1164, col: 16, offset: 35558},
				run: (*parser).callonSidebarStart1,
				expr: &seqExpr{
					pos: position{line: 1164, col: 16, offset: 35558},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1164, col: 16, offset: 35558},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1164, col: 26, offset: 35568},
								offset: 204,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1164, col: 43, offset: 35585},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1164, col: 53, offset: 35595},
							run: (*parser).callonSidebarStart6,
						},
					},
				},
			},
		},
		{
			name: "SidebarEnd",
			pos:  position{line: 1171, col: 1, offset: 35772},
			expr: &seqExpr{
				pos: position{line: 1171, col: 14, offset: 35785},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1171, col: 14, offset: 35785},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1171, col: 24, offset: 35795},
							offset: 204,
						},
					},
					&andExpr{
						pos: position{line: 1171, col: 41, offset: 35812},
						expr: &ruleRefExpr{
							pos:    position{line: 1171, col: 42, offset: 35813},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1171, col: 52, offset: 35823},
						run: (*parser).callonSidebarEnd6,
					},
				},
			},
		},
		{
			name: "SidebarAsterisks",
			pos:  position{line: 1180, col: 1, offset: 36083},
			expr: &actionExpr{
				pos: position{line: 1180, col: 20, offset: 36102},
				run: (*parser).callonSidebarAsterisks1,
				expr: &seqExpr{
					pos: position{line: 1180, col: 20, offset: 36102},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1180, col: 20, offset: 36102},
							label: "asterisks",
							expr: &seqExpr{
								pos: position{line: 1180, col: 31, offset: 36113},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1180, col: 31, offset: 36113},
										val:        "****",
										ignoreCase: false,
										want:       "\"****\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1180, col: 38, offset: 36120},
										expr: &litMatcher{
											pos:        position{line: 1180, col: 38, offset: 36120},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1180, col: 44, offset: 36126},
							run: (*parser).callonSidebarAsterisks8,
						},
					},
				},
			},
		},
		{
			name: "SidebarDelimiter",
			pos:  position{line: 1187, col: 1, offset: 36249},
			expr: &actionExpr{
				pos: position{line: 1187, col: 20, offset: 36268},
				run: (*parser).callonSidebarDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1187, col: 20, offset: 36268},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1187, col: 20, offset: 36268},
							label: "asterisks",
							expr: &ruleRefExpr{
								pos:    position{line: 1187, col: 31, offset: 36279},
								offset: 203,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1188, col: 5, offset: 36302},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "PreParse",
			pos:  position{line: 1194, col: 1, offset: 36432},
			expr: &actionExpr{
				pos: position{line: 1194, col: 12, offset: 36443},
				run: (*parser).callonPreParse1,
				expr: &seqExpr{
					pos: position{line: 1194, col: 12, offset: 36443},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1194, col: 12, offset: 36443},
							label: "content",
							expr: &oneOrMoreExpr{
								pos: position{line: 1194, col: 20, offset: 36451},
								expr: &ruleRefExpr{
									pos:    position{line: 1194, col: 21, offset: 36452},
									offset: 206,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1194, col: 39, offset: 36470},
							offset: 324,
						},
					},
				},
			},
		},
		{
			name: "PreParseElement",
			pos:  position{line: 1198, col: 1, offset: 36527},
			expr: &actionExpr{
				pos: position{line: 1198, col: 19, offset: 36545},
				run: (*parser).callonPreParseElement1,
				expr: &seqExpr{
					pos: position{line: 1198, col: 19, offset: 36545},
					exprs: []any{
						&notExpr{
							pos: position{line: 1198, col: 19, offset: 36545},
							expr: &ruleRefExpr{
								pos:    position{line: 1198, col: 20, offset: 36546},
								offset: 324,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1198, col: 30, offset: 36556},
							offset: 327,
						},
						&labeledExpr{
							pos:   position{line: 1198, col: 46, offset: 36572},
							label: "element",
							expr: &choiceExpr{
								pos: position{line: 1198, col: 55, offset: 36581},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 1198, col: 55, offset: 36581},
										offset: 209,
									},
									&ruleRefExpr{
										pos:    position{line: 1198, col: 68, offset: 36594},
										offset: 210,
									},
									&ruleRefExpr{
										pos:    position{line: 1198, col: 82, offset: 36608},
										offset: 211,
									},
									&ruleRefExpr{
										pos:    position{line: 1198, col: 96, offset: 36622},
										offset: 22,
									},
									&ruleRefExpr{
										pos:    position{line: 1198, col: 113, offset: 36639},
										offset: 26,
									},
									&ruleRefExpr{
										pos:    position{line: 1198, col: 130, offset: 36656},
										offset: 102,
									},
									&ruleRefExpr{
										pos:    position{line: 1198, col: 144, offset: 36670},
										offset: 207,
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1198, col: 158, offset: 36684},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "PreParseLine",
			pos:  position{line: 1202, col: 1, offset: 36723},
			expr: &actionExpr{
				pos: position{line: 1202, col: 16, offset: 36738},
				run: (*parser).callonPreParseLine1,
				expr: &seqExpr{
					pos: position{line: 1202, col: 16, offset: 36738},
					exprs: []any{
						&notExpr{
							pos: position{line: 1202, col: 16, offset: 36738},
							expr: &ruleRefExpr{
								pos:    position{line: 1202, col: 17, offset: 36739},
								offset: 296,
							},
						},
						&labeledExpr{
							pos:   position{line: 1202, col: 35, offset: 36757},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1202, col: 43, offset: 36765},
								expr: &ruleRefExpr{
									pos:    position{line: 1202, col: 43, offset: 36765},
									offset: 208,
								},
							},
						},
						&andExpr{
							pos: position{line: 1202, col: 64, offset: 36786},
							expr: &ruleRefExpr{
								pos:    position{line: 1202, col: 65, offset: 36787},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "PreParseLineElement",
			pos:  position{line: 1206, col: 1, offset: 36874},
			expr: &choiceExpr{
				pos: position{line: 1207, col: 4, offset: 36901},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1207, col: 4, offset: 36901},
						offset: 53,
					},
					&oneOrMoreExpr{
						pos: position{line: 1209, col: 6, offset: 36932},
						expr: &charClassMatcher{
							pos:        position{line: 1209, col: 6, offset: 36932},
							val:        "[^\\r\\n{]",
							chars:      []rune{'\r', '\n', '{'},
							ignoreCase: false,
							inverted:   true,
						},
					},
					&litMatcher{
						pos:        position{line: 1210, col: 7, offset: 36950},
						val:        "{",
						ignoreCase: false,
						want:       "\"{\"",
					},
				},
			},
		},
		{
			name: "IfDefBlock",
			pos:  position{line: 1213, col: 1, offset: 36958},
			expr: &actionExpr{
				pos: position{line: 1213, col: 14, offset: 36971},
				run: (*parser).callonIfDefBlock1,
				expr: &seqExpr{
					pos: position{line: 1213, col: 14, offset: 36971},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1213, col: 14, offset: 36971},
							offset: 290,
						},
						&labeledExpr{
							pos:   position{line: 1213, col: 29, offset: 36986},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 1213, col: 41, offset: 36998},
								offset: 298,
							},
						},
						&litMatcher{
							pos:        position{line: 1213, col: 64, offset: 37021},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1213, col: 69, offset: 37026},
							offset: 334,
						},
						&ruleRefExpr{
							pos:    position{line: 1213, col: 80, offset: 37037},
							offset: 330,
						},
						&labeledExpr{
							pos:   position{line: 1213, col: 90, offset: 37047},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1213, col: 96, offset: 37053},
								expr: &ruleRefExpr{
									pos:    position{line: 1213, col: 97, offset: 37054},
									offset: 206,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1213, col: 116, offset: 37073},
							offset: 297,
						},
					},
				},
			},
		},
		{
			name: "IfNDefBlock",
			pos:  position{line: 1218, col: 1, offset: 37261},
			expr: &actionExpr{
				pos: position{line: 1218, col: 15, offset: 37275},
				run: (*parser).callonIfNDefBlock1,
				expr: &seqExpr{
					pos: position{line: 1218, col: 15, offset: 37275},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1218, col: 15, offset: 37275},
							val:        "ifndef::",
							ignoreCase: false,
							want:       "\"ifndef::\"",
						},
						&labeledExpr{
							pos:   position{line: 1218, col: 26, offset: 37286},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 1218, col: 38, offset: 37298},
								offset: 298,
							},
						},
						&litMatcher{
							pos:        position{line: 1218, col: 61, offset: 37321},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1218, col: 66, offset: 37326},
							offset: 334,
						},
						&ruleRefExpr{
							pos:    position{line: 1218, col: 77, offset: 37337},
							offset: 330,
						},
						&labeledExpr{
							pos:   position{line: 1218, col: 87, offset: 37347},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1218, col: 93, offset: 37353},
								expr: &ruleRefExpr{
									pos:    position{line: 1218, col: 94, offset: 37354},
									offset: 206,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1218, col: 113, offset: 37373},
							offset: 297,
						},
					},
				},
			},
		},
		{
			name: "IfEvalBlock",
			pos:  position{line: 1223, col: 1, offset: 37563},
			expr: &actionExpr{
				pos: position{line: 1223, col: 15, offset: 37577},
				run: (*parser).callonIfEvalBlock1,
				expr: &seqExpr{
					pos: position{line: 1223, col: 15, offset: 37577},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1223, col: 15, offset: 37577},
							offset: 303,
						},
						&litMatcher{
							pos:        position{line: 1223, col: 31, offset: 37593},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 35, offset: 37597},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 45, offset: 37607},
							label: "left",
							expr: &ruleRefExpr{
								pos:    position{line: 1223, col: 51, offset: 37613},
								offset: 304,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 64, offset: 37626},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 75, offset: 37637},
							label: "operand",
							expr: &ruleRefExpr{
								pos:    position{line: 1223, col: 84, offset: 37646},
								offset: 305,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 100, offset: 37662},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 110, offset: 37672},
							label: "right",
							expr: &ruleRefExpr{
								pos:    position{line: 1223, col: 117, offset: 37679},
								offset: 304,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 130, offset: 37692},
							offset: 334,
						},
						&litMatcher{
							pos:        position{line: 1223, col: 140, offset: 37702},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 144, offset: 37706},
							offset: 334,
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 155, offset: 37717},
							offset: 330,
						},
						&labeledExpr{
							pos:   position{line: 1223, col: 165, offset: 37727},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1223, col: 171, offset: 37733},
								expr: &ruleRefExpr{
									pos:    position{line: 1223, col: 172, offset: 37734},
									offset: 206,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1223, col: 191, offset: 37753},
							offset: 297,
						},
					},
				},
			},
		},
		{
			name: "Quote",
			pos:  position{line: 1230, col: 1, offset: 37974},
			expr: &actionExpr{
				pos: position{line: 1231, col: 5, offset: 37986},
				run: (*parser).callonQuote1,
				expr: &seqExpr{
					pos: position{line: 1231, col: 5, offset: 37986},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1231, col: 5, offset: 37986},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1231, col: 12, offset: 37993},
								offset: 213,
							},
						},
						&labeledExpr{
							pos:   position{line: 1232, col: 5, offset: 38009},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1232, col: 11, offset: 38015},
								expr: &seqExpr{
									pos: position{line: 1232, col: 12, offset: 38016},
									exprs: []any{
										&notExpr{
											pos: position{line: 1232, col: 12, offset: 38016},
											expr: &ruleRefExpr{
												pos:    position{line: 1232, col: 13, offset: 38017},
												offset: 216,
											},
										},
										&ruleRefExpr{
											pos:    position{line: 1232, col: 28, offset: 38032},
											offset: 1,
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1233, col: 5, offset: 38046},
							offset: 214,
						},
					},
				},
			},
		},
		{
			name: "QuoteStart",
			pos:  position{line: 1237, col: 1, offset: 38198},
			expr: &actionExpr{
				pos: position{line: 1237, col: 14, offset: 38211},
				run: (*parser).callonQuoteStart1,
				expr: &seqExpr{
					pos: position{line: 1237, col: 14, offset: 38211},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1237, col: 14, offset: 38211},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1237, col: 24, offset: 38221},
								offset: 216,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1237, col: 39, offset: 38236},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1237, col: 49, offset: 38246},
							run: (*parser).callonQuoteStart6,
						},
					},
				},
			},
		},
		{
			name: "QuoteEnd",
			pos:  position{line: 1244, col: 1, offset: 38421},
			expr: &seqExpr{
				pos: position{line: 1244, col: 12, offset: 38432},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1244, col: 12, offset: 38432},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1244, col: 22, offset: 38442},
							offset: 216,
						},
					},
					&andExpr{
						pos: position{line: 1244, col: 37, offset: 38457},
						expr: &ruleRefExpr{
							pos:    position{line: 1244, col: 38, offset: 38458},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1244, col: 48, offset: 38468},
						run: (*parser).callonQuoteEnd6,
					},
				},
			},
		},
		{
			name: "QuoteUnderlines",
			pos:  position{line: 1253, col: 1, offset: 38720},
			expr: &actionExpr{
				pos: position{line: 1253, col: 19, offset: 38738},
				run: (*parser).callonQuoteUnderlines1,
				expr: &seqExpr{
					pos: position{line: 1253, col: 19, offset: 38738},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1253, col: 19, offset: 38738},
							label: "underlines",
							expr: &seqExpr{
								pos: position{line: 1253, col: 31, offset: 38750},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1253, col: 31, offset: 38750},
										val:        "____",
										ignoreCase: false,
										want:       "\"____\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1253, col: 38, offset: 38757},
										expr: &litMatcher{
											pos:        position{line: 1253, col: 38, offset: 38757},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1253, col: 44, offset: 38763},
							run: (*parser).callonQuoteUnderlines8,
						},
					},
				},
			},
		},
		{
			name: "QuoteDelimiter",
			pos:  position{line: 1260, col: 1, offset: 38888},
			expr: &actionExpr{
				pos: position{line: 1260, col: 18, offset: 38905},
				run: (*parser).callonQuoteDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1260, col: 18, offset: 38905},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1260, col: 18, offset: 38905},
							label: "underlines",
							expr: &ruleRefExpr{
								pos:    position{line: 1260, col: 30, offset: 38917},
								offset: 215,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1261, col: 5, offset: 38939},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "ListItemValue",
			pos:  position{line: 1268, col: 1, offset: 39069},
			expr: &actionExpr{
				pos: position{line: 1268, col: 17, offset: 39085},
				run: (*parser).callonListItemValue1,
				expr: &seqExpr{
					pos: position{line: 1268, col: 17, offset: 39085},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1268, col: 17, offset: 39085},
							label: "line",
							expr: &oneOrMoreExpr{
								pos: position{line: 1268, col: 22, offset: 39090},
								expr: &ruleRefExpr{
									pos:    position{line: 1268, col: 22, offset: 39090},
									offset: 90,
								},
							},
						},
						&andExpr{
							pos: position{line: 1268, col: 37, offset: 39105},
							expr: &ruleRefExpr{
								pos:    position{line: 1268, col: 38, offset: 39106},
								offset: 330,
							},
						},
						&labeledExpr{
							pos:   position{line: 1268, col: 48, offset: 39116},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1268, col: 54, offset: 39122},
								expr: &ruleRefExpr{
									pos:    position{line: 1268, col: 55, offset: 39123},
									offset: 220,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1268, col: 70, offset: 39138},
							label: "attachedBlocks",
							expr: &zeroOrOneExpr{
								pos: position{line: 1268, col: 85, offset: 39153},
								expr: &ruleRefExpr{
									pos:    position{line: 1268, col: 86, offset: 39154},
									offset: 221,
								},
							},
						},
						&andExpr{
							pos: position{line: 1268, col: 104, offset: 39172},
							expr: &ruleRefExpr{
								pos:    position{line: 1268, col: 105, offset: 39173},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "ListContinuationMarker",
			pos:  position{line: 1280, col: 1, offset: 39410},
			expr: &actionExpr{
				pos: position{line: 1280, col: 26, offset: 39435},
				run: (*parser).callonListContinuationMarker1,
				expr: &seqExpr{
					pos: position{line: 1280, col: 26, offset: 39435},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1280, col: 26, offset: 39435},
							label: "newlines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1280, col: 36, offset: 39445},
								expr: &ruleRefExpr{
									pos:    position{line: 1280, col: 36, offset: 39445},
									offset: 315,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1280, col: 48, offset: 39457},
							offset: 327,
						},
						&litMatcher{
							pos:        position{line: 1280, col: 64, offset: 39473},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
					},
				},
			},
		},
		{
			name: "ListContinuation",
			pos:  position{line: 1288, col: 1, offset: 39584},
			expr: &actionExpr{
				pos: position{line: 1288, col: 20, offset: 39603},
				run: (*parser).callonListContinuation1,
				expr: &seqExpr{
					pos: position{line: 1288, col: 20, offset: 39603},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1288, col: 20, offset: 39603},
							label: "marker",
							expr: &ruleRefExpr{
								pos:    position{line: 1288, col: 27, offset: 39610},
								offset: 218,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1288, col: 50, offset: 39633},
							offset: 334,
						},
						&ruleRefExpr{
							pos:    position{line: 1288, col: 60, offset: 39643},
							offset: 317,
						},
						&labeledExpr{
							pos:   position{line: 1288, col: 68, offset: 39651},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1288, col: 74, offset: 39657},
								offset: 222,
							},
						},
					},
				},
			},
		},
		{
			name: "ListItemLine",
			pos:  position{line: 1292, col: 1, offset: 39783},
			expr: &actionExpr{
				pos: position{line: 1292, col: 16, offset: 39798},
				run: (*parser).callonListItemLine1,
				expr: &seqExpr{
					pos: position{line: 1292, col: 16, offset: 39798},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1292, col: 16, offset: 39798},
							offset: 330,
						},
						&notExpr{
							pos: position{line: 1292, col: 26, offset: 39808},
							expr: &ruleRefExpr{
								pos:    position{line: 1292, col: 27, offset: 39809},
								offset: 261,
							},
						},
						&notExpr{
							pos: position{line: 1292, col: 45, offset: 39827},
							expr: &ruleRefExpr{
								pos:    position{line: 1292, col: 46, offset: 39828},
								offset: 263,
							},
						},
						&notExpr{
							pos: position{line: 1292, col: 66, offset: 39848},
							expr: &ruleRefExpr{
								pos:    position{line: 1292, col: 67, offset: 39849},
								offset: 14,
							},
						},
						&notExpr{
							pos: position{line: 1292, col: 83, offset: 39865},
							expr: &ruleRefExpr{
								pos:    position{line: 1292, col: 84, offset: 39866},
								offset: 306,
							},
						},
						&notExpr{
							pos: position{line: 1292, col: 105, offset: 39887},
							expr: &ruleRefExpr{
								pos:    position{line: 1292, col: 106, offset: 39888},
								offset: 218,
							},
						},
						&labeledExpr{
							pos:   position{line: 1292, col: 129, offset: 39911},
							label: "element",
							expr: &oneOrMoreExpr{
								pos: position{line: 1292, col: 137, offset: 39919},
								expr: &ruleRefExpr{
									pos:    position{line: 1292, col: 138, offset: 39920},
									offset: 90,
								},
							},
						},
						&andExpr{
							pos: position{line: 1292, col: 154, offset: 39936},
							expr: &ruleRefExpr{
								pos:    position{line: 1292, col: 155, offset: 39937},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "AttachedBlocks",
			pos:  position{line: 1296, col: 1, offset: 40023},
			expr: &actionExpr{
				pos: position{line: 1296, col: 18, offset: 40040},
				run: (*parser).callonAttachedBlocks1,
				expr: &seqExpr{
					pos: position{line: 1296, col: 18, offset: 40040},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1296, col: 18, offset: 40040},
							label: "blocks",
							expr: &oneOrMoreExpr{
								pos: position{line: 1296, col: 25, offset: 40047},
								expr: &ruleRefExpr{
									pos:    position{line: 1296, col: 26, offset: 40048},
									offset: 219,
								},
							},
						},
						&andExpr{
							pos: position{line: 1296, col: 45, offset: 40067},
							expr: &ruleRefExpr{
								pos:    position{line: 1296, col: 46, offset: 40068},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "ContinuationBlockElement",
			pos:  position{line: 1301, col: 1, offset: 40107},
			expr: &actionExpr{
				pos: position{line: 1301, col: 29, offset: 40135},
				run: (*parser).callonContinuationBlockElement1,
				expr: &seqExpr{
					pos: position{line: 1301, col: 29, offset: 40135},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1301, col: 29, offset: 40135},
							label: "element",
							expr: &ruleRefExpr{
								pos:    position{line: 1301, col: 38, offset: 40144},
								offset: 223,
							},
						},
						&andExpr{
							pos: position{line: 1301, col: 65, offset: 40171},
							expr: &ruleRefExpr{
								pos:    position{line: 1301, col: 66, offset: 40172},
								offset: 330,
							},
						},
						&andCodeExpr{
							pos: position{line: 1302, col: 1, offset: 40183},
							run: (*parser).callonContinuationBlockElement7,
						},
					},
				},
			},
		},
		{
			name: "ContinuationBlockElements",
			pos:  position{line: 1308, col: 1, offset: 40255},
			expr: &choiceExpr{
				pos: position{line: 1309, col: 5, offset: 40289},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1309, col: 5, offset: 40289},
						offset: 15,
					},
					&ruleRefExpr{
						pos:    position{line: 1310, col: 5, offset: 40309},
						offset: 5,
					},
					&ruleRefExpr{
						pos:    position{line: 1311, col: 5, offset: 40334},
						offset: 113,
					},
					&ruleRefExpr{
						pos:    position{line: 1312, col: 5, offset: 40346},
						offset: 4,
					},
					&actionExpr{
						pos: position{line: 1312, col: 19, offset: 40360},
						run: (*parser).callonContinuationBlockElements6,
						expr: &labeledExpr{
							pos:   position{line: 1312, col: 19, offset: 40360},
							label: "els",
							expr: &ruleRefExpr{
								pos:    position{line: 1312, col: 23, offset: 40364},
								offset: 89,
							},
						},
					},
				},
			},
		},
		{
			name: "ThematicBreak",
			pos:  position{line: 1318, col: 1, offset: 40505},
			expr: &actionExpr{
				pos: position{line: 1318, col: 17, offset: 40521},
				run: (*parser).callonThematicBreak1,
				expr: &seqExpr{
					pos: position{line: 1318, col: 17, offset: 40521},
					exprs: []any{
						&choiceExpr{
							pos: position{line: 1318, col: 18, offset: 40522},
							alternatives: []any{
								&litMatcher{
									pos:        position{line: 1318, col: 18, offset: 40522},
									val:        "'''",
									ignoreCase: false,
									want:       "\"'''\"",
								},
								&seqExpr{
									pos: position{line: 1318, col: 26, offset: 40530},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1318, col: 26, offset: 40530},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1318, col: 30, offset: 40534},
											expr: &ruleRefExpr{
												pos:    position{line: 1318, col: 30, offset: 40534},
												offset: 339,
											},
										},
										&litMatcher{
											pos:        position{line: 1318, col: 33, offset: 40537},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1318, col: 37, offset: 40541},
											expr: &ruleRefExpr{
												pos:    position{line: 1318, col: 37, offset: 40541},
												offset: 339,
											},
										},
										&litMatcher{
											pos:        position{line: 1318, col: 40, offset: 40544},
											val:        "*",
											ignoreCase: false,
											want:       "\"*\"",
										},
									},
								},
								&seqExpr{
									pos: position{line: 1318, col: 46, offset: 40550},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1318, col: 46, offset: 40550},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1318, col: 50, offset: 40554},
											expr: &ruleRefExpr{
												pos:    position{line: 1318, col: 50, offset: 40554},
												offset: 339,
											},
										},
										&litMatcher{
											pos:        position{line: 1318, col: 53, offset: 40557},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1318, col: 57, offset: 40561},
											expr: &ruleRefExpr{
												pos:    position{line: 1318, col: 57, offset: 40561},
												offset: 339,
											},
										},
										&litMatcher{
											pos:        position{line: 1318, col: 60, offset: 40564},
											val:        "-",
											ignoreCase: false,
											want:       "\"-\"",
										},
									},
								},
								&seqExpr{
									pos: position{line: 1318, col: 66, offset: 40570},
									exprs: []any{
										&litMatcher{
											pos:        position{line: 1318, col: 66, offset: 40570},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1318, col: 70, offset: 40574},
											expr: &ruleRefExpr{
												pos:    position{line: 1318, col: 70, offset: 40574},
												offset: 339,
											},
										},
										&litMatcher{
											pos:        position{line: 1318, col: 73, offset: 40577},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
										&zeroOrOneExpr{
											pos: position{line: 1318, col: 77, offset: 40581},
											expr: &ruleRefExpr{
												pos:    position{line: 1318, col: 77, offset: 40581},
												offset: 339,
											},
										},
										&litMatcher{
											pos:        position{line: 1318, col: 80, offset: 40584},
											val:        "_",
											ignoreCase: false,
											want:       "\"_\"",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1318, col: 85, offset: 40589},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1318, col: 95, offset: 40599},
							expr: &ruleRefExpr{
								pos:    position{line: 1318, col: 96, offset: 40600},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "PageBreak",
			pos:  position{line: 1323, col: 1, offset: 40671},
			expr: &actionExpr{
				pos: position{line: 1323, col: 13, offset: 40683},
				run: (*parser).callonPageBreak1,
				expr: &seqExpr{
					pos: position{line: 1323, col: 13, offset: 40683},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1323, col: 14, offset: 40684},
							val:        "<<<",
							ignoreCase: false,
							want:       "\"<<<\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1323, col: 21, offset: 40691},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1323, col: 31, offset: 40701},
							expr: &ruleRefExpr{
								pos:    position{line: 1323, col: 32, offset: 40702},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "Fenced",
			pos:  position{line: 1328, col: 1, offset: 40769},
			expr: &actionExpr{
				pos: position{line: 1329, col: 5, offset: 40782},
				run: (*parser).callonFenced1,
				expr: &seqExpr{
					pos: position{line: 1329, col: 5, offset: 40782},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1329, col: 5, offset: 40782},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1329, col: 12, offset: 40789},
								offset: 227,
							},
						},
						&labeledExpr{
							pos:   position{line: 1330, col: 5, offset: 40806},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1330, col: 11, offset: 40812},
								expr: &seqExpr{
									pos: position{line: 1330, col: 12, offset: 40813},
									exprs: []any{
										&notExpr{
											pos: position{line: 1330, col: 12, offset: 40813},
											expr: &ruleRefExpr{
												pos:    position{line: 1330, col: 13, offset: 40814},
												offset: 230,
											},
										},
										&ruleRefExpr{
											pos:    position{line: 1330, col: 29, offset: 40830},
											offset: 1,
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1331, col: 5, offset: 40844},
							offset: 228,
						},
					},
				},
			},
		},
		{
			name: "FencedStart",
			pos:  position{line: 1336, col: 1, offset: 41014},
			expr: &actionExpr{
				pos: position{line: 1336, col: 15, offset: 41028},
				run: (*parser).callonFencedStart1,
				expr: &seqExpr{
					pos: position{line: 1336, col: 15, offset: 41028},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1336, col: 15, offset: 41028},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1336, col: 25, offset: 41038},
								offset: 230,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1336, col: 41, offset: 41054},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1336, col: 51, offset: 41064},
							run: (*parser).callonFencedStart6,
						},
					},
				},
			},
		},
		{
			name: "FencedEnd",
			pos:  position{line: 1343, col: 1, offset: 41254},
			expr: &seqExpr{
				pos: position{line: 1343, col: 13, offset: 41266},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1343, col: 13, offset: 41266},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1343, col: 23, offset: 41276},
							offset: 230,
						},
					},
					&andExpr{
						pos: position{line: 1343, col: 39, offset: 41292},
						expr: &ruleRefExpr{
							pos:    position{line: 1343, col: 40, offset: 41293},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1343, col: 50, offset: 41303},
						run: (*parser).callonFencedEnd6,
					},
				},
			},
		},
		{
			name: "FencedBackticks",
			pos:  position{line: 1352, col: 1, offset: 41575},
			expr: &actionExpr{
				pos: position{line: 1352, col: 19, offset: 41593},
				run: (*parser).callonFencedBackticks1,
				expr: &seqExpr{
					pos: position{line: 1352, col: 19, offset: 41593},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1352, col: 19, offset: 41593},
							label: "backticks",
							expr: &seqExpr{
								pos: position{line: 1352, col: 30, offset: 41604},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1352, col: 30, offset: 41604},
										val:        "```",
										ignoreCase: false,
										want:       "\"```\"",
									},
									&notExpr{
										pos: position{line: 1352, col: 36, offset: 41610},
										expr: &litMatcher{
											pos:        position{line: 1352, col: 37, offset: 41611},
											val:        "`",
											ignoreCase: false,
											want:       "\"`\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1352, col: 42, offset: 41616},
							run: (*parser).callonFencedBackticks8,
						},
					},
				},
			},
		},
		{
			name: "FencedDelimiter",
			pos:  position{line: 1359, col: 1, offset: 41743},
			expr: &actionExpr{
				pos: position{line: 1359, col: 19, offset: 41761},
				run: (*parser).callonFencedDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1359, col: 19, offset: 41761},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1359, col: 19, offset: 41761},
							label: "hyphens",
							expr: &ruleRefExpr{
								pos:    position{line: 1359, col: 28, offset: 41770},
								offset: 229,
							},
						},
						&labeledExpr{
							pos:   position{line: 1359, col: 45, offset: 41787},
							label: "language",
							expr: &zeroOrOneExpr{
								pos: position{line: 1359, col: 54, offset: 41796},
								expr: &ruleRefExpr{
									pos:    position{line: 1359, col: 55, offset: 41797},
									offset: 89,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1360, col: 5, offset: 41818},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "FencedLine",
			pos:  position{line: 1370, col: 1, offset: 42053},
			expr: &actionExpr{
				pos: position{line: 1370, col: 14, offset: 42066},
				run: (*parser).callonFencedLine1,
				expr: &seqExpr{
					pos: position{line: 1370, col: 15, offset: 42067},
					exprs: []any{
						&notExpr{
							pos: position{line: 1370, col: 15, offset: 42067},
							expr: &ruleRefExpr{
								pos:    position{line: 1370, col: 16, offset: 42068},
								offset: 230,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1370, col: 32, offset: 42084},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 1370, col: 45, offset: 42097},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 1370, col: 50, offset: 42102},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1370, col: 58, offset: 42110},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "Stem",
			pos:  position{line: 1376, col: 1, offset: 42159},
			expr: &actionExpr{
				pos: position{line: 1377, col: 5, offset: 42170},
				run: (*parser).callonStem1,
				expr: &seqExpr{
					pos: position{line: 1377, col: 5, offset: 42170},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1377, col: 5, offset: 42170},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1377, col: 12, offset: 42177},
								offset: 233,
							},
						},
						&labeledExpr{
							pos:   position{line: 1378, col: 5, offset: 42192},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1378, col: 11, offset: 42198},
								expr: &ruleRefExpr{
									pos:    position{line: 1378, col: 12, offset: 42199},
									offset: 237,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1379, col: 5, offset: 42214},
							offset: 234,
						},
					},
				},
			},
		},
		{
			name: "StemStart",
			pos:  position{line: 1383, col: 1, offset: 42373},
			expr: &actionExpr{
				pos: position{line: 1383, col: 13, offset: 42385},
				run: (*parser).callonStemStart1,
				expr: &seqExpr{
					pos: position{line: 1383, col: 13, offset: 42385},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1383, col: 13, offset: 42385},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1383, col: 23, offset: 42395},
								offset: 236,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1383, col: 37, offset: 42409},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1383, col: 47, offset: 42419},
							run: (*parser).callonStemStart6,
						},
					},
				},
			},
		},
		{
			name: "StemEnd",
			pos:  position{line: 1390, col: 1, offset: 42593},
			expr: &seqExpr{
				pos: position{line: 1390, col: 11, offset: 42603},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1390, col: 11, offset: 42603},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1390, col: 21, offset: 42613},
							offset: 236,
						},
					},
					&andExpr{
						pos: position{line: 1390, col: 35, offset: 42627},
						expr: &ruleRefExpr{
							pos:    position{line: 1390, col: 36, offset: 42628},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1390, col: 46, offset: 42638},
						run: (*parser).callonStemEnd6,
					},
				},
			},
		},
		{
			name: "StemPluses",
			pos:  position{line: 1399, col: 1, offset: 42892},
			expr: &actionExpr{
				pos: position{line: 1399, col: 14, offset: 42905},
				run: (*parser).callonStemPluses1,
				expr: &seqExpr{
					pos: position{line: 1399, col: 14, offset: 42905},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1399, col: 14, offset: 42905},
							label: "pluses",
							expr: &seqExpr{
								pos: position{line: 1399, col: 22, offset: 42913},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1399, col: 22, offset: 42913},
										val:        "++++",
										ignoreCase: false,
										want:       "\"++++\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1399, col: 29, offset: 42920},
										expr: &litMatcher{
											pos:        position{line: 1399, col: 29, offset: 42920},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1399, col: 35, offset: 42926},
							run: (*parser).callonStemPluses8,
						},
					},
				},
			},
		},
		{
			name: "StemDelimiter",
			pos:  position{line: 1406, col: 1, offset: 43043},
			expr: &actionExpr{
				pos: position{line: 1406, col: 17, offset: 43059},
				run: (*parser).callonStemDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1406, col: 17, offset: 43059},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1406, col: 17, offset: 43059},
							label: "pluses",
							expr: &ruleRefExpr{
								pos:    position{line: 1406, col: 25, offset: 43067},
								offset: 235,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1407, col: 5, offset: 43084},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "StemLine",
			pos:  position{line: 1412, col: 1, offset: 43207},
			expr: &actionExpr{
				pos: position{line: 1412, col: 12, offset: 43218},
				run: (*parser).callonStemLine1,
				expr: &seqExpr{
					pos: position{line: 1412, col: 13, offset: 43219},
					exprs: []any{
						&notExpr{
							pos: position{line: 1412, col: 13, offset: 43219},
							expr: &ruleRefExpr{
								pos:    position{line: 1412, col: 14, offset: 43220},
								offset: 236,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1412, col: 28, offset: 43234},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 1412, col: 41, offset: 43247},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 1412, col: 46, offset: 43252},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1412, col: 54, offset: 43260},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "CrossReference",
			pos:  position{line: 1420, col: 1, offset: 43311},
			expr: &choiceExpr{
				pos: position{line: 1420, col: 18, offset: 43328},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1420, col: 18, offset: 43328},
						offset: 239,
					},
					&ruleRefExpr{
						pos:    position{line: 1420, col: 43, offset: 43353},
						offset: 251,
					},
				},
			},
		},
		{
			name: "InternalCrossReference",
			pos:  position{line: 1422, col: 1, offset: 43374},
			expr: &actionExpr{
				pos: position{line: 1422, col: 26, offset: 43399},
				run: (*parser).callonInternalCrossReference1,
				expr: &seqExpr{
					pos: position{line: 1422, col: 26, offset: 43399},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1422, col: 26, offset: 43399},
							offset: 240,
						},
						&labeledExpr{
							pos:   position{line: 1422, col: 46, offset: 43419},
							label: "id",
							expr: &ruleRefExpr{
								pos:    position{line: 1422, col: 50, offset: 43423},
								offset: 243,
							},
						},
						&labeledExpr{
							pos:   position{line: 1422, col: 68, offset: 43441},
							label: "label",
							expr: &zeroOrOneExpr{
								pos: position{line: 1422, col: 74, offset: 43447},
								expr: &actionExpr{
									pos: position{line: 1422, col: 75, offset: 43448},
									run: (*parser).callonInternalCrossReference8,
									expr: &seqExpr{
										pos: position{line: 1422, col: 75, offset: 43448},
										exprs: []any{
											&ruleRefExpr{
												pos:    position{line: 1422, col: 75, offset: 43448},
												offset: 334,
											},
											&litMatcher{
												pos:        position{line: 1422, col: 85, offset: 43458},
												val:        ",",
												ignoreCase: false,
												want:       "\",\"",
											},
											&labeledExpr{
												pos:   position{line: 1422, col: 89, offset: 43462},
												label: "label",
												expr: &seqExpr{
													pos: position{line: 1422, col: 96, offset: 43469},
													exprs: []any{
														&ruleRefExpr{
															pos:    position{line: 1422, col: 96, offset: 43469},
															offset: 334,
														},
														&ruleRefExpr{
															pos:    position{line: 1422, col: 106, offset: 43479},
															offset: 244,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1422, col: 150, offset: 43523},
							val:        ">>",
							ignoreCase: false,
							want:       "\">>\"",
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceStart",
			pos:  position{line: 1430, col: 1, offset: 43781},
			expr: &litMatcher{
				pos:        position{line: 1430, col: 23, offset: 43803},
				val:        "<<",
				ignoreCase: false,
				want:       "\"<<\"",
			},
		},
		{
			name: "CrossReferenceInitialCharacter",
			pos:  position{line: 1432, col: 1, offset: 43810},
			expr: &actionExpr{
				pos: position{line: 1432, col: 34, offset: 43843},
				run: (*parser).callonCrossReferenceInitialCharacter1,
				expr: &choiceExpr{
					pos: position{line: 1432, col: 35, offset: 43844},
					alternatives: []any{
						&ruleRefExpr{
							pos:    position{line: 1432, col: 35, offset: 43844},
							offset: 322,
						},
						&charClassMatcher{
							pos:        position{line: 1432, col: 43, offset: 43852},
							val:        "[:_]",
							chars:      []rune{':', '_'},
							ignoreCase: false,
							inverted:   false,
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceCharacters",
			pos:  position{line: 1437, col: 1, offset: 44002},
			expr: &actionExpr{
				pos: position{line: 1437, col: 28, offset: 44029},
				run: (*parser).callonCrossReferenceCharacters1,
				expr: &oneOrMoreExpr{
					pos: position{line: 1437, col: 28, offset: 44029},
					expr: &seqExpr{
						pos: position{line: 1437, col: 29, offset: 44030},
						exprs: []any{
							&notExpr{
								pos: position{line: 1437, col: 29, offset: 44030},
								expr: &ruleRefExpr{
									pos:    position{line: 1437, col: 30, offset: 44031},
									offset: 53,
								},
							},
							&charClassMatcher{
								pos:        position{line: 1437, col: 50, offset: 44051},
								val:        "[\\p{L}\\p{N} _:.-]",
								chars:      []rune{' ', '_', ':', '.', '-'},
								classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("N")},
								ignoreCase: false,
								inverted:   false,
							},
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceID",
			pos:  position{line: 1442, col: 1, offset: 44129},
			expr: &actionExpr{
				pos: position{line: 1442, col: 21, offset: 44149},
				run: (*parser).callonCrossReferenceID1,
				expr: &seqExpr{
					pos: position{line: 1442, col: 21, offset: 44149},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1442, col: 21, offset: 44149},
							label: "start",
							expr: &choiceExpr{
								pos: position{line: 1442, col: 28, offset: 44156},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 1442, col: 28, offset: 44156},
										offset: 53,
									},
									&ruleRefExpr{
										pos:    position{line: 1442, col: 49, offset: 44177},
										offset: 241,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1442, col: 81, offset: 44209},
							label: "end",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1442, col: 85, offset: 44213},
								expr: &choiceExpr{
									pos: position{line: 1442, col: 86, offset: 44214},
									alternatives: []any{
										&ruleRefExpr{
											pos:    position{line: 1442, col: 86, offset: 44214},
											offset: 53,
										},
										&ruleRefExpr{
											pos:    position{line: 1442, col: 107, offset: 44235},
											offset: 242,
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceLabel",
			pos:  position{line: 1451, col: 1, offset: 44409},
			expr: &oneOrMoreExpr{
				pos: position{line: 1451, col: 23, offset: 44431},
				expr: &choiceExpr{
					pos: position{line: 1452, col: 5, offset: 44437},
					alternatives: []any{
						&oneOrMoreExpr{
							pos: position{line: 1452, col: 6, offset: 44438},
							expr: &charClassMatcher{
								pos:        position{line: 1452, col: 6, offset: 44438},
								val:        "[^<>{[\\]]",
								chars:      []rune{'<', '>', '{', '[', ']'},
								ignoreCase: false,
								inverted:   true,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1453, col: 7, offset: 44456},
							offset: 53,
						},
						&litMatcher{
							pos:        position{line: 1454, col: 7, offset: 44482},
							val:        "{",
							ignoreCase: false,
							want:       "\"{\"",
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceMacroStart",
			pos:  position{line: 1457, col: 1, offset: 44491},
			expr: &litMatcher{
				pos:        position{line: 1457, col: 28, offset: 44518},
				val:        "xref:",
				ignoreCase: false,
				want:       "\"xref:\"",
			},
		},
		{
			name: "CrossReferenceMacroLabelElement",
			pos:  position{line: 1459, col: 1, offset: 44527},
			expr: &choiceExpr{
				pos: position{line: 1459, col: 36, offset: 44562},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1459, col: 36, offset: 44562},
						val:        "\\]",
						ignoreCase: false,
						want:       "\"\\\\]\"",
					},
					&ruleRefExpr{
						pos:    position{line: 1459, col: 44, offset: 44570},
						offset: 90,
					},
					&ruleRefExpr{
						pos:    position{line: 1459, col: 60, offset: 44586},
						offset: 317,
					},
				},
			},
		},
		{
			name: "CrossReferenceMacroLabelContent",
			pos:  position{line: 1461, col: 1, offset: 44597},
			expr: &oneOrMoreExpr{
				pos: position{line: 1461, col: 35, offset: 44631},
				expr: &seqExpr{
					pos: position{line: 1461, col: 36, offset: 44632},
					exprs: []any{
						&notExpr{
							pos: position{line: 1461, col: 36, offset: 44632},
							expr: &ruleRefExpr{
								pos:    position{line: 1461, col: 37, offset: 44633},
								offset: 250,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1461, col: 65, offset: 44661},
							offset: 246,
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceMacroLabel",
			pos:  position{line: 1463, col: 1, offset: 44697},
			expr: &actionExpr{
				pos: position{line: 1463, col: 28, offset: 44724},
				run: (*parser).callonCrossReferenceMacroLabel1,
				expr: &seqExpr{
					pos: position{line: 1463, col: 28, offset: 44724},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1463, col: 28, offset: 44724},
							offset: 249,
						},
						&labeledExpr{
							pos:   position{line: 1463, col: 58, offset: 44754},
							label: "content",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1463, col: 66, offset: 44762},
								expr: &ruleRefExpr{
									pos:    position{line: 1463, col: 67, offset: 44763},
									offset: 247,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1463, col: 101, offset: 44797},
							offset: 250,
						},
					},
				},
			},
		},
		{
			name: "CrossReferenceMacroLabelStart",
			pos:  position{line: 1467, col: 1, offset: 44858},
			expr: &litMatcher{
				pos:        position{line: 1467, col: 33, offset: 44890},
				val:        "[",
				ignoreCase: false,
				want:       "\"[\"",
			},
		},
		{
			name: "CrossReferenceMacroLabelEnd",
			pos:  position{line: 1469, col: 1, offset: 44895},
			expr: &seqExpr{
				pos: position{line: 1469, col: 31, offset: 44925},
				exprs: []any{
					&notExpr{
						pos: position{line: 1469, col: 31, offset: 44925},
						expr: &litMatcher{
							pos:        position{line: 1469, col: 32, offset: 44926},
							val:        "\\",
							ignoreCase: false,
							want:       "\"\\\\\"",
						},
					},
					&litMatcher{
						pos:        position{line: 1469, col: 37, offset: 44931},
						val:        "]",
						ignoreCase: false,
						want:       "\"]\"",
					},
				},
			},
		},
		{
			name: "CrossReferenceMacro",
			pos:  position{line: 1471, col: 1, offset: 44936},
			expr: &actionExpr{
				pos: position{line: 1471, col: 23, offset: 44958},
				run: (*parser).callonCrossReferenceMacro1,
				expr: &seqExpr{
					pos: position{line: 1471, col: 23, offset: 44958},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1471, col: 23, offset: 44958},
							offset: 245,
						},
						&labeledExpr{
							pos:   position{line: 1471, col: 48, offset: 44983},
							label: "path",
							expr: &ruleRefExpr{
								pos:    position{line: 1471, col: 54, offset: 44989},
								offset: 165,
							},
						},
						&labeledExpr{
							pos:   position{line: 1471, col: 60, offset: 44995},
							label: "label",
							expr: &ruleRefExpr{
								pos:    position{line: 1471, col: 67, offset: 45002},
								offset: 248,
							},
						},
					},
				},
			},
		},
		{
			name: "UppercaseRoman",
			pos:  position{line: 1482, col: 1, offset: 45288},
			expr: &actionExpr{
				pos: position{line: 1482, col: 18, offset: 45305},
				run: (*parser).callonUppercaseRoman1,
				expr: &seqExpr{
					pos: position{line: 1482, col: 18, offset: 45305},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1482, col: 18, offset: 45305},
							label: "thousands",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1482, col: 28, offset: 45315},
								expr: &litMatcher{
									pos:        position{line: 1482, col: 28, offset: 45315},
									val:        "M",
									ignoreCase: false,
									want:       "\"M\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1482, col: 33, offset: 45320},
							label: "hundreds",
							expr: &zeroOrOneExpr{
								pos: position{line: 1482, col: 42, offset: 45329},
								expr: &ruleRefExpr{
									pos:    position{line: 1482, col: 42, offset: 45329},
									offset: 253,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1482, col: 66, offset: 45353},
							label: "tens",
							expr: &zeroOrOneExpr{
								pos: position{line: 1482, col: 71, offset: 45358},
								expr: &ruleRefExpr{
									pos:    position{line: 1482, col: 72, offset: 45359},
									offset: 254,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1482, col: 93, offset: 45380},
							label: "ones",
							expr: &zeroOrOneExpr{
								pos: position{line: 1482, col: 98, offset: 45385},
								expr: &ruleRefExpr{
									pos:    position{line: 1482, col: 99, offset: 45386},
									offset: 255,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1482, col: 120, offset: 45407},
							run: (*parser).callonUppercaseRoman15,
						},
					},
				},
			},
		},
		{
			name: "UppercaseRomanHundreds",
			pos:  position{line: 1489, col: 1, offset: 45531},
			expr: &choiceExpr{
				pos: position{line: 1490, col: 5, offset: 45562},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1490, col: 5, offset: 45562},
						val:        "CM",
						ignoreCase: false,
						want:       "\"CM\"",
					},
					&litMatcher{
						pos:        position{line: 1491, col: 7, offset: 45573},
						val:        "CD",
						ignoreCase: false,
						want:       "\"CD\"",
					},
					&seqExpr{
						pos: position{line: 1492, col: 8, offset: 45585},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 1492, col: 8, offset: 45585},
								val:        "D",
								ignoreCase: false,
								want:       "\"D\"",
							},
							&labeledExpr{
								pos:   position{line: 1492, col: 12, offset: 45589},
								label: "hundreds",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1492, col: 21, offset: 45598},
									expr: &litMatcher{
										pos:        position{line: 1492, col: 21, offset: 45598},
										val:        "C",
										ignoreCase: false,
										want:       "\"C\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1492, col: 26, offset: 45603},
								run: (*parser).callonUppercaseRomanHundreds9,
							},
						},
					},
				},
			},
		},
		{
			name: "UppercaseRomanTens",
			pos:  position{line: 1495, col: 1, offset: 45649},
			expr: &choiceExpr{
				pos: position{line: 1496, col: 5, offset: 45676},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1496, col: 5, offset: 45676},
						val:        "XC",
						ignoreCase: false,
						want:       "\"XC\"",
					},
					&litMatcher{
						pos:        position{line: 1497, col: 7, offset: 45687},
						val:        "XL",
						ignoreCase: false,
						want:       "\"XL\"",
					},
					&seqExpr{
						pos: position{line: 1498, col: 8, offset: 45699},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1498, col: 8, offset: 45699},
								expr: &litMatcher{
									pos:        position{line: 1498, col: 8, offset: 45699},
									val:        "L",
									ignoreCase: false,
									want:       "\"L\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1498, col: 13, offset: 45704},
								label: "tens",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1498, col: 18, offset: 45709},
									expr: &litMatcher{
										pos:        position{line: 1498, col: 18, offset: 45709},
										val:        "X",
										ignoreCase: false,
										want:       "\"X\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1498, col: 23, offset: 45714},
								run: (*parser).callonUppercaseRomanTens10,
							},
						},
					},
				},
			},
		},
		{
			name: "UppercaseRomanOnes",
			pos:  position{line: 1501, col: 1, offset: 45756},
			expr: &choiceExpr{
				pos: position{line: 1502, col: 5, offset: 45783},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1502, col: 5, offset: 45783},
						val:        "IX",
						ignoreCase: false,
						want:       "\"IX\"",
					},
					&litMatcher{
						pos:        position{line: 1503, col: 7, offset: 45794},
						val:        "IV",
						ignoreCase: false,
						want:       "\"IV\"",
					},
					&seqExpr{
						pos: position{line: 1504, col: 8, offset: 45806},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1504, col: 8, offset: 45806},
								expr: &litMatcher{
									pos:        position{line: 1504, col: 8, offset: 45806},
									val:        "V",
									ignoreCase: false,
									want:       "\"V\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1504, col: 13, offset: 45811},
								label: "ones",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1504, col: 18, offset: 45816},
									expr: &litMatcher{
										pos:        position{line: 1504, col: 18, offset: 45816},
										val:        "I",
										ignoreCase: false,
										want:       "\"I\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1504, col: 23, offset: 45821},
								run: (*parser).callonUppercaseRomanOnes10,
							},
						},
					},
				},
			},
		},
		{
			name: "LowercaseRoman",
			pos:  position{line: 1507, col: 1, offset: 45863},
			expr: &actionExpr{
				pos: position{line: 1507, col: 18, offset: 45880},
				run: (*parser).callonLowercaseRoman1,
				expr: &seqExpr{
					pos: position{line: 1507, col: 18, offset: 45880},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1507, col: 18, offset: 45880},
							label: "thousands",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1507, col: 28, offset: 45890},
								expr: &litMatcher{
									pos:        position{line: 1507, col: 28, offset: 45890},
									val:        "m",
									ignoreCase: false,
									want:       "\"m\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1507, col: 33, offset: 45895},
							label: "hundreds",
							expr: &zeroOrOneExpr{
								pos: position{line: 1507, col: 42, offset: 45904},
								expr: &ruleRefExpr{
									pos:    position{line: 1507, col: 42, offset: 45904},
									offset: 257,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1507, col: 66, offset: 45928},
							label: "tens",
							expr: &zeroOrOneExpr{
								pos: position{line: 1507, col: 71, offset: 45933},
								expr: &ruleRefExpr{
									pos:    position{line: 1507, col: 72, offset: 45934},
									offset: 258,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1507, col: 93, offset: 45955},
							label: "ones",
							expr: &zeroOrOneExpr{
								pos: position{line: 1507, col: 98, offset: 45960},
								expr: &ruleRefExpr{
									pos:    position{line: 1507, col: 99, offset: 45961},
									offset: 259,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1507, col: 120, offset: 45982},
							run: (*parser).callonLowercaseRoman15,
						},
					},
				},
			},
		},
		{
			name: "LowercaseRomanHundreds",
			pos:  position{line: 1514, col: 1, offset: 46106},
			expr: &choiceExpr{
				pos: position{line: 1515, col: 5, offset: 46137},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1515, col: 5, offset: 46137},
						val:        "cm",
						ignoreCase: false,
						want:       "\"cm\"",
					},
					&litMatcher{
						pos:        position{line: 1516, col: 7, offset: 46148},
						val:        "cd",
						ignoreCase: false,
						want:       "\"cd\"",
					},
					&seqExpr{
						pos: position{line: 1517, col: 8, offset: 46160},
						exprs: []any{
							&litMatcher{
								pos:        position{line: 1517, col: 8, offset: 46160},
								val:        "d",
								ignoreCase: false,
								want:       "\"d\"",
							},
							&labeledExpr{
								pos:   position{line: 1517, col: 12, offset: 46164},
								label: "hundreds",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1517, col: 21, offset: 46173},
									expr: &litMatcher{
										pos:        position{line: 1517, col: 21, offset: 46173},
										val:        "c",
										ignoreCase: false,
										want:       "\"c\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1517, col: 26, offset: 46178},
								run: (*parser).callonLowercaseRomanHundreds9,
							},
						},
					},
				},
			},
		},
		{
			name: "LowercaseRomanTens",
			pos:  position{line: 1520, col: 1, offset: 46224},
			expr: &choiceExpr{
				pos: position{line: 1521, col: 5, offset: 46251},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1521, col: 5, offset: 46251},
						val:        "xc",
						ignoreCase: false,
						want:       "\"xc\"",
					},
					&litMatcher{
						pos:        position{line: 1522, col: 7, offset: 46262},
						val:        "xl",
						ignoreCase: false,
						want:       "\"xl\"",
					},
					&seqExpr{
						pos: position{line: 1523, col: 8, offset: 46274},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1523, col: 8, offset: 46274},
								expr: &litMatcher{
									pos:        position{line: 1523, col: 8, offset: 46274},
									val:        "l",
									ignoreCase: false,
									want:       "\"l\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1523, col: 13, offset: 46279},
								label: "tens",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1523, col: 18, offset: 46284},
									expr: &litMatcher{
										pos:        position{line: 1523, col: 18, offset: 46284},
										val:        "x",
										ignoreCase: false,
										want:       "\"x\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1523, col: 23, offset: 46289},
								run: (*parser).callonLowercaseRomanTens10,
							},
						},
					},
				},
			},
		},
		{
			name: "LowercaseRomanOnes",
			pos:  position{line: 1526, col: 1, offset: 46331},
			expr: &choiceExpr{
				pos: position{line: 1527, col: 5, offset: 46358},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1527, col: 5, offset: 46358},
						val:        "ix",
						ignoreCase: false,
						want:       "\"ix\"",
					},
					&litMatcher{
						pos:        position{line: 1528, col: 7, offset: 46369},
						val:        "iv",
						ignoreCase: false,
						want:       "\"iv\"",
					},
					&seqExpr{
						pos: position{line: 1529, col: 8, offset: 46381},
						exprs: []any{
							&zeroOrOneExpr{
								pos: position{line: 1529, col: 8, offset: 46381},
								expr: &litMatcher{
									pos:        position{line: 1529, col: 8, offset: 46381},
									val:        "v",
									ignoreCase: false,
									want:       "\"v\"",
								},
							},
							&labeledExpr{
								pos:   position{line: 1529, col: 13, offset: 46386},
								label: "ones",
								expr: &zeroOrMoreExpr{
									pos: position{line: 1529, col: 18, offset: 46391},
									expr: &litMatcher{
										pos:        position{line: 1529, col: 18, offset: 46391},
										val:        "i",
										ignoreCase: false,
										want:       "\"i\"",
									},
								},
							},
							&andCodeExpr{
								pos: position{line: 1529, col: 23, offset: 46396},
								run: (*parser).callonLowercaseRomanOnes10,
							},
						},
					},
				},
			},
		},
		{
			name: "OrderedListItem",
			pos:  position{line: 1534, col: 1, offset: 46440},
			expr: &actionExpr{
				pos: position{line: 1534, col: 19, offset: 46458},
				run: (*parser).callonOrderedListItem1,
				expr: &seqExpr{
					pos: position{line: 1534, col: 19, offset: 46458},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1534, col: 19, offset: 46458},
							label: "marker",
							expr: &ruleRefExpr{
								pos:    position{line: 1534, col: 27, offset: 46466},
								offset: 261,
							},
						},
						&labeledExpr{
							pos:   position{line: 1534, col: 47, offset: 46486},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1534, col: 54, offset: 46493},
								offset: 217,
							},
						},
					},
				},
			},
		},
		{
			name: "OrderedListMarker",
			pos:  position{line: 1540, col: 1, offset: 46687},
			expr: &actionExpr{
				pos: position{line: 1540, col: 21, offset: 46707},
				run: (*parser).callonOrderedListMarker1,
				expr: &seqExpr{
					pos: position{line: 1540, col: 21, offset: 46707},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1540, col: 21, offset: 46707},
							label: "indent",
							expr: &ruleRefExpr{
								pos:    position{line: 1540, col: 29, offset: 46715},
								offset: 334,
							},
						},
						&labeledExpr{
							pos:   position{line: 1540, col: 40, offset: 46726},
							label: "marker",
							expr: &choiceExpr{
								pos: position{line: 1540, col: 48, offset: 46734},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1540, col: 48, offset: 46734},
										run: (*parser).callonOrderedListMarker7,
										expr: &seqExpr{
											pos: position{line: 1540, col: 48, offset: 46734},
											exprs: []any{
												&labeledExpr{
													pos:   position{line: 1540, col: 48, offset: 46734},
													label: "ordinal",
													expr: &actionExpr{
														pos: position{line: 1540, col: 57, offset: 46743},
														run: (*parser).callonOrderedListMarker10,
														expr: &oneOrMoreExpr{
															pos: position{line: 1540, col: 58, offset: 46744},
															expr: &litMatcher{
																pos:        position{line: 1540, col: 58, offset: 46744},
																val:        ".",
																ignoreCase: false,
																want:       "\".\"",
															},
														},
													},
												},
												&andCodeExpr{
													pos: position{line: 1542, col: 4, offset: 46790},
													run: (*parser).callonOrderedListMarker13,
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1548, col: 3, offset: 46885},
										run: (*parser).callonOrderedListMarker14,
										expr: &seqExpr{
											pos: position{line: 1548, col: 3, offset: 46885},
											exprs: []any{
												&oneOrMoreExpr{
													pos: position{line: 1548, col: 3, offset: 46885},
													expr: &charClassMatcher{
														pos:        position{line: 1548, col: 3, offset: 46885},
														val:        "[0-9]",
														ranges:     []rune{'0', '9'},
														ignoreCase: false,
														inverted:   false,
													},
												},
												&litMatcher{
													pos:        position{line: 1548, col: 10, offset: 46892},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1549, col: 3, offset: 46929},
										run: (*parser).callonOrderedListMarker19,
										expr: &seqExpr{
											pos: position{line: 1549, col: 3, offset: 46929},
											exprs: []any{
												&charClassMatcher{
													pos:        position{line: 1549, col: 3, offset: 46929},
													val:        "[a-z]",
													ranges:     []rune{'a', 'z'},
													ignoreCase: false,
													inverted:   false,
												},
												&litMatcher{
													pos:        position{line: 1549, col: 9, offset: 46935},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1550, col: 3, offset: 46972},
										run: (*parser).callonOrderedListMarker23,
										expr: &seqExpr{
											pos: position{line: 1550, col: 3, offset: 46972},
											exprs: []any{
												&charClassMatcher{
													pos:        position{line: 1550, col: 3, offset: 46972},
													val:        "[A-Z]",
													ranges:     []rune{'A', 'Z'},
													ignoreCase: false,
													inverted:   false,
												},
												&litMatcher{
													pos:        position{line: 1550, col: 9, offset: 46978},
													val:        ".",
													ignoreCase: false,
													want:       "\".\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1551, col: 3, offset: 47015},
										run: (*parser).callonOrderedListMarker27,
										expr: &seqExpr{
											pos: position{line: 1551, col: 3, offset: 47015},
											exprs: []any{
												&ruleRefExpr{
													pos:    position{line: 1551, col: 3, offset: 47015},
													offset: 256,
												},
												&litMatcher{
													pos:        position{line: 1551, col: 18, offset: 47030},
													val:        ")",
													ignoreCase: false,
													want:       "\")\"",
												},
											},
										},
									},
									&actionExpr{
										pos: position{line: 1552, col: 3, offset: 47067},
										run: (*parser).callonOrderedListMarker31,
										expr: &seqExpr{
											pos: position{line: 1552, col: 3, offset: 47067},
											exprs: []any{
												&ruleRefExpr{
													pos:    position{line: 1552, col: 3, offset: 47067},
													offset: 252,
												},
												&litMatcher{
													pos:        position{line: 1552, col: 18, offset: 47082},
													val:        ")",
													ignoreCase: false,
													want:       "\")\"",
												},
											},
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1554, col: 1, offset: 47119},
							offset: 338,
						},
					},
				},
			},
		},
		{
			name: "UnorderedListItem",
			pos:  position{line: 1562, col: 1, offset: 47210},
			expr: &actionExpr{
				pos: position{line: 1562, col: 21, offset: 47230},
				run: (*parser).callonUnorderedListItem1,
				expr: &seqExpr{
					pos: position{line: 1562, col: 21, offset: 47230},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1562, col: 21, offset: 47230},
							label: "marker",
							expr: &ruleRefExpr{
								pos:    position{line: 1562, col: 29, offset: 47238},
								offset: 263,
							},
						},
						&labeledExpr{
							pos:   position{line: 1562, col: 50, offset: 47259},
							label: "checklist",
							expr: &zeroOrOneExpr{
								pos: position{line: 1562, col: 60, offset: 47269},
								expr: &ruleRefExpr{
									pos:    position{line: 1562, col: 61, offset: 47270},
									offset: 264,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1562, col: 73, offset: 47282},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1562, col: 80, offset: 47289},
								offset: 217,
							},
						},
					},
				},
			},
		},
		{
			name: "UnorderedListMarker",
			pos:  position{line: 1569, col: 1, offset: 47533},
			expr: &actionExpr{
				pos: position{line: 1569, col: 23, offset: 47555},
				run: (*parser).callonUnorderedListMarker1,
				expr: &seqExpr{
					pos: position{line: 1569, col: 23, offset: 47555},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1569, col: 23, offset: 47555},
							label: "indent",
							expr: &ruleRefExpr{
								pos:    position{line: 1569, col: 31, offset: 47563},
								offset: 334,
							},
						},
						&labeledExpr{
							pos:   position{line: 1569, col: 42, offset: 47574},
							label: "marker",
							expr: &actionExpr{
								pos: position{line: 1569, col: 50, offset: 47582},
								run: (*parser).callonUnorderedListMarker6,
								expr: &choiceExpr{
									pos: position{line: 1569, col: 51, offset: 47583},
									alternatives: []any{
										&oneOrMoreExpr{
											pos: position{line: 1569, col: 51, offset: 47583},
											expr: &litMatcher{
												pos:        position{line: 1569, col: 51, offset: 47583},
												val:        "*",
												ignoreCase: false,
												want:       "\"*\"",
											},
										},
										&oneOrMoreExpr{
											pos: position{line: 1569, col: 58, offset: 47590},
											expr: &litMatcher{
												pos:        position{line: 1569, col: 58, offset: 47590},
												val:        "-",
												ignoreCase: false,
												want:       "\"-\"",
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1571, col: 4, offset: 47632},
							run: (*parser).callonUnorderedListMarker12,
						},
						&ruleRefExpr{
							pos:    position{line: 1574, col: 1, offset: 47681},
							offset: 338,
						},
					},
				},
			},
		},
		{
			name: "Checklist",
			pos:  position{line: 1580, col: 1, offset: 47766},
			expr: &actionExpr{
				pos: position{line: 1580, col: 13, offset: 47778},
				run: (*parser).callonChecklist1,
				expr: &seqExpr{
					pos: position{line: 1580, col: 13, offset: 47778},
					exprs: []any{
						&andExpr{
							pos: position{line: 1580, col: 13, offset: 47778},
							expr: &litMatcher{
								pos:        position{line: 1580, col: 14, offset: 47779},
								val:        "[",
								ignoreCase: false,
								want:       "\"[\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1581, col: 1, offset: 47784},
							label: "checklist",
							expr: &choiceExpr{
								pos: position{line: 1582, col: 7, offset: 47802},
								alternatives: []any{
									&actionExpr{
										pos: position{line: 1582, col: 7, offset: 47802},
										run: (*parser).callonChecklist7,
										expr: &litMatcher{
											pos:        position{line: 1582, col: 7, offset: 47802},
											val:        "[ ]",
											ignoreCase: false,
											want:       "\"[ ]\"",
										},
									},
									&actionExpr{
										pos: position{line: 1583, col: 7, offset: 47859},
										run: (*parser).callonChecklist9,
										expr: &litMatcher{
											pos:        position{line: 1583, col: 7, offset: 47859},
											val:        "[*]",
											ignoreCase: false,
											want:       "\"[*]\"",
										},
									},
									&actionExpr{
										pos: position{line: 1584, col: 7, offset: 47914},
										run: (*parser).callonChecklist11,
										expr: &litMatcher{
											pos:        position{line: 1584, col: 7, offset: 47914},
											val:        "[x]",
											ignoreCase: false,
											want:       "\"[x]\"",
										},
									},
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1585, col: 7, offset: 47968},
							offset: 338,
						},
					},
				},
			},
		},
		{
			name: "DescriptionListItem",
			pos:  position{line: 1590, col: 1, offset: 48011},
			expr: &actionExpr{
				pos: position{line: 1590, col: 23, offset: 48033},
				run: (*parser).callonDescriptionListItem1,
				expr: &seqExpr{
					pos: position{line: 1590, col: 23, offset: 48033},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1590, col: 23, offset: 48033},
							label: "inlineAnchor",
							expr: &zeroOrOneExpr{
								pos: position{line: 1590, col: 36, offset: 48046},
								expr: &ruleRefExpr{
									pos:    position{line: 1590, col: 37, offset: 48047},
									offset: 85,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1590, col: 55, offset: 48065},
							label: "term",
							expr: &ruleRefExpr{
								pos:    position{line: 1590, col: 61, offset: 48071},
								offset: 266,
							},
						},
						&labeledExpr{
							pos:   position{line: 1590, col: 82, offset: 48092},
							label: "marker",
							expr: &ruleRefExpr{
								pos:    position{line: 1590, col: 90, offset: 48100},
								offset: 267,
							},
						},
						&labeledExpr{
							pos:   position{line: 1590, col: 113, offset: 48123},
							label: "whitespace",
							expr: &oneOrMoreExpr{
								pos: position{line: 1590, col: 124, offset: 48134},
								expr: &choiceExpr{
									pos: position{line: 1590, col: 125, offset: 48135},
									alternatives: []any{
										&actionExpr{
											pos: position{line: 1590, col: 125, offset: 48135},
											run: (*parser).callonDescriptionListItem13,
											expr: &ruleRefExpr{
												pos:    position{line: 1590, col: 125, offset: 48135},
												offset: 339,
											},
										},
										&ruleRefExpr{
											pos:    position{line: 1590, col: 180, offset: 48190},
											offset: 317,
										},
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1590, col: 190, offset: 48200},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1590, col: 197, offset: 48207},
								offset: 268,
							},
						},
					},
				},
			},
		},
		{
			name: "DescriptionListTerm",
			pos:  position{line: 1601, col: 1, offset: 48734},
			expr: &actionExpr{
				pos: position{line: 1601, col: 23, offset: 48756},
				run: (*parser).callonDescriptionListTerm1,
				expr: &labeledExpr{
					pos:   position{line: 1601, col: 23, offset: 48756},
					label: "term",
					expr: &oneOrMoreExpr{
						pos: position{line: 1601, col: 28, offset: 48761},
						expr: &seqExpr{
							pos: position{line: 1601, col: 29, offset: 48762},
							exprs: []any{
								&notExpr{
									pos: position{line: 1601, col: 29, offset: 48762},
									expr: &ruleRefExpr{
										pos:    position{line: 1601, col: 30, offset: 48763},
										offset: 267,
									},
								},
								&notExpr{
									pos: position{line: 1601, col: 52, offset: 48785},
									expr: &ruleRefExpr{
										pos:    position{line: 1601, col: 53, offset: 48786},
										offset: 330,
									},
								},
								&ruleRefExpr{
									pos:    position{line: 1601, col: 63, offset: 48796},
									offset: 90,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DescriptionListMarker",
			pos:  position{line: 1605, col: 1, offset: 48852},
			expr: &actionExpr{
				pos: position{line: 1605, col: 25, offset: 48876},
				run: (*parser).callonDescriptionListMarker1,
				expr: &seqExpr{
					pos: position{line: 1605, col: 25, offset: 48876},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1605, col: 25, offset: 48876},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1605, col: 35, offset: 48886},
							label: "marker",
							expr: &actionExpr{
								pos: position{line: 1605, col: 43, offset: 48894},
								run: (*parser).callonDescriptionListMarker5,
								expr: &oneOrMoreExpr{
									pos: position{line: 1605, col: 43, offset: 48894},
									expr: &choiceExpr{
										pos: position{line: 1605, col: 44, offset: 48895},
										alternatives: []any{
											&litMatcher{
												pos:        position{line: 1605, col: 44, offset: 48895},
												val:        ":",
												ignoreCase: false,
												want:       "\":\"",
											},
											&litMatcher{
												pos:        position{line: 1605, col: 50, offset: 48901},
												val:        ";",
												ignoreCase: false,
												want:       "\";\"",
											},
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1607, col: 4, offset: 48943},
							run: (*parser).callonDescriptionListMarker10,
						},
						&ruleRefExpr{
							pos:    position{line: 1614, col: 1, offset: 49070},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "DescriptionListItemValue",
			pos:  position{line: 1619, col: 1, offset: 49117},
			expr: &actionExpr{
				pos: position{line: 1619, col: 28, offset: 49144},
				run: (*parser).callonDescriptionListItemValue1,
				expr: &seqExpr{
					pos: position{line: 1619, col: 28, offset: 49144},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1619, col: 28, offset: 49144},
							label: "line",
							expr: &choiceExpr{
								pos: position{line: 1619, col: 34, offset: 49150},
								alternatives: []any{
									&oneOrMoreExpr{
										pos: position{line: 1619, col: 34, offset: 49150},
										expr: &ruleRefExpr{
											pos:    position{line: 1619, col: 34, offset: 49150},
											offset: 90,
										},
									},
									&ruleRefExpr{
										pos:    position{line: 1619, col: 51, offset: 49167},
										offset: 2,
									},
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1619, col: 65, offset: 49181},
							label: "attachedBlocks",
							expr: &zeroOrOneExpr{
								pos: position{line: 1619, col: 80, offset: 49196},
								expr: &ruleRefExpr{
									pos:    position{line: 1619, col: 81, offset: 49197},
									offset: 221,
								},
							},
						},
						&andExpr{
							pos: position{line: 1619, col: 99, offset: 49215},
							expr: &ruleRefExpr{
								pos:    position{line: 1619, col: 100, offset: 49216},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineComment",
			pos:  position{line: 1628, col: 1, offset: 49377},
			expr: &actionExpr{
				pos: position{line: 1628, col: 21, offset: 49397},
				run: (*parser).callonSingleLineComment1,
				expr: &seqExpr{
					pos: position{line: 1628, col: 21, offset: 49397},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1628, col: 21, offset: 49397},
							offset: 270,
						},
						&notExpr{
							pos: position{line: 1628, col: 48, offset: 49424},
							expr: &litMatcher{
								pos:        position{line: 1628, col: 49, offset: 49425},
								val:        "//",
								ignoreCase: false,
								want:       "\"//\"",
							},
						},
						&labeledExpr{
							pos:   position{line: 1628, col: 54, offset: 49430},
							label: "comment",
							expr: &ruleRefExpr{
								pos:    position{line: 1628, col: 63, offset: 49439},
								offset: 271,
							},
						},
						&andExpr{
							pos: position{line: 1628, col: 89, offset: 49465},
							expr: &ruleRefExpr{
								pos:    position{line: 1628, col: 90, offset: 49466},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "SingleLineCommentDelimiter",
			pos:  position{line: 1632, col: 1, offset: 49556},
			expr: &actionExpr{
				pos: position{line: 1632, col: 30, offset: 49585},
				run: (*parser).callonSingleLineCommentDelimiter1,
				expr: &litMatcher{
					pos:        position{line: 1632, col: 30, offset: 49585},
					val:        "//",
					ignoreCase: false,
					want:       "\"//\"",
				},
			},
		},
		{
			name: "SingleLineCommentContent",
			pos:  position{line: 1636, col: 1, offset: 49630},
			expr: &actionExpr{
				pos: position{line: 1636, col: 28, offset: 49657},
				run: (*parser).callonSingleLineCommentContent1,
				expr: &zeroOrMoreExpr{
					pos: position{line: 1636, col: 28, offset: 49657},
					expr: &charClassMatcher{
						pos:        position{line: 1636, col: 28, offset: 49657},
						val:        "[^\\r\\n]",
						chars:      []rune{'\r', '\n'},
						ignoreCase: false,
						inverted:   true,
					},
				},
			},
		},
		{
			name: "MultiLineComment",
			pos:  position{line: 1640, col: 1, offset: 49706},
			expr: &actionExpr{
				pos: position{line: 1641, col: 5, offset: 49729},
				run: (*parser).callonMultiLineComment1,
				expr: &seqExpr{
					pos: position{line: 1641, col: 5, offset: 49729},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1641, col: 5, offset: 49729},
							label: "start",
							expr: &ruleRefExpr{
								pos:    position{line: 1641, col: 12, offset: 49736},
								offset: 273,
							},
						},
						&labeledExpr{
							pos:   position{line: 1642, col: 5, offset: 49763},
							label: "lines",
							expr: &zeroOrMoreExpr{
								pos: position{line: 1642, col: 11, offset: 49769},
								expr: &ruleRefExpr{
									pos:    position{line: 1642, col: 12, offset: 49770},
									offset: 277,
								},
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1643, col: 5, offset: 49797},
							offset: 274,
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentStart",
			pos:  position{line: 1647, col: 1, offset: 49982},
			expr: &actionExpr{
				pos: position{line: 1647, col: 25, offset: 50006},
				run: (*parser).callonMultiLineCommentStart1,
				expr: &seqExpr{
					pos: position{line: 1647, col: 25, offset: 50006},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1647, col: 25, offset: 50006},
							label: "delimiter",
							expr: &ruleRefExpr{
								pos:    position{line: 1647, col: 35, offset: 50016},
								offset: 276,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1647, col: 61, offset: 50042},
							offset: 330,
						},
						&andCodeExpr{
							pos: position{line: 1647, col: 72, offset: 50053},
							run: (*parser).callonMultiLineCommentStart6,
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentEnd",
			pos:  position{line: 1654, col: 1, offset: 50243},
			expr: &seqExpr{
				pos: position{line: 1654, col: 23, offset: 50265},
				exprs: []any{
					&labeledExpr{
						pos:   position{line: 1654, col: 23, offset: 50265},
						label: "delimiter",
						expr: &ruleRefExpr{
							pos:    position{line: 1654, col: 33, offset: 50275},
							offset: 276,
						},
					},
					&andExpr{
						pos: position{line: 1654, col: 59, offset: 50301},
						expr: &ruleRefExpr{
							pos:    position{line: 1654, col: 60, offset: 50302},
							offset: 330,
						},
					},
					&andCodeExpr{
						pos: position{line: 1654, col: 70, offset: 50312},
						run: (*parser).callonMultiLineCommentEnd6,
					},
				},
			},
		},
		{
			name: "MultiLineCommentForwardSlashes",
			pos:  position{line: 1663, col: 1, offset: 50598},
			expr: &actionExpr{
				pos: position{line: 1663, col: 34, offset: 50631},
				run: (*parser).callonMultiLineCommentForwardSlashes1,
				expr: &seqExpr{
					pos: position{line: 1663, col: 34, offset: 50631},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1663, col: 34, offset: 50631},
							label: "forwardSlashes",
							expr: &seqExpr{
								pos: position{line: 1663, col: 50, offset: 50647},
								exprs: []any{
									&litMatcher{
										pos:        position{line: 1663, col: 50, offset: 50647},
										val:        "////",
										ignoreCase: false,
										want:       "\"////\"",
									},
									&zeroOrMoreExpr{
										pos: position{line: 1663, col: 57, offset: 50654},
										expr: &litMatcher{
											pos:        position{line: 1663, col: 57, offset: 50654},
											val:        "/",
											ignoreCase: false,
											want:       "\"/\"",
										},
									},
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1663, col: 63, offset: 50660},
							run: (*parser).callonMultiLineCommentForwardSlashes8,
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentDelimiter",
			pos:  position{line: 1670, col: 1, offset: 50805},
			expr: &actionExpr{
				pos: position{line: 1670, col: 29, offset: 50833},
				run: (*parser).callonMultiLineCommentDelimiter1,
				expr: &seqExpr{
					pos: position{line: 1670, col: 29, offset: 50833},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1670, col: 29, offset: 50833},
							label: "forwardSlashes",
							expr: &ruleRefExpr{
								pos:    position{line: 1670, col: 45, offset: 50849},
								offset: 275,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1671, col: 5, offset: 50886},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "MultiLineCommentLine",
			pos:  position{line: 1676, col: 1, offset: 51037},
			expr: &actionExpr{
				pos: position{line: 1676, col: 24, offset: 51060},
				run: (*parser).callonMultiLineCommentLine1,
				expr: &seqExpr{
					pos: position{line: 1676, col: 25, offset: 51061},
					exprs: []any{
						&notExpr{
							pos: position{line: 1676, col: 25, offset: 51061},
							expr: &ruleRefExpr{
								pos:    position{line: 1676, col: 26, offset: 51062},
								offset: 276,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1676, col: 52, offset: 51088},
							offset: 325,
						},
						&labeledExpr{
							pos:   position{line: 1676, col: 65, offset: 51101},
							label: "line",
							expr: &ruleRefExpr{
								pos:    position{line: 1676, col: 70, offset: 51106},
								offset: 333,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1676, col: 78, offset: 51114},
							offset: 330,
						},
					},
				},
			},
		},
		{
			name: "Counter",
			pos:  position{line: 1682, col: 1, offset: 51163},
			expr: &choiceExpr{
				pos: position{line: 1682, col: 11, offset: 51173},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1682, col: 11, offset: 51173},
						offset: 279,
					},
					&ruleRefExpr{
						pos:    position{line: 1682, col: 30, offset: 51192},
						offset: 280,
					},
				},
			},
		},
		{
			name: "CounterIncrement",
			pos:  position{line: 1684, col: 1, offset: 51216},
			expr: &actionExpr{
				pos: position{line: 1684, col: 20, offset: 51235},
				run: (*parser).callonCounterIncrement1,
				expr: &seqExpr{
					pos: position{line: 1684, col: 20, offset: 51235},
					exprs: []any{
						&notExpr{
							pos: position{line: 1684, col: 20, offset: 51235},
							expr: &litMatcher{
								pos:        position{line: 1684, col: 21, offset: 51236},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 1684, col: 26, offset: 51241},
							val:        "{counter:",
							ignoreCase: false,
							want:       "\"{counter:\"",
						},
						&labeledExpr{
							pos:   position{line: 1684, col: 38, offset: 51253},
							label: "name",
							expr: &ruleRefExpr{
								pos:    position{line: 1684, col: 43, offset: 51258},
								offset: 23,
							},
						},
						&labeledExpr{
							pos:   position{line: 1684, col: 62, offset: 51277},
							label: "initialValue",
							expr: &zeroOrOneExpr{
								pos: position{line: 1684, col: 75, offset: 51290},
								expr: &ruleRefExpr{
									pos:    position{line: 1684, col: 76, offset: 51291},
									offset: 281,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1684, col: 98, offset: 51313},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
					},
				},
			},
		},
		{
			name: "CounterSilentIncrement",
			pos:  position{line: 1688, col: 1, offset: 51414},
			expr: &actionExpr{
				pos: position{line: 1688, col: 26, offset: 51439},
				run: (*parser).callonCounterSilentIncrement1,
				expr: &seqExpr{
					pos: position{line: 1688, col: 26, offset: 51439},
					exprs: []any{
						&notExpr{
							pos: position{line: 1688, col: 26, offset: 51439},
							expr: &litMatcher{
								pos:        position{line: 1688, col: 27, offset: 51440},
								val:        "\\",
								ignoreCase: false,
								want:       "\"\\\\\"",
							},
						},
						&litMatcher{
							pos:        position{line: 1688, col: 32, offset: 51445},
							val:        "{counter2:",
							ignoreCase: false,
							want:       "\"{counter2:\"",
						},
						&labeledExpr{
							pos:   position{line: 1688, col: 45, offset: 51458},
							label: "name",
							expr: &ruleRefExpr{
								pos:    position{line: 1688, col: 50, offset: 51463},
								offset: 23,
							},
						},
						&labeledExpr{
							pos:   position{line: 1688, col: 69, offset: 51482},
							label: "initialValue",
							expr: &zeroOrOneExpr{
								pos: position{line: 1688, col: 82, offset: 51495},
								expr: &ruleRefExpr{
									pos:    position{line: 1688, col: 83, offset: 51496},
									offset: 281,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1688, col: 105, offset: 51518},
							val:        "}",
							ignoreCase: false,
							want:       "\"}\"",
						},
					},
				},
			},
		},
		{
			name: "CounterInitialValue",
			pos:  position{line: 1692, col: 1, offset: 51620},
			expr: &actionExpr{
				pos: position{line: 1692, col: 23, offset: 51642},
				run: (*parser).callonCounterInitialValue1,
				expr: &seqExpr{
					pos: position{line: 1692, col: 23, offset: 51642},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1692, col: 23, offset: 51642},
							val:        ":",
							ignoreCase: false,
							want:       "\":\"",
						},
						&labeledExpr{
							pos:   position{line: 1692, col: 27, offset: 51646},
							label: "initializer",
							expr: &ruleRefExpr{
								pos:    position{line: 1692, col: 40, offset: 51659},
								offset: 282,
							},
						},
					},
				},
			},
		},
		{
			name: "CounterInitializer",
			pos:  position{line: 1696, col: 1, offset: 51712},
			expr: &choiceExpr{
				pos: position{line: 1696, col: 23, offset: 51734},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1696, col: 23, offset: 51734},
						run: (*parser).callonCounterInitializer2,
						expr: &charClassMatcher{
							pos:        position{line: 1696, col: 23, offset: 51734},
							val:        "[a-zA-Z]",
							ranges:     []rune{'a', 'z', 'A', 'Z'},
							ignoreCase: false,
							inverted:   false,
						},
					},
					&actionExpr{
						pos: position{line: 1699, col: 7, offset: 51790},
						run: (*parser).callonCounterInitializer4,
						expr: &oneOrMoreExpr{
							pos: position{line: 1699, col: 7, offset: 51790},
							expr: &charClassMatcher{
								pos:        position{line: 1699, col: 7, offset: 51790},
								val:        "[0-9]",
								ranges:     []rune{'0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
						},
					},
				},
			},
		},
		{
			name: "InlinePassthrough",
			pos:  position{line: 1706, col: 1, offset: 51856},
			expr: &actionExpr{
				pos: position{line: 1706, col: 21, offset: 51876},
				run: (*parser).callonInlinePassthrough1,
				expr: &seqExpr{
					pos: position{line: 1706, col: 21, offset: 51876},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1706, col: 21, offset: 51876},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 1706, col: 32, offset: 51887},
								expr: &ruleRefExpr{
									pos:    position{line: 1706, col: 33, offset: 51888},
									offset: 97,
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1706, col: 53, offset: 51908},
							label: "text",
							expr: &choiceExpr{
								pos: position{line: 1706, col: 59, offset: 51914},
								alternatives: []any{
									&ruleRefExpr{
										pos:    position{line: 1706, col: 59, offset: 51914},
										offset: 284,
									},
									&ruleRefExpr{
										pos:    position{line: 1706, col: 85, offset: 51940},
										offset: 287,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineSinglePassthrough",
			pos:  position{line: 1710, col: 1, offset: 52086},
			expr: &actionExpr{
				pos: position{line: 1710, col: 27, offset: 52112},
				run: (*parser).callonInlineSinglePassthrough1,
				expr: &seqExpr{
					pos: position{line: 1710, col: 27, offset: 52112},
					exprs: []any{
						&notExpr{
							pos: position{line: 1710, col: 27, offset: 52112},
							expr: &ruleRefExpr{
								pos:    position{line: 1710, col: 28, offset: 52113},
								offset: 340,
							},
						},
						&litMatcher{
							pos:        position{line: 1710, col: 35, offset: 52120},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&andExpr{
							pos: position{line: 1710, col: 39, offset: 52124},
							expr: &notExpr{
								pos: position{line: 1710, col: 41, offset: 52126},
								expr: &litMatcher{
									pos:        position{line: 1710, col: 42, offset: 52127},
									val:        "+",
									ignoreCase: false,
									want:       "\"+\"",
								},
							},
						},
						&labeledExpr{
							pos:   position{line: 1710, col: 47, offset: 52132},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1710, col: 54, offset: 52139},
								offset: 285,
							},
						},
						&litMatcher{
							pos:        position{line: 1710, col: 82, offset: 52167},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&notExpr{
							pos: position{line: 1710, col: 86, offset: 52171},
							expr: &litMatcher{
								pos:        position{line: 1710, col: 87, offset: 52172},
								val:        "+",
								ignoreCase: false,
								want:       "\"+\"",
							},
						},
						&andExpr{
							pos: position{line: 1710, col: 91, offset: 52176},
							expr: &notExpr{
								pos: position{line: 1710, col: 93, offset: 52178},
								expr: &ruleRefExpr{
									pos:    position{line: 1710, col: 94, offset: 52179},
									offset: 323,
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SinglePassthroughTextValue",
			pos:  position{line: 1714, col: 1, offset: 52224},
			expr: &actionExpr{
				pos: position{line: 1714, col: 30, offset: 52253},
				run: (*parser).callonSinglePassthroughTextValue1,
				expr: &seqExpr{
					pos: position{line: 1714, col: 30, offset: 52253},
					exprs: []any{
						&notExpr{
							pos: position{line: 1714, col: 30, offset: 52253},
							expr: &ruleRefExpr{
								pos:    position{line: 1714, col: 31, offset: 52254},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 1714, col: 33, offset: 52256},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1714, col: 39, offset: 52262},
								expr: &actionExpr{
									pos: position{line: 1714, col: 40, offset: 52263},
									run: (*parser).callonSinglePassthroughTextValue7,
									expr: &seqExpr{
										pos: position{line: 1714, col: 40, offset: 52263},
										exprs: []any{
											&notExpr{
												pos: position{line: 1714, col: 40, offset: 52263},
												expr: &ruleRefExpr{
													pos:    position{line: 1714, col: 41, offset: 52264},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 1714, col: 43, offset: 52266},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1714, col: 49, offset: 52272},
													expr: &ruleRefExpr{
														pos:    position{line: 1714, col: 50, offset: 52273},
														offset: 286,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "SinglePassthroughTextElement",
			pos:  position{line: 1718, col: 1, offset: 52454},
			expr: &seqExpr{
				pos: position{line: 1718, col: 32, offset: 52485},
				exprs: []any{
					&notExpr{
						pos: position{line: 1718, col: 32, offset: 52485},
						expr: &seqExpr{
							pos: position{line: 1718, col: 34, offset: 52487},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1718, col: 34, offset: 52487},
									val:        "+",
									ignoreCase: false,
									want:       "\"+\"",
								},
								&notExpr{
									pos: position{line: 1718, col: 38, offset: 52491},
									expr: &litMatcher{
										pos:        position{line: 1718, col: 39, offset: 52492},
										val:        "+",
										ignoreCase: false,
										want:       "\"+\"",
									},
								},
							},
						},
					},
					&ruleRefExpr{
						pos:    position{line: 1718, col: 44, offset: 52497},
						offset: 96,
					},
				},
			},
		},
		{
			name: "InlineDoublePassthrough",
			pos:  position{line: 1720, col: 1, offset: 52519},
			expr: &actionExpr{
				pos: position{line: 1720, col: 27, offset: 52545},
				run: (*parser).callonInlineDoublePassthrough1,
				expr: &seqExpr{
					pos: position{line: 1720, col: 27, offset: 52545},
					exprs: []any{
						&notExpr{
							pos: position{line: 1720, col: 27, offset: 52545},
							expr: &ruleRefExpr{
								pos:    position{line: 1720, col: 28, offset: 52546},
								offset: 341,
							},
						},
						&litMatcher{
							pos:        position{line: 1720, col: 41, offset: 52559},
							val:        "++",
							ignoreCase: false,
							want:       "\"++\"",
						},
						&labeledExpr{
							pos:   position{line: 1720, col: 46, offset: 52564},
							label: "value",
							expr: &ruleRefExpr{
								pos:    position{line: 1720, col: 53, offset: 52571},
								offset: 288,
							},
						},
						&litMatcher{
							pos:        position{line: 1720, col: 81, offset: 52599},
							val:        "++",
							ignoreCase: false,
							want:       "\"++\"",
						},
					},
				},
			},
		},
		{
			name: "DoublePassthroughTextValue",
			pos:  position{line: 1724, col: 1, offset: 52636},
			expr: &actionExpr{
				pos: position{line: 1724, col: 30, offset: 52665},
				run: (*parser).callonDoublePassthroughTextValue1,
				expr: &seqExpr{
					pos: position{line: 1724, col: 30, offset: 52665},
					exprs: []any{
						&notExpr{
							pos: position{line: 1724, col: 30, offset: 52665},
							expr: &ruleRefExpr{
								pos:    position{line: 1724, col: 31, offset: 52666},
								offset: 339,
							},
						},
						&labeledExpr{
							pos:   position{line: 1724, col: 33, offset: 52668},
							label: "value",
							expr: &oneOrMoreExpr{
								pos: position{line: 1724, col: 39, offset: 52674},
								expr: &actionExpr{
									pos: position{line: 1724, col: 40, offset: 52675},
									run: (*parser).callonDoublePassthroughTextValue7,
									expr: &seqExpr{
										pos: position{line: 1724, col: 40, offset: 52675},
										exprs: []any{
											&notExpr{
												pos: position{line: 1724, col: 40, offset: 52675},
												expr: &ruleRefExpr{
													pos:    position{line: 1724, col: 41, offset: 52676},
													offset: 339,
												},
											},
											&labeledExpr{
												pos:   position{line: 1724, col: 43, offset: 52678},
												label: "value",
												expr: &oneOrMoreExpr{
													pos: position{line: 1724, col: 49, offset: 52684},
													expr: &ruleRefExpr{
														pos:    position{line: 1724, col: 50, offset: 52685},
														offset: 289,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "DoublePassthroughTextElement",
			pos:  position{line: 1728, col: 1, offset: 52878},
			expr: &seqExpr{
				pos: position{line: 1728, col: 32, offset: 52909},
				exprs: []any{
					&notExpr{
						pos: position{line: 1728, col: 32, offset: 52909},
						expr: &litMatcher{
							pos:        position{line: 1728, col: 34, offset: 52911},
							val:        "++",
							ignoreCase: false,
							want:       "\"++\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 1728, col: 40, offset: 52917},
						offset: 96,
					},
				},
			},
		},
		{
			name: "IfDefStatement",
			pos:  position{line: 1731, col: 1, offset: 52940},
			expr: &litMatcher{
				pos:        position{line: 1731, col: 18, offset: 52957},
				val:        "ifdef::",
				ignoreCase: false,
				want:       "\"ifdef::\"",
			},
		},
		{
			name: "IfDef",
			pos:  position{line: 1733, col: 1, offset: 52969},
			expr: &actionExpr{
				pos: position{line: 1733, col: 9, offset: 52977},
				run: (*parser).callonIfDef1,
				expr: &seqExpr{
					pos: position{line: 1733, col: 9, offset: 52977},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1733, col: 9, offset: 52977},
							offset: 290,
						},
						&labeledExpr{
							pos:   position{line: 1733, col: 24, offset: 52992},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 1733, col: 36, offset: 53004},
								offset: 298,
							},
						},
						&litMatcher{
							pos:        position{line: 1733, col: 59, offset: 53027},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1733, col: 64, offset: 53032},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1733, col: 75, offset: 53043},
							expr: &ruleRefExpr{
								pos:    position{line: 1733, col: 76, offset: 53044},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "IfNDefStatement",
			pos:  position{line: 1738, col: 1, offset: 53164},
			expr: &litMatcher{
				pos:        position{line: 1738, col: 19, offset: 53182},
				val:        "ifndef::",
				ignoreCase: false,
				want:       "\"ifndef::\"",
			},
		},
		{
			name: "IfNDef",
			pos:  position{line: 1741, col: 1, offset: 53196},
			expr: &actionExpr{
				pos: position{line: 1741, col: 10, offset: 53205},
				run: (*parser).callonIfNDef1,
				expr: &seqExpr{
					pos: position{line: 1741, col: 10, offset: 53205},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1741, col: 10, offset: 53205},
							offset: 292,
						},
						&labeledExpr{
							pos:   position{line: 1741, col: 26, offset: 53221},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 1741, col: 38, offset: 53233},
								offset: 298,
							},
						},
						&litMatcher{
							pos:        position{line: 1741, col: 61, offset: 53256},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1741, col: 66, offset: 53261},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1741, col: 77, offset: 53272},
							expr: &ruleRefExpr{
								pos:    position{line: 1741, col: 78, offset: 53273},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "InlineIfDef",
			pos:  position{line: 1746, col: 1, offset: 53395},
			expr: &actionExpr{
				pos: position{line: 1746, col: 15, offset: 53409},
				run: (*parser).callonInlineIfDef1,
				expr: &seqExpr{
					pos: position{line: 1746, col: 15, offset: 53409},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1746, col: 15, offset: 53409},
							offset: 290,
						},
						&labeledExpr{
							pos:   position{line: 1746, col: 30, offset: 53424},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 1746, col: 42, offset: 53436},
								offset: 298,
							},
						},
						&litMatcher{
							pos:        position{line: 1746, col: 65, offset: 53459},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 1746, col: 69, offset: 53463},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 1746, col: 78, offset: 53472},
								offset: 301,
							},
						},
						&litMatcher{
							pos:        position{line: 1746, col: 104, offset: 53498},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1746, col: 108, offset: 53502},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "InlineIfNDef",
			pos:  position{line: 1751, col: 1, offset: 53680},
			expr: &actionExpr{
				pos: position{line: 1751, col: 16, offset: 53695},
				run: (*parser).callonInlineIfNDef1,
				expr: &seqExpr{
					pos: position{line: 1751, col: 16, offset: 53695},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1751, col: 16, offset: 53695},
							offset: 292,
						},
						&labeledExpr{
							pos:   position{line: 1751, col: 32, offset: 53711},
							label: "attributes",
							expr: &ruleRefExpr{
								pos:    position{line: 1751, col: 44, offset: 53723},
								offset: 298,
							},
						},
						&litMatcher{
							pos:        position{line: 1751, col: 67, offset: 53746},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&labeledExpr{
							pos:   position{line: 1751, col: 71, offset: 53750},
							label: "content",
							expr: &ruleRefExpr{
								pos:    position{line: 1751, col: 80, offset: 53759},
								offset: 301,
							},
						},
						&litMatcher{
							pos:        position{line: 1751, col: 106, offset: 53785},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1751, col: 110, offset: 53789},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "EndIfDefStatement",
			pos:  position{line: 1756, col: 1, offset: 53969},
			expr: &litMatcher{
				pos:        position{line: 1756, col: 21, offset: 53989},
				val:        "endif::",
				ignoreCase: false,
				want:       "\"endif::\"",
			},
		},
		{
			name: "EndIfDef",
			pos:  position{line: 1758, col: 1, offset: 54001},
			expr: &actionExpr{
				pos: position{line: 1758, col: 12, offset: 54012},
				run: (*parser).callonEndIfDef1,
				expr: &seqExpr{
					pos: position{line: 1758, col: 12, offset: 54012},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1758, col: 12, offset: 54012},
							offset: 296,
						},
						&labeledExpr{
							pos:   position{line: 1758, col: 30, offset: 54030},
							label: "attributes",
							expr: &zeroOrOneExpr{
								pos: position{line: 1758, col: 41, offset: 54041},
								expr: &ruleRefExpr{
									pos:    position{line: 1758, col: 42, offset: 54042},
									offset: 298,
								},
							},
						},
						&litMatcher{
							pos:        position{line: 1758, col: 66, offset: 54066},
							val:        "[]",
							ignoreCase: false,
							want:       "\"[]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1758, col: 72, offset: 54072},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1758, col: 82, offset: 54082},
							expr: &ruleRefExpr{
								pos:    position{line: 1758, col: 83, offset: 54083},
								offset: 330,
							},
						},
					},
				},
			},
		},
		{
			name: "ConditionalAttributes",
			pos:  position{line: 1768, col: 1, offset: 54370},
			expr: &choiceExpr{
				pos: position{line: 1768, col: 25, offset: 54394},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1768, col: 25, offset: 54394},
						offset: 299,
					},
					&ruleRefExpr{
						pos:    position{line: 1768, col: 52, offset: 54421},
						offset: 300,
					},
				},
			},
		},
		{
			name: "ConditionalAttributesAny",
			pos:  position{line: 1770, col: 1, offset: 54447},
			expr: &actionExpr{
				pos: position{line: 1770, col: 28, offset: 54474},
				run: (*parser).callonConditionalAttributesAny1,
				expr: &labeledExpr{
					pos:   position{line: 1770, col: 28, offset: 54474},
					label: "names",
					expr: &oneOrMoreExpr{
						pos: position{line: 1770, col: 34, offset: 54480},
						expr: &actionExpr{
							pos: position{line: 1771, col: 5, offset: 54486},
							run: (*parser).callonConditionalAttributesAny4,
							expr: &seqExpr{
								pos: position{line: 1771, col: 5, offset: 54486},
								exprs: []any{
									&labeledExpr{
										pos:   position{line: 1771, col: 5, offset: 54486},
										label: "name",
										expr: &ruleRefExpr{
											pos:    position{line: 1771, col: 10, offset: 54491},
											offset: 23,
										},
									},
									&ruleRefExpr{
										pos:    position{line: 1771, col: 29, offset: 54510},
										offset: 334,
									},
									&zeroOrOneExpr{
										pos: position{line: 1771, col: 39, offset: 54520},
										expr: &litMatcher{
											pos:        position{line: 1771, col: 39, offset: 54520},
											val:        ",",
											ignoreCase: false,
											want:       "\",\"",
										},
									},
									&ruleRefExpr{
										pos:    position{line: 1771, col: 44, offset: 54525},
										offset: 334,
									},
									&andCodeExpr{
										pos: position{line: 1772, col: 5, offset: 54540},
										run: (*parser).callonConditionalAttributesAny12,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "ConditionalAttributesAll",
			pos:  position{line: 1782, col: 1, offset: 54801},
			expr: &actionExpr{
				pos: position{line: 1782, col: 28, offset: 54828},
				run: (*parser).callonConditionalAttributesAll1,
				expr: &labeledExpr{
					pos:   position{line: 1782, col: 28, offset: 54828},
					label: "names",
					expr: &oneOrMoreExpr{
						pos: position{line: 1782, col: 34, offset: 54834},
						expr: &actionExpr{
							pos: position{line: 1783, col: 5, offset: 54840},
							run: (*parser).callonConditionalAttributesAll4,
							expr: &seqExpr{
								pos: position{line: 1783, col: 5, offset: 54840},
								exprs: []any{
									&labeledExpr{
										pos:   position{line: 1783, col: 5, offset: 54840},
										label: "name",
										expr: &ruleRefExpr{
											pos:    position{line: 1783, col: 10, offset: 54845},
											offset: 23,
										},
									},
									&ruleRefExpr{
										pos:    position{line: 1783, col: 29, offset: 54864},
										offset: 334,
									},
									&zeroOrOneExpr{
										pos: position{line: 1783, col: 39, offset: 54874},
										expr: &litMatcher{
											pos:        position{line: 1783, col: 39, offset: 54874},
											val:        "+",
											ignoreCase: false,
											want:       "\"+\"",
										},
									},
									&ruleRefExpr{
										pos:    position{line: 1783, col: 44, offset: 54879},
										offset: 334,
									},
									&andCodeExpr{
										pos: position{line: 1784, col: 5, offset: 54894},
										run: (*parser).callonConditionalAttributesAll12,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "InlineConditionalContent",
			pos:  position{line: 1794, col: 1, offset: 55155},
			expr: &seqExpr{
				pos: position{line: 1794, col: 28, offset: 55182},
				exprs: []any{
					&notExpr{
						pos: position{line: 1794, col: 28, offset: 55182},
						expr: &litMatcher{
							pos:        position{line: 1794, col: 29, offset: 55183},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
					},
					&oneOrMoreExpr{
						pos: position{line: 1794, col: 33, offset: 55187},
						expr: &ruleRefExpr{
							pos:    position{line: 1794, col: 33, offset: 55187},
							offset: 90,
						},
					},
				},
			},
		},
		{
			name: "IfEval",
			pos:  position{line: 1796, col: 1, offset: 55204},
			expr: &actionExpr{
				pos: position{line: 1796, col: 10, offset: 55213},
				run: (*parser).callonIfEval1,
				expr: &seqExpr{
					pos: position{line: 1796, col: 10, offset: 55213},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1796, col: 10, offset: 55213},
							offset: 303,
						},
						&litMatcher{
							pos:        position{line: 1796, col: 26, offset: 55229},
							val:        "[",
							ignoreCase: false,
							want:       "\"[\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1796, col: 30, offset: 55233},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1796, col: 40, offset: 55243},
							label: "left",
							expr: &ruleRefExpr{
								pos:    position{line: 1796, col: 46, offset: 55249},
								offset: 304,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1796, col: 59, offset: 55262},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1796, col: 70, offset: 55273},
							label: "operand",
							expr: &ruleRefExpr{
								pos:    position{line: 1796, col: 79, offset: 55282},
								offset: 305,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1796, col: 95, offset: 55298},
							offset: 334,
						},
						&labeledExpr{
							pos:   position{line: 1796, col: 105, offset: 55308},
							label: "right",
							expr: &ruleRefExpr{
								pos:    position{line: 1796, col: 112, offset: 55315},
								offset: 304,
							},
						},
						&ruleRefExpr{
							pos:    position{line: 1796, col: 125, offset: 55328},
							offset: 334,
						},
						&litMatcher{
							pos:        position{line: 1796, col: 135, offset: 55338},
							val:        "]",
							ignoreCase: false,
							want:       "\"]\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1796, col: 139, offset: 55342},
							offset: 334,
						},
					},
				},
			},
		},
		{
			name: "IfEvalStatement",
			pos:  position{line: 1800, col: 1, offset: 55497},
			expr: &litMatcher{
				pos:        position{line: 1800, col: 19, offset: 55515},
				val:        "ifeval::",
				ignoreCase: false,
				want:       "\"ifeval::\"",
			},
		},
		{
			name: "IfEvalValue",
			pos:  position{line: 1802, col: 1, offset: 55528},
			expr: &actionExpr{
				pos: position{line: 1802, col: 15, offset: 55542},
				run: (*parser).callonIfEvalValue1,
				expr: &labeledExpr{
					pos:   position{line: 1802, col: 15, offset: 55542},
					label: "val",
					expr: &choiceExpr{
						pos: position{line: 1802, col: 20, offset: 55547},
						alternatives: []any{
							&ruleRefExpr{
								pos:    position{line: 1802, col: 20, offset: 55547},
								offset: 38,
							},
							&ruleRefExpr{
								pos:    position{line: 1802, col: 48, offset: 55575},
								offset: 43,
							},
							&ruleRefExpr{
								pos:    position{line: 1802, col: 76, offset: 55603},
								offset: 47,
							},
						},
					},
				},
			},
		},
		{
			name: "IfEvalOperator",
			pos:  position{line: 1806, col: 1, offset: 55736},
			expr: &choiceExpr{
				pos: position{line: 1807, col: 7, offset: 55760},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1807, col: 8, offset: 55761},
						run: (*parser).callonIfEvalOperator2,
						expr: &litMatcher{
							pos:        position{line: 1807, col: 8, offset: 55761},
							val:        "==",
							ignoreCase: false,
							want:       "\"==\"",
						},
					},
					&actionExpr{
						pos: position{line: 1808, col: 8, offset: 55824},
						run: (*parser).callonIfEvalOperator4,
						expr: &litMatcher{
							pos:        position{line: 1808, col: 8, offset: 55824},
							val:        "!=",
							ignoreCase: false,
							want:       "\"!=\"",
						},
					},
					&actionExpr{
						pos: position{line: 1809, col: 8, offset: 55890},
						run: (*parser).callonIfEvalOperator6,
						expr: &litMatcher{
							pos:        position{line: 1809, col: 8, offset: 55890},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
					},
					&actionExpr{
						pos: position{line: 1810, col: 8, offset: 55956},
						run: (*parser).callonIfEvalOperator8,
						expr: &litMatcher{
							pos:        position{line: 1810, col: 8, offset: 55956},
							val:        "<=",
							ignoreCase: false,
							want:       "\"<=\"",
						},
					},
					&actionExpr{
						pos: position{line: 1811, col: 8, offset: 56029},
						run: (*parser).callonIfEvalOperator10,
						expr: &litMatcher{
							pos:        position{line: 1811, col: 8, offset: 56029},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
					},
					&actionExpr{
						pos: position{line: 1812, col: 8, offset: 56098},
						run: (*parser).callonIfEvalOperator12,
						expr: &litMatcher{
							pos:        position{line: 1812, col: 8, offset: 56098},
							val:        ">=",
							ignoreCase: false,
							want:       "\">=\"",
						},
					},
				},
			},
		},
		{
			name: "ConditionalStatement",
			pos:  position{line: 1814, col: 1, offset: 56168},
			expr: &choiceExpr{
				pos: position{line: 1814, col: 25, offset: 56192},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1814, col: 25, offset: 56192},
						offset: 290,
					},
					&ruleRefExpr{
						pos:    position{line: 1814, col: 42, offset: 56209},
						offset: 292,
					},
					&ruleRefExpr{
						pos:    position{line: 1814, col: 60, offset: 56227},
						offset: 303,
					},
					&ruleRefExpr{
						pos:    position{line: 1814, col: 78, offset: 56245},
						offset: 296,
					},
				},
			},
		},
		{
			name: "SpecialCharacter",
			pos:  position{line: 1817, col: 1, offset: 56266},
			expr: &actionExpr{
				pos: position{line: 1817, col: 20, offset: 56285},
				run: (*parser).callonSpecialCharacter1,
				expr: &choiceExpr{
					pos: position{line: 1817, col: 21, offset: 56286},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 1817, col: 21, offset: 56286},
							val:        "<",
							ignoreCase: false,
							want:       "\"<\"",
						},
						&litMatcher{
							pos:        position{line: 1817, col: 27, offset: 56292},
							val:        ">",
							ignoreCase: false,
							want:       "\">\"",
						},
						&litMatcher{
							pos:        position{line: 1817, col: 33, offset: 56298},
							val:        "&",
							ignoreCase: false,
							want:       "\"&\"",
						},
					},
				},
			},
		},
		{
			name: "SingleTilde",
			pos:  position{line: 1821, col: 1, offset: 56369},
			expr: &seqExpr{
				pos: position{line: 1821, col: 15, offset: 56383},
				exprs: []any{
					&litMatcher{
						pos:        position{line: 1821, col: 15, offset: 56383},
						val:        "`",
						ignoreCase: false,
						want:       "\"`\"",
					},
					&andExpr{
						pos: position{line: 1821, col: 19, offset: 56387},
						expr: &notExpr{
							pos: position{line: 1821, col: 21, offset: 56389},
							expr: &litMatcher{
								pos:        position{line: 1821, col: 22, offset: 56390},
								val:        "`",
								ignoreCase: false,
								want:       "\"`\"",
							},
						},
					},
				},
			},
		},
		{
			name: "Apostrophe",
			pos:  position{line: 1823, col: 1, offset: 56396},
			expr: &choiceExpr{
				pos: position{line: 1823, col: 15, offset: 56410},
				alternatives: []any{
					&actionExpr{
						pos: position{line: 1823, col: 15, offset: 56410},
						run: (*parser).callonApostrophe2,
						expr: &seqExpr{
							pos: position{line: 1823, col: 15, offset: 56410},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1823, col: 15, offset: 56410},
									val:        "\\'",
									ignoreCase: false,
									want:       "\"\\\\'\"",
								},
								&andExpr{
									pos: position{line: 1823, col: 21, offset: 56416},
									expr: &charClassMatcher{
										pos:        position{line: 1823, col: 22, offset: 56417},
										val:        "[\\p{L}]",
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
						},
					},
					&actionExpr{
						pos: position{line: 1825, col: 9, offset: 56475},
						run: (*parser).callonApostrophe7,
						expr: &seqExpr{
							pos: position{line: 1825, col: 9, offset: 56475},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1825, col: 9, offset: 56475},
									val:        "'",
									ignoreCase: false,
									want:       "\"'\"",
								},
								&andExpr{
									pos: position{line: 1825, col: 13, offset: 56479},
									expr: &charClassMatcher{
										pos:        position{line: 1825, col: 14, offset: 56480},
										val:        "[\\p{L}]",
										classes:    []*unicode.RangeTable{rangeTable("L")},
										ignoreCase: false,
										inverted:   false,
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "Punctuation",
			pos:  position{line: 1830, col: 1, offset: 56543},
			expr: &actionExpr{
				pos: position{line: 1830, col: 15, offset: 56557},
				run: (*parser).callonPunctuation1,
				expr: &choiceExpr{
					pos: position{line: 1830, col: 17, offset: 56559},
					alternatives: []any{
						&charClassMatcher{
							pos:        position{line: 1830, col: 18, offset: 56560},
							val:        "[,;.?)/:!=\"'@-[\\]]",
							chars:      []rune{',', ';', '.', '?', ')', '/', ':', '!', '=', '"', '\'', ']'},
							ranges:     []rune{'@', '['},
							ignoreCase: false,
							inverted:   false,
						},
						&seqExpr{
							pos: position{line: 1830, col: 41, offset: 56583},
							exprs: []any{
								&litMatcher{
									pos:        position{line: 1830, col: 41, offset: 56583},
									val:        "(",
									ignoreCase: false,
									want:       "\"(\"",
								},
								&notExpr{
									pos: position{line: 1830, col: 45, offset: 56587},
									expr: &litMatcher{
										pos:        position{line: 1830, col: 46, offset: 56588},
										val:        "(",
										ignoreCase: false,
										want:       "\"(\"",
									},
								},
							},
						},
					},
				},
			},
		},
		{
			name: "LineBreak",
			pos:  position{line: 1834, col: 1, offset: 56655},
			expr: &actionExpr{
				pos: position{line: 1834, col: 13, offset: 56667},
				run: (*parser).callonLineBreak1,
				expr: &seqExpr{
					pos: position{line: 1834, col: 13, offset: 56667},
					exprs: []any{
						&litMatcher{
							pos:        position{line: 1834, col: 13, offset: 56667},
							val:        "+",
							ignoreCase: false,
							want:       "\"+\"",
						},
						&ruleRefExpr{
							pos:    position{line: 1834, col: 17, offset: 56671},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1834, col: 27, offset: 56681},
							expr: &ruleRefExpr{
								pos:    position{line: 1834, col: 29, offset: 56683},
								offset: 330,
							},
						},
						&andCodeExpr{
							pos: position{line: 1834, col: 40, offset: 56694},
							run: (*parser).callonLineBreak7,
						},
					},
				},
			},
		},
		{
			name: "CurvedQuote",
			pos:  position{line: 1840, col: 1, offset: 56795},
			expr: &choiceExpr{
				pos: position{line: 1840, col: 16, offset: 56810},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1840, col: 16, offset: 56810},
						offset: 314,
					},
					&ruleRefExpr{
						pos:    position{line: 1840, col: 36, offset: 56830},
						offset: 313,
					},
				},
			},
		},
		{
			name: "DoubleCurvedQuote",
			pos:  position{line: 1842, col: 1, offset: 56850},
			expr: &choiceExpr{
				pos: position{line: 1842, col: 22, offset: 56871},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1842, col: 22, offset: 56871},
						val:        "\"`",
						ignoreCase: false,
						want:       "\"\\\"`\"",
					},
					&litMatcher{
						pos:        position{line: 1842, col: 30, offset: 56879},
						val:        "`\"",
						ignoreCase: false,
						want:       "\"`\\\"\"",
					},
				},
			},
		},
		{
			name: "SingleCurvedQuote",
			pos:  position{line: 1844, col: 1, offset: 56888},
			expr: &choiceExpr{
				pos: position{line: 1844, col: 22, offset: 56909},
				alternatives: []any{
					&litMatcher{
						pos:        position{line: 1844, col: 22, offset: 56909},
						val:        "'`",
						ignoreCase: false,
						want:       "\"'`\"",
					},
					&litMatcher{
						pos:        position{line: 1844, col: 29, offset: 56916},
						val:        "`'",
						ignoreCase: false,
						want:       "\"`'\"",
					},
				},
			},
		},
		{
			name: "EmptyLine",
			pos:  position{line: 1846, col: 1, offset: 56924},
			expr: &actionExpr{
				pos: position{line: 1846, col: 13, offset: 56936},
				run: (*parser).callonEmptyLine1,
				expr: &seqExpr{
					pos: position{line: 1846, col: 13, offset: 56936},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1846, col: 13, offset: 56936},
							offset: 327,
						},
						&ruleRefExpr{
							pos:    position{line: 1846, col: 29, offset: 56952},
							offset: 334,
						},
						&ruleRefExpr{
							pos:    position{line: 1846, col: 39, offset: 56962},
							offset: 317,
						},
					},
				},
			},
		},
		{
			name: "SoftNewLine",
			pos:  position{line: 1850, col: 1, offset: 57052},
			expr: &seqExpr{
				pos: position{line: 1850, col: 15, offset: 57066},
				exprs: []any{
					&notExpr{
						pos: position{line: 1850, col: 15, offset: 57066},
						expr: &litMatcher{
							pos:        position{line: 1850, col: 16, offset: 57067},
							val:        "\\",
							ignoreCase: false,
							want:       "\"\\\\\"",
						},
					},
					&ruleRefExpr{
						pos:    position{line: 1850, col: 21, offset: 57072},
						offset: 317,
					},
				},
			},
		},
		{
			name: "NewLine",
			pos:  position{line: 1852, col: 1, offset: 57081},
			expr: &actionExpr{
				pos: position{line: 1852, col: 11, offset: 57091},
				run: (*parser).callonNewLine1,
				expr: &choiceExpr{
					pos: position{line: 1852, col: 12, offset: 57092},
					alternatives: []any{
						&litMatcher{
							pos:        position{line: 1852, col: 12, offset: 57092},
							val:        "\n",
							ignoreCase: false,
							want:       "\"\\n\"",
						},
						&litMatcher{
							pos:        position{line: 1852, col: 19, offset: 57099},
							val:        "\r\n",
							ignoreCase: false,
							want:       "\"\\r\\n\"",
						},
					},
				},
			},
		},
		{
			name: "Percentage",
			pos:  position{line: 1856, col: 1, offset: 57159},
			expr: &actionExpr{
				pos: position{line: 1856, col: 15, offset: 57173},
				run: (*parser).callonPercentage1,
				expr: &seqExpr{
					pos: position{line: 1856, col: 15, offset: 57173},
					exprs: []any{
						&labeledExpr{
							pos:   position{line: 1856, col: 15, offset: 57173},
							label: "percentage",
							expr: &ruleRefExpr{
								pos:    position{line: 1856, col: 26, offset: 57184},
								offset: 319,
							},
						},
						&litMatcher{
							pos:        position{line: 1856, col: 42, offset: 57200},
							val:        "%",
							ignoreCase: false,
							want:       "\"%\"",
						},
					},
				},
			},
		},
		{
			name: "PositiveInteger",
			pos:  position{line: 1860, col: 1, offset: 57236},
			expr: &actionExpr{
				pos: position{line: 1860, col: 20, offset: 57255},
				run: (*parser).callonPositiveInteger1,
				expr: &seqExpr{
					pos: position{line: 1860, col: 20, offset: 57255},
					exprs: []any{
						&oneOrMoreExpr{
							pos: position{line: 1860, col: 21, offset: 57256},
							expr: &charClassMatcher{
								pos:        position{line: 1860, col: 21, offset: 57256},
								val:        "[0-9]",
								ranges:     []rune{'0', '9'},
								ignoreCase: false,
								inverted:   false,
							},
						},
						&andCodeExpr{
							pos: position{line: 1860, col: 29, offset: 57264},
							run: (*parser).callonPositiveInteger5,
						},
					},
				},
			},
		},
		{
			name: "NotNewLine",
			pos:  position{line: 1866, col: 1, offset: 57355},
			expr: &notExpr{
				pos: position{line: 1866, col: 14, offset: 57368},
				expr: &ruleRefExpr{
					pos:    position{line: 1866, col: 15, offset: 57369},
					offset: 317,
				},
			},
		},
		{
			name: "NotSpace",
			pos:  position{line: 1868, col: 1, offset: 57378},
			expr: &notExpr{
				pos: position{line: 1868, col: 12, offset: 57389},
				expr: &ruleRefExpr{
					pos:    position{line: 1868, col: 13, offset: 57390},
					offset: 339,
				},
			},
		},
		{
			name: "Alpha",
			pos:  position{line: 1870, col: 1, offset: 57393},
			expr: &charClassMatcher{
				pos:        position{line: 1870, col: 9, offset: 57401},
				val:        "[\\p{L}]",
				classes:    []*unicode.RangeTable{rangeTable("L")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "Alphanumeric",
			pos:  position{line: 1872, col: 1, offset: 57410},
			expr: &charClassMatcher{
				pos:        position{line: 1872, col: 16, offset: 57425},
				val:        "[\\p{L}\\p{N}]",
				classes:    []*unicode.RangeTable{rangeTable("L"), rangeTable("N")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "EndOfFile",
			pos:  position{line: 1874, col: 1, offset: 57439},
			expr: &notExpr{
				pos: position{line: 1874, col: 13, offset: 57451},
				expr: &anyMatcher{
					line: 1874, col: 14, offset: 57452,
				},
			},
		},
		{
			name: "NotEndOfFile",
			pos:  position{line: 1876, col: 1, offset: 57456},
			expr: &andExpr{
				pos: position{line: 1876, col: 16, offset: 57471},
				expr: &anyMatcher{
					line: 1876, col: 18, offset: 57473,
				},
			},
		},
		{
			name: "BeginningOfFile",
			pos:  position{line: 1878, col: 1, offset: 57477},
			expr: &seqExpr{
				pos: position{line: 1878, col: 19, offset: 57495},
				exprs: []any{
					&andExpr{
						pos: position{line: 1878, col: 19, offset: 57495},
						expr: &anyMatcher{
							line: 1878, col: 21, offset: 57497,
						},
					},
					&andCodeExpr{
						pos: position{line: 1878, col: 24, offset: 57500},
						run: (*parser).callonBeginningOfFile4,
					},
				},
			},
		},
		{
			name: "BeginningOfLine",
			pos:  position{line: 1884, col: 1, offset: 57615},
			expr: &notExpr{
				pos: position{line: 1884, col: 19, offset: 57633},
				expr: &ruleRefExpr{
					pos:    position{line: 1884, col: 20, offset: 57634},
					offset: 328,
				},
			},
		},
		{
			name: "OffsetCharacter",
			pos:  position{line: 1886, col: 1, offset: 57651},
			expr: &seqExpr{
				pos: position{line: 1886, col: 19, offset: 57669},
				exprs: []any{
					&anyMatcher{
						line: 1886, col: 19, offset: 57669,
					},
					&andCodeExpr{
						pos: position{line: 1886, col: 21, offset: 57671},
						run: (*parser).callonOffsetCharacter3,
					},
				},
			},
		},
		{
			name: "Indent",
			pos:  position{line: 1890, col: 1, offset: 57719},
			expr: &actionExpr{
				pos: position{line: 1890, col: 10, offset: 57728},
				run: (*parser).callonIndent1,
				expr: &seqExpr{
					pos: position{line: 1890, col: 10, offset: 57728},
					exprs: []any{
						&ruleRefExpr{
							pos:    position{line: 1890, col: 10, offset: 57728},
							offset: 334,
						},
						&andExpr{
							pos: position{line: 1890, col: 20, offset: 57738},
							expr: &notExpr{
								pos: position{line: 1890, col: 22, offset: 57740},
								expr: &ruleRefExpr{
									pos:    position{line: 1890, col: 23, offset: 57741},
									offset: 339,
								},
							},
						},
						&andCodeExpr{
							pos: position{line: 1890, col: 26, offset: 57744},
							run: (*parser).callonIndent7,
						},
					},
				},
			},
		},
		{
			name: "EndOfLine",
			pos:  position{line: 1896, col: 1, offset: 57813},
			expr: &choiceExpr{
				pos: position{line: 1896, col: 13, offset: 57825},
				alternatives: []any{
					&ruleRefExpr{
						pos:    position{line: 1896, col: 13, offset: 57825},
						offset: 317,
					},
					&ruleRefExpr{
						pos:    position{line: 1896, col: 23, offset: 57835},
						offset: 324,
					},
				},
			},
		},
		{
			name: "InlineText",
			pos:  position{line: 1898, col: 1, offset: 57846},
			expr: &labeledExpr{
				pos:   position{line: 1898, col: 14, offset: 57859},
				label: "text",
				expr: &actionExpr{
					pos: position{line: 1898, col: 20, offset: 57865},
					run: (*parser).callonInlineText2,
					expr: &oneOrMoreExpr{
						pos: position{line: 1898, col: 20, offset: 57865},
						expr: &ruleRefExpr{
							pos:    position{line: 1898, col: 20, offset: 57865},
							offset: 323,
						},
					},
				},
			},
		},
		{
			name: "UnbrokenText",
			pos:  position{line: 1900, col: 1, offset: 57911},
			expr: &actionExpr{
				pos: position{line: 1900, col: 16, offset: 57926},
				run: (*parser).callonUnbrokenText1,
				expr: &oneOrMoreExpr{
					pos: position{line: 1900, col: 16, offset: 57926},
					expr: &ruleRefExpr{
						pos:    position{line: 1900, col: 16, offset: 57926},
						offset: 336,
					},
				},
			},
		},
		{
			name: "AnyText",
			pos:  position{line: 1904, col: 1, offset: 57988},
			expr: &zeroOrMoreExpr{
				pos: position{line: 1904, col: 11, offset: 57998},
				expr: &charClassMatcher{
					pos:        position{line: 1904, col: 11, offset: 57998},
					val:        "[^\\r\\n]",
					chars:      []rune{'\r', '\n'},
					ignoreCase: false,
					inverted:   true,
				},
			},
		},
		{
			name: "AnySpaces",
			pos:  position{line: 1906, col: 1, offset: 58009},
			expr: &zeroOrMoreExpr{
				pos: position{line: 1906, col: 13, offset: 58021},
				expr: &charClassMatcher{
					pos:        position{line: 1906, col: 13, offset: 58021},
					val:        "[ \\t]",
					chars:      []rune{' ', '\t'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "CharacterClassAll",
			pos:  position{line: 1908, col: 1, offset: 58030},
			expr: &actionExpr{
				pos: position{line: 1908, col: 21, offset: 58050},
				run: (*parser).callonCharacterClassAll1,
				expr: &choiceExpr{
					pos: position{line: 1908, col: 22, offset: 58051},
					alternatives: []any{
						&anyMatcher{
							line: 1908, col: 22, offset: 58051,
						},
						&ruleRefExpr{
							pos:    position{line: 1908, col: 26, offset: 58055},
							offset: 317,
						},
					},
				},
			},
		},
		{
			name: "CharacterClassInline",
			pos:  position{line: 1912, col: 1, offset: 58104},
			expr: &charClassMatcher{
				pos:        position{line: 1912, col: 24, offset: 58127},
				val:        "[^\\r\\n]",
				chars:      []rune{'\r', '\n'},
				ignoreCase: false,
				inverted:   true,
			},
		},
		{
			name: "CharacterGroupWord",
			pos:  position{line: 1914, col: 1, offset: 58137},
			expr: &charClassMatcher{
				pos:        position{line: 1914, col: 22, offset: 58158},
				val:        "[\\p{M}\\p{Nd}\\p{Pc}\\p{Join_Control}\\p{L}]",
				classes:    []*unicode.RangeTable{rangeTable("M"), rangeTable("Nd"), rangeTable("Pc"), rangeTable("Join_Control"), rangeTable("L")},
				ignoreCase: false,
				inverted:   false,
			},
		},
		{
			name: "__",
			pos:  position{line: 1916, col: 1, offset: 58201},
			expr: &actionExpr{
				pos: position{line: 1916, col: 6, offset: 58206},
				run: (*parser).callon__1,
				expr: &oneOrMoreExpr{
					pos: position{line: 1916, col: 6, offset: 58206},
					expr: &charClassMatcher{
						pos:        position{line: 1916, col: 6, offset: 58206},
						val:        "[ \\t]",
						chars:      []rune{' ', '\t'},
						ignoreCase: false,
						inverted:   false,
					},
				},
			},
		},
		{
			name: "_",
			pos:  position{line: 1920, col: 1, offset: 58253},
			expr: &actionExpr{
				pos: position{line: 1920, col: 5, offset: 58257},
				run: (*parser).callon_1,
				expr: &charClassMatcher{
					pos:        position{line: 1920, col: 5, offset: 58257},
					val:        "[ \\t]",
					chars:      []rune{' ', '\t'},
					ignoreCase: false,
					inverted:   false,
				},
			},
		},
		{
			name: "Escape",
			pos:  position{line: 1924, col: 1, offset: 58303},
			expr: &litMatcher{
				pos:        position{line: 1924, col: 10, offset: 58312},
				val:        "\\",
				ignoreCase: false,
				want:       "\"\\\\\"",
			},
		},
		{
			name: "DoubleEscape",
			pos:  position{line: 1926, col: 1, offset: 58319},
			expr: &litMatcher{
				pos:        position{line: 1926, col: 16, offset: 58334},
				val:        "\\\\",
				ignoreCase: false,
				want:       "\"\\\\\\\\\"",
			},
		},
	},
}

func (c *current) onDocument1(content any) (any, error) {
	return flat(content.([]any)), nil
}

func (p *parser) callonDocument1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDocument1(stack["content"])
}

func (c *current) onBlockElement7(element any) (bool, error) {
	return element != nil, nil
}

func (p *parser) callonBlockElement7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElement7(stack["element"])
}

func (c *current) onBlockElement1(element any) (any, error) {
	return compose(c, element.(asciidoc.Element))
}

func (p *parser) callonBlockElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElement1(stack["element"])
}

func (c *current) onAttributableBlocks23(attributes, element any) (bool, error) {
	return attributes != nil || element != nil, nil

}

func (p *parser) callonAttributableBlocks23() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributableBlocks23(stack["attributes"], stack["element"])
}

func (c *current) onAttributableBlocks1(attributes, element any) (any, error) {
	if element == nil {
		return asciidoc.NewBlockAttributes(attributes.(asciidoc.AttributeList)), nil
	}
	if attributes != nil {
	}
	return compose(c, element.(asciidoc.AttributableElement), setAttributes[asciidoc.AttributableElement](attributes))

}

func (p *parser) callonAttributableBlocks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributableBlocks1(stack["attributes"], stack["element"])
}

func (c *current) onBlockTitle1(content any) (any, error) {
	els, err := coalesce(content.(asciidoc.Elements))
	if err != nil {
		return nil, err
	}
	return asciidoc.NewTitleAttribute(els), nil
}

func (p *parser) callonBlockTitle1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTitle1(stack["content"])
}

func (c *current) onBlockTitleContent1(content any) (any, error) {
	return flat(content.([]any)), nil
}

func (p *parser) callonBlockTitleContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTitleContent1(stack["content"])
}

func (c *current) onBlockEmptyLine1() (any, error) {
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))
}

func (p *parser) callonBlockEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockEmptyLine1()
}

func (c *current) onBlockElementAttribute1(attributes any) (any, error) {
	return attributes, nil
}

func (p *parser) callonBlockElementAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElementAttribute1(stack["attributes"])
}

func (c *current) onBlockElementAdditionalAttribute1(attributes any) (any, error) {
	return attributes, nil
}

func (p *parser) callonBlockElementAdditionalAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElementAdditionalAttribute1(stack["attributes"])
}

func (c *current) onBlockElementAttributes1(attribute, additionalAttributes any) (any, error) {
	attributes := []any{attribute}
	if additionalAttributes != nil {
		attributes = append(attributes, additionalAttributes.([]any)...)
	}
	return extractAttributes(attributes, nil)
}

func (p *parser) callonBlockElementAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockElementAttributes1(stack["attribute"], stack["additionalAttributes"])
}

func (c *current) onNakedBlockAttributes1(attribute, additionalAttributes any) (any, error) {
	attributes := []any{attribute}
	if additionalAttributes != nil {
		attributes = append(attributes, additionalAttributes.([]any)...)
	}
	as, err := extractAttributes(attributes, nil)
	if err != nil {
		return nil, err
	}
	return asciidoc.NewBlockAttributes(as), nil
}

func (p *parser) callonNakedBlockAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedBlockAttributes1(stack["attribute"], stack["additionalAttributes"])
}

func (c *current) onAlchemyEscape1(start, value, lines any) (any, error) {
	return compose(c, asciidoc.NewAlchemyEscape(), setLines[*asciidoc.AlchemyEscape](cast[any, string](lines.([]any))), setElements[*asciidoc.AlchemyEscape](value))

}

func (p *parser) callonAlchemyEscape1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAlchemyEscape1(stack["start"], stack["value"], stack["lines"])
}

func (c *current) onAlchemyEscapeLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonAlchemyEscapeLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAlchemyEscapeLine1(stack["line"])
}

func (c *current) onSection4() (any, error) {
	return len(c.text) - 1, nil

}

func (p *parser) callonSection4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSection4()
}

func (c *current) onSection7(level any) (bool, error) {
	return level.(int) < 6, nil

}

func (p *parser) callonSection7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSection7(stack["level"])
}

func (c *current) onSection1(level, title any) (any, error) {
	return compose(c, asciidoc.NewSection(join(flat(title.([]any))), level.(int)))

}

func (p *parser) callonSection1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSection1(stack["level"], stack["title"])
}

func (c *current) onAttributeEntry1(name, value any) (any, error) {
	return compose(c, asciidoc.NewAttributeEntry(name.(string)), setElements[*asciidoc.AttributeEntry](value))
}

func (p *parser) callonAttributeEntry1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeEntry1(stack["name"], stack["value"])
}

func (c *current) onAttributeEntryName1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonAttributeEntryName1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeEntryName1()
}

func (c *current) onAttributeEntryElements1(value any) (any, error) {
	return join(flat(value.([]any))), nil
}

func (p *parser) callonAttributeEntryElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeEntryElements1(stack["value"])
}

func (c *current) onAttributeReset2(name any) (any, error) {
	return compose(c, asciidoc.NewAttributeReset(name.(string)))
}

func (p *parser) callonAttributeReset2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReset2(stack["name"])
}

func (c *current) onAttributeReset9(name any) (any, error) {
	return compose(c, asciidoc.NewAttributeReset(name.(string)))
}

func (p *parser) callonAttributeReset9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReset9(stack["name"])
}

func (c *current) onAttributes1(attributes any) (any, error) {
	return attributes, nil
}

func (p *parser) callonAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributes1(stack["attributes"])
}

func (c *current) onAttributeList1(attributes any) (any, error) {
	return extractAttributes(attributes.([]any), nil)
}

func (p *parser) callonAttributeList1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeList1(stack["attributes"])
}

func (c *current) onAttributeListItem1(attribute any) (any, error) {
	return attribute, nil
}

func (p *parser) callonAttributeListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeListItem1(stack["attribute"])
}

func (c *current) onAttribute5(name any) (any, error) {
	return name, nil
}

func (p *parser) callonAttribute5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttribute5(stack["name"])
}

func (c *current) onAttribute1(name, value any) (any, error) {
	if name != nil {
		return asciidoc.NewNamedAttribute(name.(string), value.(*attributeValue).value, value.(*attributeValue).quote), nil
	}
	return asciidoc.NewPositionalAttribute(value.(*attributeValue).value), nil
}

func (p *parser) callonAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttribute1(stack["name"], stack["value"])
}

func (c *current) onShorthandAttributes1(attribute any) (any, error) {
	return attribute, nil
}

func (p *parser) callonShorthandAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandAttributes1(stack["attribute"])
}

func (c *current) onShorthandAttribute1(style, values any) (any, error) {
	return asciidoc.NewShorthandAttribute(style, values.([]any))
}

func (p *parser) callonShorthandAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandAttribute1(stack["style"], stack["values"])
}

func (c *current) onShorthandStyle1(value any) (any, error) {
	return asciidoc.NewShorthandID(value.(asciidoc.Elements)...), nil
}

func (p *parser) callonShorthandStyle1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandStyle1(stack["value"])
}

func (c *current) onShorthandID1(value any) (any, error) {
	return asciidoc.NewShorthandID(value.(asciidoc.Elements)...), nil
}

func (p *parser) callonShorthandID1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandID1(stack["value"])
}

func (c *current) onShorthandRole1(value any) (any, error) {
	return asciidoc.NewShorthandRole(value.(asciidoc.Elements)...), nil
}

func (p *parser) callonShorthandRole1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandRole1(stack["value"])
}

func (c *current) onShorthandOption1(value any) (any, error) {
	return asciidoc.NewShorthandOption(value.(asciidoc.Elements)...), nil
}

func (p *parser) callonShorthandOption1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onShorthandOption1(stack["value"])
}

func (c *current) onSingleQuoteAttributeValue1(value any) (any, error) {
	return &attributeValue{value: join(flat(value.([]any))), quote: asciidoc.AttributeQuoteTypeSingle}, nil
}

func (p *parser) callonSingleQuoteAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleQuoteAttributeValue1(stack["value"])
}

func (c *current) onSingleQuoteAttributeValueCharacter2() (any, error) {
	return asciidoc.NewString("'"), nil
}

func (p *parser) callonSingleQuoteAttributeValueCharacter2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleQuoteAttributeValueCharacter2()
}

func (c *current) onDoubleQuoteAttributeValue1(value any) (any, error) {
	return &attributeValue{value: join(flat(value.([]any))), quote: asciidoc.AttributeQuoteTypeDouble}, nil
}

func (p *parser) callonDoubleQuoteAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleQuoteAttributeValue1(stack["value"])
}

func (c *current) onDoubleQuoteAttributeValueCharacter2() (any, error) {
	return asciidoc.NewString("'"), nil
}

func (p *parser) callonDoubleQuoteAttributeValueCharacter2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleQuoteAttributeValueCharacter2()
}

func (c *current) onNakedAttributeValue1(value any) (any, error) {
	return &attributeValue{value: join(flat(value.([]any)))}, nil
}

func (p *parser) callonNakedAttributeValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedAttributeValue1(stack["value"])
}

func (c *current) onInlineAttributes1(attributes any) (any, error) {
	return attributes, nil
}

func (p *parser) callonInlineAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineAttributes1(stack["attributes"])
}

func (c *current) onNamedAttributeName1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonNamedAttributeName1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNamedAttributeName1()
}

func (c *current) onAttributeReferenceValue1(name any) (any, error) {
	return populatePosition(c, asciidoc.NewAttributeReference(name.(string))), nil
}

func (p *parser) callonAttributeReferenceValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttributeReferenceValue1(stack["name"])
}

func (c *current) onSingleBoldText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleBoldText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldText1(stack["value"])
}

func (c *current) onSingleBoldTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleBoldTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldTextValue7(stack["value"])
}

func (c *current) onSingleBoldTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewBold(), setElements[*asciidoc.Bold](flat(value.([]any))))
}

func (p *parser) callonSingleBoldTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleBoldTextValue1(stack["value"])
}

func (c *current) onDoubleBoldText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleBoldText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldText1(stack["value"])
}

func (c *current) onDoubleBoldTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleBoldTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldTextValue7(stack["value"])
}

func (c *current) onDoubleBoldTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewDoubleBold(), setElements[*asciidoc.DoubleBold](flat(value.([]any))))
}

func (p *parser) callonDoubleBoldTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleBoldTextValue1(stack["value"])
}

func (c *current) onSingleItalicText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleItalicText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicText1(stack["value"])
}

func (c *current) onSingleItalicTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleItalicTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicTextValue7(stack["value"])
}

func (c *current) onSingleItalicTextValue1(value any) (any, error) {
	return asciidoc.NewItalic(flat(value.([]any))), nil
}

func (p *parser) callonSingleItalicTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleItalicTextValue1(stack["value"])
}

func (c *current) onDoubleItalicText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleItalicText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicText1(stack["value"])
}

func (c *current) onDoubleItalicTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleItalicTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicTextValue7(stack["value"])
}

func (c *current) onDoubleItalicTextValue1(value any) (any, error) {
	return asciidoc.NewDoubleItalic(flat(value.([]any))), nil
}

func (p *parser) callonDoubleItalicTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleItalicTextValue1(stack["value"])
}

func (c *current) onSubscriptText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSubscriptText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptText1(stack["value"])
}

func (c *current) onSubscriptTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSubscriptTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptTextValue7(stack["value"])
}

func (c *current) onSubscriptTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewSubscript(), setElements[*asciidoc.Subscript](flat(value.([]any))))
}

func (p *parser) callonSubscriptTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSubscriptTextValue1(stack["value"])
}

func (c *current) onEscapedSubscript1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonEscapedSubscript1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEscapedSubscript1()
}

func (c *current) onSuperscriptText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSuperscriptText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptText1(stack["value"])
}

func (c *current) onSuperscriptTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSuperscriptTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptTextValue7(stack["value"])
}

func (c *current) onSuperscriptTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewSuperscript(), setElements[*asciidoc.Superscript](flat(value.([]any))))
}

func (p *parser) callonSuperscriptTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSuperscriptTextValue1(stack["value"])
}

func (c *current) onEscapedSuperscript1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonEscapedSuperscript1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEscapedSuperscript1()
}

func (c *current) onSingleMonospaceText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleMonospaceText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceText1(stack["value"])
}

func (c *current) onSingleMonospaceTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleMonospaceTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceTextValue7(stack["value"])
}

func (c *current) onSingleMonospaceTextValue1(value any) (any, error) {
	return asciidoc.NewMonospace(flat(value.([]any))), nil
}

func (p *parser) callonSingleMonospaceTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMonospaceTextValue1(stack["value"])
}

func (c *current) onDoubleMonospaceText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleMonospaceText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceText1(stack["value"])
}

func (c *current) onDoubleMonospaceTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleMonospaceTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceTextValue7(stack["value"])
}

func (c *current) onDoubleMonospaceTextValue1(value any) (any, error) {
	return asciidoc.NewDoubleMonospace(flat(value.([]any))), nil
}

func (p *parser) callonDoubleMonospaceTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMonospaceTextValue1(stack["value"])
}

func (c *current) onAnchor10(label any) (any, error) {
	return label, nil
}

func (p *parser) callonAnchor10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchor10(stack["label"])
}

func (c *current) onAnchor1(id, label any) (any, error) {
	var lbl asciidoc.Elements
	if label != nil {
		lbl = join(label.([]any))
	}
	return compose(c, asciidoc.NewAnchor(id.(asciidoc.Elements), lbl))
}

func (p *parser) callonAnchor1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchor1(stack["id"], stack["label"])
}

func (c *current) onAnchorAttribute10(label any) (any, error) {
	return label, nil
}

func (p *parser) callonAnchorAttribute10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorAttribute10(stack["label"])
}

func (c *current) onAnchorAttribute1(id, label any) (any, error) {
	var lbl asciidoc.Elements
	if label != nil {
		lbl = join(label.([]any))
	}
	return populatePosition(c, asciidoc.NewAnchorAttribute(id.(asciidoc.Elements), lbl)), nil
}

func (p *parser) callonAnchorAttribute1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAnchorAttribute1(stack["id"], stack["label"])
}

func (c *current) onAdmonition2() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeNote), nil
}

func (p *parser) callonAdmonition2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition2()
}

func (c *current) onAdmonition6() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeTip), nil
}

func (p *parser) callonAdmonition6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition6()
}

func (c *current) onAdmonition8() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeImportant), nil
}

func (p *parser) callonAdmonition8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition8()
}

func (c *current) onAdmonition10() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeCaution), nil
}

func (p *parser) callonAdmonition10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition10()
}

func (c *current) onAdmonition12() (any, error) {
	return asciidoc.NewAdmonition(asciidoc.AdmonitionTypeWarning), nil
}

func (p *parser) callonAdmonition12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdmonition12()
}

func (c *current) onInlineBlock1(content, eol any) (any, error) {
	els := content.(asciidoc.Elements)
	if eol, ok := eol.(*asciidoc.NewLine); ok {
		els = append(els, eol)
	}
	return els, nil
}

func (p *parser) callonInlineBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineBlock1(stack["content"], stack["eol"])
}

func (c *current) onInlineElements1(content any) (any, error) {
	return flat(content.([]any)), nil
}

func (p *parser) callonInlineElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineElements1(stack["content"])
}

func (c *current) onNakedInlineText1() (any, error) {

	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonNakedInlineText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedInlineText1()
}

func (c *current) onFootnote1(id, value any) (any, error) {
	return asciidoc.NewFootnote(id.(string), value.([]any)), nil
}

func (p *parser) callonFootnote1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFootnote1(stack["id"], stack["value"])
}

func (c *current) onFootnoteId1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonFootnoteId1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFootnoteId1()
}

func (c *current) onFormattedText1(attributes, text any) (any, error) {
	return compose(c, text.(asciidoc.AttributableElement), setAttributes[asciidoc.AttributableElement](attributes))

}

func (p *parser) callonFormattedText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFormattedText1(stack["attributes"], stack["text"])
}

func (c *current) onFormatAttributes1(attributes any) (any, error) {
	return attributes, nil
}

func (p *parser) callonFormatAttributes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFormatAttributes1(stack["attributes"])
}

func (c *current) onBlockImage1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewBlockImage(path.(asciidoc.Elements)), setAttributes[*asciidoc.BlockImage](attributes))
}

func (p *parser) callonBlockImage1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockImage1(stack["path"], stack["attributes"])
}

func (c *current) onInlineImage1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewInlineImage(path.(asciidoc.Elements)), setAttributes[*asciidoc.InlineImage](attributes))
}

func (p *parser) callonInlineImage1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineImage1(stack["path"], stack["attributes"])
}

func (c *current) onIcon5() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonIcon5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIcon5()
}

func (c *current) onIcon1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewIcon(path.(string)), setAttributes[*asciidoc.Icon](attributes))
}

func (p *parser) callonIcon1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIcon1(stack["path"], stack["attributes"])
}

func (c *current) onFileInclude1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewFileInclude(), setElements[*asciidoc.FileInclude](path), setAttributes[*asciidoc.FileInclude](attributes))
}

func (p *parser) callonFileInclude1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFileInclude1(stack["path"], stack["attributes"])
}

func (c *current) onFileIncludePath1(path any) (any, error) {
	return path, nil
}

func (p *parser) callonFileIncludePath1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFileIncludePath1(stack["path"])
}

func (c *current) onIncludeParse1(content any) (any, error) {
	return flat(content.([]any)), nil
}

func (p *parser) callonIncludeParse1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIncludeParse1(stack["content"])
}

func (c *current) onIncludeParseElement1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonIncludeParseElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIncludeParseElement1(stack["element"])
}

func (c *current) onIncludeParseLine1(content any) (any, error) {
	return flat(append(content.([]any), &asciidoc.NewLine{})), nil
}

func (p *parser) callonIncludeParseLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIncludeParseLine1(stack["content"])
}

func (c *current) onLink1(link any) (any, error) {
	return link, nil
}

func (p *parser) callonLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLink1(stack["link"])
}

func (c *current) onHTMLLink1(url any) (any, error) {
	return asciidoc.NewLink(url.(asciidoc.URL)), nil
}

func (p *parser) callonHTMLLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onHTMLLink1(stack["url"])
}

func (c *current) onPrefixedLink1(url, attributes any) (any, error) {

	return compose(c, asciidoc.NewLinkMacro(url.(asciidoc.URL)), setAttributes[*asciidoc.LinkMacro](attributes))
}

func (p *parser) callonPrefixedLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPrefixedLink1(stack["url"], stack["attributes"])
}

func (c *current) onExternalLink1(url, attributes any) (any, error) {
	return compose(c, asciidoc.NewLink(url.(asciidoc.URL)), setAttributes[*asciidoc.Link](attributes))
}

func (p *parser) callonExternalLink1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExternalLink1(stack["url"], stack["attributes"])
}

func (c *current) onTable1(attributes, cells any) (any, error) {
	table, err := parseTable(attributes, cells.([]any))
	if err != nil {
		return nil, err
	}
	return compose(c, table)
}

func (p *parser) callonTable1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTable1(stack["attributes"], stack["cells"])
}

func (c *current) onIncludedTableElements1(content any) (any, error) {
	table := c.globalStore["table"].(*asciidoc.Table)
	return parseTableRows(table, content.([]any))
}

func (p *parser) callonIncludedTableElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIncludedTableElements1(stack["content"])
}

func (c *current) onTableStart1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonTableStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableStart1()
}

func (c *current) onTableEmptyLine1() (any, error) {
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))
}

func (p *parser) callonTableEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableEmptyLine1()
}

func (c *current) onIncludedTableEmptyLine1() (any, error) {
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))
}

func (p *parser) callonIncludedTableEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIncludedTableEmptyLine1()
}

func (c *current) onTableIfDef1(ifdef any) (any, error) {
	return compose(c, ifdef.(*asciidoc.IfDef))
}

func (p *parser) callonTableIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableIfDef1(stack["ifdef"])
}

func (c *current) onTableInlineIfDef1(ifdef, content, endif any) (any, error) {
	id, err := compose(c, ifdef.(*asciidoc.IfDef))
	if err != nil {
		return nil, err
	}
	id.Inline = true
	ei, err := compose(c, endif.(*asciidoc.EndIf))
	if err != nil {
		return nil, err
	}
	out := append(asciidoc.Elements{id}, content.(asciidoc.Elements)...)
	return append(out, ei), nil
}

func (p *parser) callonTableInlineIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableInlineIfDef1(stack["ifdef"], stack["content"], stack["endif"])
}

func (c *current) onTableIfNDef1(ifndef any) (any, error) {
	return compose(c, ifndef.(*asciidoc.IfNDef))
}

func (p *parser) callonTableIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableIfNDef1(stack["ifndef"])
}

func (c *current) onTableInlineIfNDef1(ifndef, content, endif any) (any, error) {
	id, err := compose(c, ifndef.(*asciidoc.IfNDef))
	if err != nil {
		return nil, err
	}
	id.Inline = true
	ei, err := compose(c, endif.(*asciidoc.EndIf))
	if err != nil {
		return nil, err
	}
	out := append(asciidoc.Elements{id}, content.(asciidoc.Elements)...)
	return append(out, ei), nil
}

func (p *parser) callonTableInlineIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableInlineIfNDef1(stack["ifndef"], stack["content"], stack["endif"])
}

func (c *current) onTableIfEval1(ifeval any) (any, error) {
	return compose(c, ifeval.(*asciidoc.IfEval))
}

func (p *parser) callonTableIfEval1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableIfEval1(stack["ifeval"])
}

func (c *current) onTableInlineIfEval1(ifeval, content, endif any) (any, error) {
	id, err := compose(c, ifeval.(*asciidoc.IfEval))
	if err != nil {
		return nil, err
	}
	id.Inline = true
	ei, err := compose(c, endif.(*asciidoc.EndIf))
	if err != nil {
		return nil, err
	}
	out := append(asciidoc.Elements{id}, content.(asciidoc.Elements)...)
	return append(out, ei), nil
}

func (p *parser) callonTableInlineIfEval1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableInlineIfEval1(stack["ifeval"], stack["content"], stack["endif"])
}

func (c *current) onTableEndIfDef1(endifdef any) (any, error) {
	return compose(c, endifdef.(*asciidoc.EndIf))
}

func (p *parser) callonTableEndIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableEndIfDef1(stack["endifdef"])
}

func (c *current) onTableComment1(comment any) (any, error) {
	return compose(c, comment.(*asciidoc.SingleLineComment))
}

func (p *parser) callonTableComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableComment1(stack["comment"])
}

func (c *current) onTableMultiLineComment1(comment any) (any, error) {
	return compose(c, comment.(*asciidoc.MultiLineComment))
}

func (p *parser) callonTableMultiLineComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableMultiLineComment1(stack["comment"])
}

func (c *current) onTableFileInclude1(path, attributes any) (any, error) {
	return compose(c, asciidoc.NewFileInclude(), setElements[*asciidoc.FileInclude](path), setAttributes[*asciidoc.FileInclude](attributes))
}

func (p *parser) callonTableFileInclude1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableFileInclude1(stack["path"], stack["attributes"])
}

func (c *current) onTableCellInlineContent1(content any) (any, error) {
	return trim(mergeStrings(flat(content.([]any)))), nil
}

func (p *parser) callonTableCellInlineContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellInlineContent1(stack["content"])
}

func (c *current) onTableRow1(initial, additional any) (any, error) {

	var rows = []*asciidoc.TableCell{initial.(*asciidoc.TableCell)}
	if len(additional.([]any)) > 0 {
		rows = append(rows, cast[any, *asciidoc.TableCell](additional.([]any))...)
	}
	return rows, nil
}

func (p *parser) callonTableRow1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableRow1(stack["initial"], stack["additional"])
}

func (c *current) onIncludedTableRow1(initial, additional any) (any, error) {

	var rows = []*asciidoc.TableCell{initial.(*asciidoc.TableCell)}
	if len(additional.([]any)) > 0 {
		rows = append(rows, cast[any, *asciidoc.TableCell](additional.([]any))...)
	}
	return rows, nil
}

func (p *parser) callonIncludedTableRow1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIncludedTableRow1(stack["initial"], stack["additional"])
}

func (c *current) onInitialInlineTableCell1(format, content any) (any, error) {
	return compose(c, newTableCell(format), setElements[*asciidoc.TableCell](content.(asciidoc.Elements)))
}

func (p *parser) callonInitialInlineTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialInlineTableCell1(stack["format"], stack["content"])
}

func (c *current) onAdditionalInlineTableCell1(format, content any) (any, error) {
	return compose(c, newTableCell(format), setElements[*asciidoc.TableCell](content.(asciidoc.Elements)))
}

func (p *parser) callonAdditionalInlineTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalInlineTableCell1(stack["format"], stack["content"])
}

func (c *current) onInlineTableLines1(content any) (any, error) {
	return content, nil
}

func (p *parser) callonInlineTableLines1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableLines1(stack["content"])
}

func (c *current) onEmptyCell1() (any, error) {
	return asciidoc.Elements{}, nil
}

func (p *parser) callonEmptyCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmptyCell1()
}

func (c *current) onMultiLineTableCell1(lines, content any) (any, error) {
	var cellLines asciidoc.Elements
	if lines != nil {
		cellLines = flat(lines.([]any))
	} else {
	}
	cellLines = append(cellLines, content.([]asciidoc.Element)...)
	return trim(cellLines), nil
}

func (p *parser) callonMultiLineTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineTableCell1(stack["lines"], stack["content"])
}

func (c *current) onInlineTableCellIntermediateLine13(nl any) (any, error) {
	return nl, nil
}

func (p *parser) callonInlineTableCellIntermediateLine13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellIntermediateLine13(stack["nl"])
}

func (c *current) onInlineTableCellIntermediateLine1(newline, content, newlineBeforeEmptyLine any) (any, error) {
	var els []asciidoc.Element
	if newline != nil {
		els = []asciidoc.Element{newline.(*asciidoc.NewLine)}
	}
	els = append(els, mergeStrings(flat(content.([]any)))...)
	if newlineBeforeEmptyLine != nil {
		els = append(els, newlineBeforeEmptyLine.(*asciidoc.NewLine))
	}
	return els, nil
}

func (p *parser) callonInlineTableCellIntermediateLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellIntermediateLine1(stack["newline"], stack["content"], stack["newlineBeforeEmptyLine"])
}

func (c *current) onInlineTableCellEmptyLine1() (any, error) {
	return asciidoc.Elements{populatePosition(c, asciidoc.NewEmptyLine(string(c.text)))}, nil
}

func (p *parser) callonInlineTableCellEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellEmptyLine1()
}

func (c *current) onInlineTableCellLastLine1(nl, content any) (any, error) {
	var els = []asciidoc.Element{nl.(*asciidoc.NewLine)}
	els = append(els, trim(mergeStrings(flat(content.([]any))))...)
	return els, nil
}

func (p *parser) callonInlineTableCellLastLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellLastLine1(stack["nl"], stack["content"])
}

func (c *current) onInlineTableElements1(content any) (any, error) {
	return mergeStrings(flat(content.([]any))), nil
}

func (p *parser) callonInlineTableElements1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableElements1(stack["content"])
}

func (c *current) onInlineTableElement1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonInlineTableElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableElement1(stack["element"])
}

func (c *current) onBlockTableElement1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonBlockTableElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBlockTableElement1(stack["element"])
}

func (c *current) onNakedInlineTableCellText1() (any, error) {

	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonNakedInlineTableCellText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNakedInlineTableCellText1()
}

func (c *current) onInlineTableCellSpaces1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonInlineTableCellSpaces1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineTableCellSpaces1()
}

func (c *current) onCharacterClassTableCell1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonCharacterClassTableCell1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCharacterClassTableCell1()
}

func (c *current) onInitialTableCellDelimiter1(format any) (any, error) {
	if format != nil {
		return format, nil
	}
	return asciidoc.NewTableCellFormat(), nil
}

func (p *parser) callonInitialTableCellDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialTableCellDelimiter1(stack["format"])
}

func (c *current) onAdditionalTableCellDelimiter1(format any) (any, error) {
	return format, nil
}

func (p *parser) callonAdditionalTableCellDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalTableCellDelimiter1(stack["format"])
}

func (c *current) onInitialTableCellFormat6(format any) (bool, error) {
	return format != nil, nil
}

func (p *parser) callonInitialTableCellFormat6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialTableCellFormat6(stack["format"])
}

func (c *current) onInitialTableCellFormat1(format any) (any, error) {
	return format, nil
}

func (p *parser) callonInitialTableCellFormat1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInitialTableCellFormat1(stack["format"])
}

func (c *current) onAdditionalTableCellFormat7(lead, format any) (bool, error) {
	return lead != nil && format != nil, nil
}

func (p *parser) callonAdditionalTableCellFormat7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalTableCellFormat7(stack["lead"], stack["format"])
}

func (c *current) onAdditionalTableCellFormat1(lead, format any) (any, error) {
	return format, nil
}

func (p *parser) callonAdditionalTableCellFormat1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAdditionalTableCellFormat1(stack["lead"], stack["format"])
}

func (c *current) onTableCellSpan5(n any) (any, error) {

	return n, nil
}

func (p *parser) callonTableCellSpan5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellSpan5(stack["n"])
}

func (c *current) onTableCellSpan10(n any) (any, error) {

	return n, nil

}

func (p *parser) callonTableCellSpan10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellSpan10(stack["n"])
}

func (c *current) onTableCellSpan1(column, row any) (any, error) {
	span := asciidoc.NewTableCellSpan()
	span.Column = asciidoc.Maybe(column, span.Column.Value)
	span.Row = asciidoc.Maybe(row, span.Row.Value)
	return span, nil

}

func (p *parser) callonTableCellSpan1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellSpan1(stack["column"], stack["row"])
}

func (c *current) onTableCellFormat8() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonTableCellFormat8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat8()
}

func (c *current) onTableCellFormat5(multiplier any) (any, error) {

	return strconv.Atoi(multiplier.(string))

}

func (p *parser) callonTableCellFormat5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat5(stack["multiplier"])
}

func (c *current) onTableCellFormat16(span any) (any, error) {
	return span, nil

}

func (p *parser) callonTableCellFormat16() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat16(stack["span"])
}

func (c *current) onTableCellFormat22() (any, error) {
	return asciidoc.TableCellHorizontalAlignLeft, nil
}

func (p *parser) callonTableCellFormat22() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat22()
}

func (c *current) onTableCellFormat24() (any, error) {
	return asciidoc.TableCellHorizontalAlignRight, nil
}

func (p *parser) callonTableCellFormat24() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat24()
}

func (c *current) onTableCellFormat26() (any, error) {
	return asciidoc.TableCellHorizontalAlignCenter, nil
}

func (p *parser) callonTableCellFormat26() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat26()
}

func (c *current) onTableCellFormat31() (any, error) {
	return asciidoc.TableCellVerticalAlignTop, nil
}

func (p *parser) callonTableCellFormat31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat31()
}

func (c *current) onTableCellFormat33() (any, error) {
	return asciidoc.TableCellVerticalAlignBottom, nil
}

func (p *parser) callonTableCellFormat33() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat33()
}

func (c *current) onTableCellFormat35() (any, error) {
	return asciidoc.TableCellVerticalAlignMiddle, nil
}

func (p *parser) callonTableCellFormat35() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat35()
}

func (c *current) onTableCellFormat40() (any, error) {
	return asciidoc.TableCellStyleAsciiDoc, nil
}

func (p *parser) callonTableCellFormat40() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat40()
}

func (c *current) onTableCellFormat42() (any, error) {
	return asciidoc.TableCellStyleDefault, nil
}

func (p *parser) callonTableCellFormat42() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat42()
}

func (c *current) onTableCellFormat44() (any, error) {
	return asciidoc.TableCellStyleEmphasis, nil
}

func (p *parser) callonTableCellFormat44() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat44()
}

func (c *current) onTableCellFormat46() (any, error) {
	return asciidoc.TableCellStyleHeader, nil
}

func (p *parser) callonTableCellFormat46() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat46()
}

func (c *current) onTableCellFormat48() (any, error) {
	return asciidoc.TableCellStyleLiteral, nil
}

func (p *parser) callonTableCellFormat48() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat48()
}

func (c *current) onTableCellFormat50() (any, error) {
	return asciidoc.TableCellStyleMonospace, nil
}

func (p *parser) callonTableCellFormat50() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat50()
}

func (c *current) onTableCellFormat52() (any, error) {
	return asciidoc.TableCellStyleStrong, nil
}

func (p *parser) callonTableCellFormat52() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat52()
}

func (c *current) onTableCellFormat54(multiplier, span, horizontalAlign, verticalAlign, style any) (bool, error) {
	return (multiplier != nil || span != nil || horizontalAlign != nil || verticalAlign != nil || style != nil), nil

}

func (p *parser) callonTableCellFormat54() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat54(stack["multiplier"], stack["span"], stack["horizontalAlign"], stack["verticalAlign"], stack["style"])
}

func (c *current) onTableCellFormat1(multiplier, span, horizontalAlign, verticalAlign, style any) (any, error) {
	format := asciidoc.NewTableCellFormat()
	format.Multiplier = asciidoc.Maybe(multiplier, format.Multiplier.Value)
	if span != nil {
		format.Span = span.(asciidoc.TableCellSpan)
	}
	format.HorizontalAlign = asciidoc.Maybe(horizontalAlign, format.HorizontalAlign.Value)
	format.VerticalAlign = asciidoc.Maybe(verticalAlign, format.VerticalAlign.Value)
	format.Style = asciidoc.Maybe(style, format.Style.Value)
	return format, nil
}

func (p *parser) callonTableCellFormat1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onTableCellFormat1(stack["multiplier"], stack["span"], stack["horizontalAlign"], stack["verticalAlign"], stack["style"])
}

func (c *current) onURL1(scheme, path any) (any, error) {
	return compose(c, asciidoc.NewURL(toString(scheme), path.(asciidoc.Elements)))
}

func (p *parser) callonURL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onURL1(stack["scheme"], stack["path"])
}

func (c *current) onFullURL1(scheme, path any) (any, error) {
	return compose(c, asciidoc.NewURL(toString(scheme), path.(asciidoc.Elements)))
}

func (p *parser) callonFullURL1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFullURL1(stack["scheme"], stack["path"])
}

func (c *current) onPath1(elements any) (any, error) {
	return mergeStrings(elements.([]any)), nil
}

func (p *parser) callonPath1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPath1(stack["elements"])
}

func (c *current) onEmail1(name, domain any) (any, error) {
	return compose(c, asciidoc.NewEmail(name.(string)+"@"+domain.(string)))
}

func (p *parser) callonEmail1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmail1(stack["name"], stack["domain"])
}

func (c *current) onEmailName4() (any, error) {
	// See https://en.wikipedia.org/wiki/Email_address#Local-part
	return string(c.text), nil
}

func (p *parser) callonEmailName4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailName4()
}

func (c *current) onEmailName9(name any) (bool, error) {
	n := name.(string)
	return !strings.Contains(n, "..") && !strings.HasPrefix(n, ".") && !strings.HasSuffix(n, "."), nil
}

func (p *parser) callonEmailName9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailName9(stack["name"])
}

func (c *current) onEmailName1(name any) (any, error) {
	return name.(string), nil
}

func (p *parser) callonEmailName1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailName1(stack["name"])
}

func (c *current) onEmailDomain4() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonEmailDomain4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailDomain4()
}

func (c *current) onEmailDomain15(domain any) (bool, error) {
	d := domain.(string)
	return !strings.HasPrefix(d, "-") && !strings.HasSuffix(d, "-"), nil
}

func (p *parser) callonEmailDomain15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailDomain15(stack["domain"])
}

func (c *current) onEmailDomain1(domain any) (any, error) {
	return domain.(string), nil
}

func (p *parser) callonEmailDomain1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmailDomain1(stack["domain"])
}

func (c *current) onListing1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewListing(start.(asciidoc.Delimiter)), setLines[*asciidoc.Listing](cast[any, string](lines.([]any))))

}

func (p *parser) callonListing1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListing1(stack["start"], stack["lines"])
}

func (c *current) onListingStart7(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeListing, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonListingStart7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingStart7(stack["delimiter"])
}

func (c *current) onListingStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonListingStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingStart1(stack["delimiter"])
}

func (c *current) onListingEnd7(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeListing)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeListing)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonListingEnd7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingEnd7(stack["delimiter"])
}

func (c *current) onListingHyphens8(hyphens any) (bool, error) {
	return delimitedLength(hyphens) == 4, nil

}

func (p *parser) callonListingHyphens8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingHyphens8(stack["hyphens"])
}

func (c *current) onListingHyphens1(hyphens any) (any, error) {

	return delimitedLength(hyphens), nil

}

func (p *parser) callonListingHyphens1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingHyphens1(stack["hyphens"])
}

func (c *current) onListingDelimiter1(hyphens any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeListing, Length: hyphens.(int)}, nil

}

func (p *parser) callonListingDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingDelimiter1(stack["hyphens"])
}

func (c *current) onListingLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonListingLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListingLine1(stack["line"])
}

func (c *current) onOpen1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewOpenBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.OpenBlock](join(lines.([]any))))

}

func (p *parser) callonOpen1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpen1(stack["start"], stack["lines"])
}

func (c *current) onOpenStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeOpen, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonOpenStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenStart6(stack["delimiter"])
}

func (c *current) onOpenStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonOpenStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenStart1(stack["delimiter"])
}

func (c *current) onOpenEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeOpen)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeOpen)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonOpenEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenEnd6(stack["delimiter"])
}

func (c *current) onOpenEquals1(hyphens any) (any, error) {

	return string(c.text), nil

}

func (p *parser) callonOpenEquals1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenEquals1(stack["hyphens"])
}

func (c *current) onOpenDelimiter1(hyphens any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeOpen, Length: len(hyphens.(string))}, nil

}

func (p *parser) callonOpenDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOpenDelimiter1(stack["hyphens"])
}

func (c *current) onSingleMarkedText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleMarkedText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedText1(stack["value"])
}

func (c *current) onSingleMarkedTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSingleMarkedTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedTextValue7(stack["value"])
}

func (c *current) onSingleMarkedTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewMarked(), setElements[*asciidoc.Marked](flat(value.([]any))))
}

func (p *parser) callonSingleMarkedTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleMarkedTextValue1(stack["value"])
}

func (c *current) onDoubleMarkedText1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleMarkedText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedText1(stack["value"])
}

func (c *current) onDoubleMarkedTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoubleMarkedTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedTextValue7(stack["value"])
}

func (c *current) onDoubleMarkedTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewDoubleMarked(), setElements[*asciidoc.DoubleMarked](flat(value.([]any))))
}

func (p *parser) callonDoubleMarkedTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoubleMarkedTextValue1(stack["value"])
}

func (c *current) onExample1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewExampleBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.ExampleBlock](join(lines.([]any))))

}

func (p *parser) callonExample1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExample1(stack["start"], stack["lines"])
}

func (c *current) onExampleStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeExample, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonExampleStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleStart6(stack["delimiter"])
}

func (c *current) onExampleStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonExampleStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleStart1(stack["delimiter"])
}

func (c *current) onExampleEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeExample)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeExample)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonExampleEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleEnd6(stack["delimiter"])
}

func (c *current) onExampleEquals8(hyphens any) (bool, error) {
	return delimitedLength(hyphens) >= 4, nil

}

func (p *parser) callonExampleEquals8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleEquals8(stack["hyphens"])
}

func (c *current) onExampleEquals1(hyphens any) (any, error) {

	return delimitedLength(hyphens), nil

}

func (p *parser) callonExampleEquals1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleEquals1(stack["hyphens"])
}

func (c *current) onExampleDelimiter1(hyphens any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeExample, Length: hyphens.(int)}, nil

}

func (p *parser) callonExampleDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleDelimiter1(stack["hyphens"])
}

func (c *current) onExampleLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonExampleLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onExampleLine1(stack["line"])
}

func (c *current) onLiteral1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewLiteralBlock(start.(asciidoc.Delimiter)), setLines[*asciidoc.LiteralBlock](cast[any, string](lines.([]any))))

}

func (p *parser) callonLiteral1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteral1(stack["start"], stack["lines"])
}

func (c *current) onLiteralStart7(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeLiteral, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonLiteralStart7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralStart7(stack["delimiter"])
}

func (c *current) onLiteralStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonLiteralStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralStart1(stack["delimiter"])
}

func (c *current) onLiteralEnd7(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeLiteral)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeLiteral)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonLiteralEnd7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralEnd7(stack["delimiter"])
}

func (c *current) onLiteralDots8(dots any) (bool, error) {
	return delimitedLength(dots) >= 4, nil

}

func (p *parser) callonLiteralDots8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralDots8(stack["dots"])
}

func (c *current) onLiteralDots1(dots any) (any, error) {

	return delimitedLength(dots), nil

}

func (p *parser) callonLiteralDots1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralDots1(stack["dots"])
}

func (c *current) onLiteralDelimiter1(dots any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeLiteral, Length: dots.(int)}, nil

}

func (p *parser) callonLiteralDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralDelimiter1(stack["dots"])
}

func (c *current) onLiteralLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonLiteralLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLiteralLine1(stack["line"])
}

func (c *current) onSidebar1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewSidebarBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.SidebarBlock](join(lines.([]any))))

}

func (p *parser) callonSidebar1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebar1(stack["start"], stack["lines"])
}

func (c *current) onSidebarStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeSidebar, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonSidebarStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarStart6(stack["delimiter"])
}

func (c *current) onSidebarStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonSidebarStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarStart1(stack["delimiter"])
}

func (c *current) onSidebarEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeSidebar)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeSidebar)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonSidebarEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarEnd6(stack["delimiter"])
}

func (c *current) onSidebarAsterisks8(asterisks any) (bool, error) {
	return delimitedLength(asterisks) >= 4, nil

}

func (p *parser) callonSidebarAsterisks8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarAsterisks8(stack["asterisks"])
}

func (c *current) onSidebarAsterisks1(asterisks any) (any, error) {

	return delimitedLength(asterisks), nil

}

func (p *parser) callonSidebarAsterisks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarAsterisks1(stack["asterisks"])
}

func (c *current) onSidebarDelimiter1(asterisks any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeSidebar, Length: asterisks.(int)}, nil

}

func (p *parser) callonSidebarDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSidebarDelimiter1(stack["asterisks"])
}

func (c *current) onPreParse1(content any) (any, error) {
	return flat(content.([]any)), nil
}

func (p *parser) callonPreParse1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParse1(stack["content"])
}

func (c *current) onPreParseElement1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonPreParseElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseElement1(stack["element"])
}

func (c *current) onPreParseLine1(content any) (any, error) {
	return flat(append(content.([]any), &asciidoc.NewLine{})), nil
}

func (p *parser) callonPreParseLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPreParseLine1(stack["content"])
}

func (c *current) onIfDefBlock1(attributes, lines any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewIfDefBlock(attr.names, attr.union), setElements[*asciidoc.IfDefBlock](flat(lines.([]any))))
}

func (p *parser) callonIfDefBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfDefBlock1(stack["attributes"], stack["lines"])
}

func (c *current) onIfNDefBlock1(attributes, lines any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewIfNDefBlock(attr.names, attr.union), setElements[*asciidoc.IfNDefBlock](flat(lines.([]any))))
}

func (p *parser) callonIfNDefBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfNDefBlock1(stack["attributes"], stack["lines"])
}

func (c *current) onIfEvalBlock1(left, operand, right, lines any) (any, error) {
	return compose(c, asciidoc.NewIfEvalBlock(left.(asciidoc.IfEvalValue), operand.(asciidoc.ConditionalOperator), right.(asciidoc.IfEvalValue)), setElements[*asciidoc.IfEvalBlock](flat(lines.([]any))))

}

func (p *parser) callonIfEvalBlock1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalBlock1(stack["left"], stack["operand"], stack["right"], stack["lines"])
}

func (c *current) onQuote1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewQuoteBlock(start.(asciidoc.Delimiter)), setElements[*asciidoc.QuoteBlock](join(lines.([]any))))

}

func (p *parser) callonQuote1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuote1(stack["start"], stack["lines"])
}

func (c *current) onQuoteStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeQuote, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonQuoteStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteStart6(stack["delimiter"])
}

func (c *current) onQuoteStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonQuoteStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteStart1(stack["delimiter"])
}

func (c *current) onQuoteEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeQuote)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeQuote)
		return true, nil
	}
	return false, nil
}

func (p *parser) callonQuoteEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteEnd6(stack["delimiter"])
}

func (c *current) onQuoteUnderlines8(underlines any) (bool, error) {
	return delimitedLength(underlines) >= 4, nil

}

func (p *parser) callonQuoteUnderlines8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteUnderlines8(stack["underlines"])
}

func (c *current) onQuoteUnderlines1(underlines any) (any, error) {

	return delimitedLength(underlines), nil

}

func (p *parser) callonQuoteUnderlines1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteUnderlines1(stack["underlines"])
}

func (c *current) onQuoteDelimiter1(underlines any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeQuote, Length: underlines.(int)}, nil

}

func (p *parser) callonQuoteDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onQuoteDelimiter1(stack["underlines"])
}

func (c *current) onListItemValue1(line, lines, attachedBlocks any) (any, error) {
	value := []any{line}
	if lines != nil {
		value = append(value, lines.([]any)...)
	}
	if attachedBlocks != nil {
		value = append(value, attachedBlocks.([]any))
	}
	return flat(value), nil
}

func (p *parser) callonListItemValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListItemValue1(stack["line"], stack["lines"], stack["attachedBlocks"])
}

func (c *current) onListContinuationMarker1(newlines any) (any, error) {
	count := len(newlines.([]any))
	if count > 0 {
		count--
	}
	return count, nil
}

func (p *parser) callonListContinuationMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListContinuationMarker1(stack["newlines"])
}

func (c *current) onListContinuation1(marker, value any) (any, error) {
	return compose(c, asciidoc.NewListContinuation(value.(asciidoc.Element), marker.(int)))
}

func (p *parser) callonListContinuation1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListContinuation1(stack["marker"], stack["value"])
}

func (c *current) onListItemLine1(element any) (any, error) {
	return append([]any{&asciidoc.NewLine{}}, element.([]any)...), nil
}

func (p *parser) callonListItemLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onListItemLine1(stack["element"])
}

func (c *current) onAttachedBlocks1(blocks any) (any, error) {
	return blocks, nil
}

func (p *parser) callonAttachedBlocks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onAttachedBlocks1(stack["blocks"])
}

func (c *current) onContinuationBlockElement7(element any) (bool, error) {
	return element != nil, nil
}

func (p *parser) callonContinuationBlockElement7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onContinuationBlockElement7(stack["element"])
}

func (c *current) onContinuationBlockElement1(element any) (any, error) {
	return element, nil
}

func (p *parser) callonContinuationBlockElement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onContinuationBlockElement1(stack["element"])
}

func (c *current) onContinuationBlockElements6(els any) (any, error) {
	return compose(c, asciidoc.NewParagraph(), setElements[*asciidoc.Paragraph](els.(asciidoc.Elements)))

}

func (p *parser) callonContinuationBlockElements6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onContinuationBlockElements6(stack["els"])
}

func (c *current) onThematicBreak1() (any, error) {
	return compose(c, asciidoc.NewThematicBreak())
}

func (p *parser) callonThematicBreak1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onThematicBreak1()
}

func (c *current) onPageBreak1() (any, error) {
	return compose(c, asciidoc.NewPageBreak())
}

func (p *parser) callonPageBreak1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPageBreak1()
}

func (c *current) onFenced1(start, lines any) (any, error) {

	return compose(c, asciidoc.NewFencedBlock(start.(asciidoc.FencedDelimiter)), setElements[*asciidoc.FencedBlock](join(lines.([]any))))

}

func (p *parser) callonFenced1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFenced1(stack["start"], stack["lines"])
}

func (c *current) onFencedStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeFenced, delimiter.(asciidoc.FencedDelimiter).Length)
	return true, nil

}

func (p *parser) callonFencedStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedStart6(stack["delimiter"])
}

func (c *current) onFencedStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonFencedStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedStart1(stack["delimiter"])
}

func (c *current) onFencedEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeFenced)
	if previous == delimiter.(asciidoc.FencedDelimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeFenced)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonFencedEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedEnd6(stack["delimiter"])
}

func (c *current) onFencedBackticks8(backticks any) (bool, error) {
	return delimitedLength(backticks) >= 3, nil

}

func (p *parser) callonFencedBackticks8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedBackticks8(stack["backticks"])
}

func (c *current) onFencedBackticks1(backticks any) (any, error) {

	return delimitedLength(backticks), nil

}

func (p *parser) callonFencedBackticks1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedBackticks1(stack["backticks"])
}

func (c *current) onFencedDelimiter1(hyphens, language any) (any, error) {

	var lang asciidoc.Elements
	if language != nil {
		lang = join(language.(asciidoc.Elements))
	}
	return asciidoc.NewFencedDelimiter(hyphens.(int), lang), nil

}

func (p *parser) callonFencedDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedDelimiter1(stack["hyphens"], stack["language"])
}

func (c *current) onFencedLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonFencedLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onFencedLine1(stack["line"])
}

func (c *current) onStem1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewStemBlock(start.(asciidoc.Delimiter)), setLines[*asciidoc.StemBlock](cast[any, string](lines.([]any))))

}

func (p *parser) callonStem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStem1(stack["start"], stack["lines"])
}

func (c *current) onStemStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeStem, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonStemStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemStart6(stack["delimiter"])
}

func (c *current) onStemStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonStemStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemStart1(stack["delimiter"])
}

func (c *current) onStemEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeStem)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeStem)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonStemEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemEnd6(stack["delimiter"])
}

func (c *current) onStemPluses8(pluses any) (bool, error) {
	return delimitedLength(pluses) >= 4, nil

}

func (p *parser) callonStemPluses8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemPluses8(stack["pluses"])
}

func (c *current) onStemPluses1(pluses any) (any, error) {

	return delimitedLength(pluses), nil

}

func (p *parser) callonStemPluses1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemPluses1(stack["pluses"])
}

func (c *current) onStemDelimiter1(pluses any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeStem, Length: pluses.(int)}, nil

}

func (p *parser) callonStemDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemDelimiter1(stack["pluses"])
}

func (c *current) onStemLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonStemLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onStemLine1(stack["line"])
}

func (c *current) onInternalCrossReference8(label any) (any, error) {
	return label, nil
}

func (p *parser) callonInternalCrossReference8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInternalCrossReference8(stack["label"])
}

func (c *current) onInternalCrossReference1(id, label any) (any, error) {
	var lbl asciidoc.Elements
	if label != nil {
		lbl = join(label.([]any))
	}
	return compose(c, asciidoc.NewCrossReference(id.(asciidoc.Elements), asciidoc.CrossReferenceFormatNatural), setElements[*asciidoc.CrossReference](lbl))
}

func (p *parser) callonInternalCrossReference1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInternalCrossReference1(stack["id"], stack["label"])
}

func (c *current) onCrossReferenceInitialCharacter1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonCrossReferenceInitialCharacter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceInitialCharacter1()
}

func (c *current) onCrossReferenceCharacters1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonCrossReferenceCharacters1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceCharacters1()
}

func (c *current) onCrossReferenceID1(start, end any) (any, error) {

	var id []any
	id = append(id, start)
	if end != nil {
		id = append(id, end.([]any)...)
	}
	return join(id), nil
}

func (p *parser) callonCrossReferenceID1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceID1(stack["start"], stack["end"])
}

func (c *current) onCrossReferenceMacroLabel1(content any) (any, error) {
	return content, nil
}

func (p *parser) callonCrossReferenceMacroLabel1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceMacroLabel1(stack["content"])
}

func (c *current) onCrossReferenceMacro1(path, label any) (any, error) {
	var lbl asciidoc.Elements
	if label != nil {
		lbl = join(label.([]any))
	}
	return compose(c, asciidoc.NewCrossReference(path.(asciidoc.Elements), asciidoc.CrossReferenceFormatMacro), setElements[*asciidoc.CrossReference](lbl))
}

func (p *parser) callonCrossReferenceMacro1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCrossReferenceMacro1(stack["path"], stack["label"])
}

func (c *current) onUppercaseRoman15(thousands, hundreds, tens, ones any) (bool, error) {
	return thousands != nil || hundreds != nil || tens != nil || ones != nil, nil
}

func (p *parser) callonUppercaseRoman15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRoman15(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onUppercaseRoman1(thousands, hundreds, tens, ones any) (any, error) {
	return string(c.text), nil
}

func (p *parser) callonUppercaseRoman1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRoman1(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onUppercaseRomanHundreds9(hundreds any) (bool, error) {
	return len(hundreds.([]any)) < 4, nil
}

func (p *parser) callonUppercaseRomanHundreds9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRomanHundreds9(stack["hundreds"])
}

func (c *current) onUppercaseRomanTens10(tens any) (bool, error) {
	return len(tens.([]any)) < 4, nil
}

func (p *parser) callonUppercaseRomanTens10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRomanTens10(stack["tens"])
}

func (c *current) onUppercaseRomanOnes10(ones any) (bool, error) {
	return len(ones.([]any)) < 4, nil
}

func (p *parser) callonUppercaseRomanOnes10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUppercaseRomanOnes10(stack["ones"])
}

func (c *current) onLowercaseRoman15(thousands, hundreds, tens, ones any) (bool, error) {
	return thousands != nil || hundreds != nil || tens != nil || ones != nil, nil
}

func (p *parser) callonLowercaseRoman15() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRoman15(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onLowercaseRoman1(thousands, hundreds, tens, ones any) (any, error) {
	return string(c.text), nil
}

func (p *parser) callonLowercaseRoman1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRoman1(stack["thousands"], stack["hundreds"], stack["tens"], stack["ones"])
}

func (c *current) onLowercaseRomanHundreds9(hundreds any) (bool, error) {
	return len(hundreds.([]any)) < 4, nil
}

func (p *parser) callonLowercaseRomanHundreds9() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRomanHundreds9(stack["hundreds"])
}

func (c *current) onLowercaseRomanTens10(tens any) (bool, error) {
	return len(tens.([]any)) < 4, nil
}

func (p *parser) callonLowercaseRomanTens10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRomanTens10(stack["tens"])
}

func (c *current) onLowercaseRomanOnes10(ones any) (bool, error) {
	return len(ones.([]any)) < 4, nil
}

func (p *parser) callonLowercaseRomanOnes10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLowercaseRomanOnes10(stack["ones"])
}

func (c *current) onOrderedListItem1(marker, value any) (any, error) {
	m := marker.(listMarker)
	return compose(c, asciidoc.NewOrderedListItem(m.indent, m.marker), setElements[*asciidoc.OrderedListItem](value.(asciidoc.Elements)))
}

func (p *parser) callonOrderedListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListItem1(stack["marker"], stack["value"])
}

func (c *current) onOrderedListMarker10() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker10()
}

func (c *current) onOrderedListMarker13(ordinal any) (bool, error) {
	return len(ordinal.(string)) <= 10, nil
}

func (p *parser) callonOrderedListMarker13() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker13(stack["ordinal"])
}

func (c *current) onOrderedListMarker7(ordinal any) (any, error) {

	return ordinal, nil
}

func (p *parser) callonOrderedListMarker7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker7(stack["ordinal"])
}

func (c *current) onOrderedListMarker14() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker14() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker14()
}

func (c *current) onOrderedListMarker19() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker19() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker19()
}

func (c *current) onOrderedListMarker23() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker23() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker23()
}

func (c *current) onOrderedListMarker27() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker27() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker27()
}

func (c *current) onOrderedListMarker31() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonOrderedListMarker31() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker31()
}

func (c *current) onOrderedListMarker1(indent, marker any) (any, error) {
	return listMarker{marker: marker.(string), indent: toString(indent)}, nil
}

func (p *parser) callonOrderedListMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOrderedListMarker1(stack["indent"], stack["marker"])
}

func (c *current) onUnorderedListItem1(marker, checklist, value any) (any, error) {
	cl, _ := checklist.(asciidoc.Checklist)
	m := marker.(listMarker)
	return compose(c, asciidoc.NewUnorderedListItem(m.indent, m.marker, cl), setElements[*asciidoc.UnorderedListItem](value.(asciidoc.Elements)))
}

func (p *parser) callonUnorderedListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListItem1(stack["marker"], stack["checklist"], stack["value"])
}

func (c *current) onUnorderedListMarker6() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonUnorderedListMarker6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListMarker6()
}

func (c *current) onUnorderedListMarker12(indent, marker any) (bool, error) {
	return len(marker.(string)) <= 10, nil
}

func (p *parser) callonUnorderedListMarker12() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListMarker12(stack["indent"], stack["marker"])
}

func (c *current) onUnorderedListMarker1(indent, marker any) (any, error) {
	return listMarker{marker: marker.(string), indent: toString(indent)}, nil
}

func (p *parser) callonUnorderedListMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnorderedListMarker1(stack["indent"], stack["marker"])
}

func (c *current) onChecklist7() (any, error) {
	return asciidoc.ChecklistUnchecked, nil
}

func (p *parser) callonChecklist7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist7()
}

func (c *current) onChecklist9() (any, error) {
	return asciidoc.ChecklistChecked, nil
}

func (p *parser) callonChecklist9() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist9()
}

func (c *current) onChecklist11() (any, error) {
	return asciidoc.ChecklistChecked, nil
}

func (p *parser) callonChecklist11() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist11()
}

func (c *current) onChecklist1(checklist any) (any, error) {
	return checklist, nil

}

func (p *parser) callonChecklist1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onChecklist1(stack["checklist"])
}

func (c *current) onDescriptionListItem13() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonDescriptionListItem13() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListItem13()
}

func (c *current) onDescriptionListItem1(inlineAnchor, term, marker, whitespace, value any) (any, error) {
	dli := asciidoc.NewDescriptionListItem(marker.(string), term.(asciidoc.Elements))
	values := cast[any, asciidoc.Element](whitespace.([]any))
	values = append(values, value.(asciidoc.Elements)...)
	cos := []composeOption[*asciidoc.DescriptionListItem]{setElements[*asciidoc.DescriptionListItem](asciidoc.Elements(values))}
	if inlineAnchor != nil {
		cos = append(cos, setAttributes[*asciidoc.DescriptionListItem](inlineAnchor))
	}
	return compose(c, dli, cos...)
}

func (p *parser) callonDescriptionListItem1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListItem1(stack["inlineAnchor"], stack["term"], stack["marker"], stack["whitespace"], stack["value"])
}

func (c *current) onDescriptionListTerm1(term any) (any, error) {
	return flat(term.([]any)), nil
}

func (p *parser) callonDescriptionListTerm1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListTerm1(stack["term"])
}

func (c *current) onDescriptionListMarker5() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonDescriptionListMarker5() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListMarker5()
}

func (c *current) onDescriptionListMarker10(marker any) (bool, error) {
	switch marker.(string) {
	case "::", ":::", "::::", ";;":
		return true, nil
	}
	return false, nil
}

func (p *parser) callonDescriptionListMarker10() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListMarker10(stack["marker"])
}

func (c *current) onDescriptionListMarker1(marker any) (any, error) {
	return marker.(string), nil
}

func (p *parser) callonDescriptionListMarker1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListMarker1(stack["marker"])
}

func (c *current) onDescriptionListItemValue1(line, attachedBlocks any) (any, error) {
	value := []any{line}
	if attachedBlocks != nil {
		value = append(value, attachedBlocks.([]any))
	}
	return flat(value), nil
}

func (p *parser) callonDescriptionListItemValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDescriptionListItemValue1(stack["line"], stack["attachedBlocks"])
}

func (c *current) onSingleLineComment1(comment any) (any, error) {
	return compose(c, asciidoc.NewSingleLineComment(comment.(string)))
}

func (p *parser) callonSingleLineComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineComment1(stack["comment"])
}

func (c *current) onSingleLineCommentDelimiter1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonSingleLineCommentDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineCommentDelimiter1()
}

func (c *current) onSingleLineCommentContent1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonSingleLineCommentContent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSingleLineCommentContent1()
}

func (c *current) onMultiLineComment1(start, lines any) (any, error) {
	return compose(c, asciidoc.NewMultiLineComment(start.(asciidoc.Delimiter)), setLines[*asciidoc.MultiLineComment](cast[any, string](lines.([]any))))

}

func (p *parser) callonMultiLineComment1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineComment1(stack["start"], stack["lines"])
}

func (c *current) onMultiLineCommentStart6(delimiter any) (bool, error) {
	c.pushDelimitedLevel(asciidoc.DelimitedBlockTypeMultiLineComment, delimiter.(asciidoc.Delimiter).Length)
	return true, nil

}

func (p *parser) callonMultiLineCommentStart6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentStart6(stack["delimiter"])
}

func (c *current) onMultiLineCommentStart1(delimiter any) (any, error) {
	return delimiter, nil

}

func (p *parser) callonMultiLineCommentStart1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentStart1(stack["delimiter"])
}

func (c *current) onMultiLineCommentEnd6(delimiter any) (bool, error) {
	previous := c.peekDelimitedLevel(asciidoc.DelimitedBlockTypeMultiLineComment)
	if previous == delimiter.(asciidoc.Delimiter).Length {
		c.popDelimitedLevel(asciidoc.DelimitedBlockTypeMultiLineComment)
		return true, nil
	}
	return false, nil

}

func (p *parser) callonMultiLineCommentEnd6() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentEnd6(stack["delimiter"])
}

func (c *current) onMultiLineCommentForwardSlashes8(forwardSlashes any) (bool, error) {
	return delimitedLength(forwardSlashes) >= 4, nil

}

func (p *parser) callonMultiLineCommentForwardSlashes8() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentForwardSlashes8(stack["forwardSlashes"])
}

func (c *current) onMultiLineCommentForwardSlashes1(forwardSlashes any) (any, error) {

	return delimitedLength(forwardSlashes), nil

}

func (p *parser) callonMultiLineCommentForwardSlashes1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentForwardSlashes1(stack["forwardSlashes"])
}

func (c *current) onMultiLineCommentDelimiter1(forwardSlashes any) (any, error) {
	return asciidoc.Delimiter{Type: asciidoc.DelimitedBlockTypeMultiLineComment, Length: forwardSlashes.(int)}, nil

}

func (p *parser) callonMultiLineCommentDelimiter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentDelimiter1(stack["forwardSlashes"])
}

func (c *current) onMultiLineCommentLine1(line any) (any, error) {
	return toString(line), nil
}

func (p *parser) callonMultiLineCommentLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onMultiLineCommentLine1(stack["line"])
}

func (c *current) onCounterIncrement1(name, initialValue any) (any, error) {
	return populatePosition(c, asciidoc.NewCounter(name.(string), initialValue, true)), nil
}

func (p *parser) callonCounterIncrement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterIncrement1(stack["name"], stack["initialValue"])
}

func (c *current) onCounterSilentIncrement1(name, initialValue any) (any, error) {
	return populatePosition(c, asciidoc.NewCounter(name.(string), initialValue, false)), nil
}

func (p *parser) callonCounterSilentIncrement1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterSilentIncrement1(stack["name"], stack["initialValue"])
}

func (c *current) onCounterInitialValue1(initializer any) (any, error) {
	return initializer, nil
}

func (p *parser) callonCounterInitialValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterInitialValue1(stack["initializer"])
}

func (c *current) onCounterInitializer2() (any, error) {

	return string(c.text), nil

}

func (p *parser) callonCounterInitializer2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterInitializer2()
}

func (c *current) onCounterInitializer4() (any, error) {

	return strconv.Atoi(string(c.text))

}

func (p *parser) callonCounterInitializer4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCounterInitializer4()
}

func (c *current) onInlinePassthrough1(attributes, text any) (any, error) {
	return compose(c, text.(asciidoc.AttributableElement), setAttributes[asciidoc.AttributableElement](attributes))
}

func (p *parser) callonInlinePassthrough1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlinePassthrough1(stack["attributes"], stack["text"])
}

func (c *current) onInlineSinglePassthrough1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonInlineSinglePassthrough1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineSinglePassthrough1(stack["value"])
}

func (c *current) onSinglePassthroughTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonSinglePassthroughTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSinglePassthroughTextValue7(stack["value"])
}

func (c *current) onSinglePassthroughTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewInlinePassthrough(), setElements[*asciidoc.InlinePassthrough](flat(value.([]any))))
}

func (p *parser) callonSinglePassthroughTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSinglePassthroughTextValue1(stack["value"])
}

func (c *current) onInlineDoublePassthrough1(value any) (any, error) {
	return value, nil
}

func (p *parser) callonInlineDoublePassthrough1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineDoublePassthrough1(stack["value"])
}

func (c *current) onDoublePassthroughTextValue7(value any) (any, error) {
	return value, nil
}

func (p *parser) callonDoublePassthroughTextValue7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoublePassthroughTextValue7(stack["value"])
}

func (c *current) onDoublePassthroughTextValue1(value any) (any, error) {
	return compose(c, asciidoc.NewInlineDoublePassthrough(), setElements[*asciidoc.InlineDoublePassthrough](flat(value.([]any))))
}

func (p *parser) callonDoublePassthroughTextValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onDoublePassthroughTextValue1(stack["value"])
}

func (c *current) onIfDef1(attributes any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return asciidoc.NewIfDef(attr.names, attr.union), nil
}

func (p *parser) callonIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfDef1(stack["attributes"])
}

func (c *current) onIfNDef1(attributes any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return asciidoc.NewIfNDef(attr.names, attr.union), nil
}

func (p *parser) callonIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfNDef1(stack["attributes"])
}

func (c *current) onInlineIfDef1(attributes, content any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewInlineIfDef(attr.names, attr.union), setElements[*asciidoc.InlineIfDef](content))
}

func (p *parser) callonInlineIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfDef1(stack["attributes"], stack["content"])
}

func (c *current) onInlineIfNDef1(attributes, content any) (any, error) {
	attr := attributes.(conditionalAttributes)
	return compose(c, asciidoc.NewInlineIfNDef(attr.names, attr.union), setElements[*asciidoc.InlineIfNDef](content))
}

func (p *parser) callonInlineIfNDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineIfNDef1(stack["attributes"], stack["content"])
}

func (c *current) onEndIfDef1(attributes any) (any, error) {
	var attr []asciidoc.AttributeName
	var union asciidoc.ConditionalUnion
	if attributes != nil {
		attr = attributes.(conditionalAttributes).names
		union = attributes.(conditionalAttributes).union
	}
	return asciidoc.NewEndIf(attr, union), nil
}

func (p *parser) callonEndIfDef1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEndIfDef1(stack["attributes"])
}

func (c *current) onConditionalAttributesAny12(name any) (bool, error) {
	return len(name.(string)) > 0, nil

}

func (p *parser) callonConditionalAttributesAny12() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAny12(stack["name"])
}

func (c *current) onConditionalAttributesAny4(name any) (any, error) {
	return asciidoc.AttributeName(name.(string)), nil

}

func (p *parser) callonConditionalAttributesAny4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAny4(stack["name"])
}

func (c *current) onConditionalAttributesAny1(names any) (any, error) {
	return conditionalAttributes{names: cast[any, asciidoc.AttributeName](names.([]any)), union: asciidoc.ConditionalUnionAny}, nil
}

func (p *parser) callonConditionalAttributesAny1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAny1(stack["names"])
}

func (c *current) onConditionalAttributesAll12(name any) (bool, error) {
	return len(name.(string)) > 0, nil

}

func (p *parser) callonConditionalAttributesAll12() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAll12(stack["name"])
}

func (c *current) onConditionalAttributesAll4(name any) (any, error) {
	return asciidoc.AttributeName(name.(string)), nil

}

func (p *parser) callonConditionalAttributesAll4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAll4(stack["name"])
}

func (c *current) onConditionalAttributesAll1(names any) (any, error) {
	return conditionalAttributes{names: cast[any, asciidoc.AttributeName](names.([]any)), union: asciidoc.ConditionalUnionAll}, nil
}

func (p *parser) callonConditionalAttributesAll1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onConditionalAttributesAll1(stack["names"])
}

func (c *current) onIfEval1(left, operand, right any) (any, error) {
	return asciidoc.NewIfEval(left.(asciidoc.IfEvalValue), operand.(asciidoc.ConditionalOperator), right.(asciidoc.IfEvalValue)), nil
}

func (p *parser) callonIfEval1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEval1(stack["left"], stack["operand"], stack["right"])
}

func (c *current) onIfEvalValue1(val any) (any, error) {
	return asciidoc.IfEvalValue{Quote: val.(*attributeValue).quote, Value: val.(*attributeValue).value}, nil
}

func (p *parser) callonIfEvalValue1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalValue1(stack["val"])
}

func (c *current) onIfEvalOperator2() (any, error) {
	return asciidoc.ConditionalOperatorEqual, nil
}

func (p *parser) callonIfEvalOperator2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator2()
}

func (c *current) onIfEvalOperator4() (any, error) {
	return asciidoc.ConditionalOperatorNotEqual, nil
}

func (p *parser) callonIfEvalOperator4() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator4()
}

func (c *current) onIfEvalOperator6() (any, error) {
	return asciidoc.ConditionalOperatorLessThan, nil
}

func (p *parser) callonIfEvalOperator6() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator6()
}

func (c *current) onIfEvalOperator8() (any, error) {
	return asciidoc.ConditionalOperatorLessThanOrEqual, nil
}

func (p *parser) callonIfEvalOperator8() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator8()
}

func (c *current) onIfEvalOperator10() (any, error) {
	return asciidoc.ConditionalOperatorGreaterThan, nil
}

func (p *parser) callonIfEvalOperator10() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator10()
}

func (c *current) onIfEvalOperator12() (any, error) {
	return asciidoc.ConditionalOperatorGreaterThanOrEqual, nil
}

func (p *parser) callonIfEvalOperator12() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIfEvalOperator12()
}

func (c *current) onSpecialCharacter1() (any, error) {
	return asciidoc.NewSpecialCharacter(string(c.text)), nil
}

func (p *parser) callonSpecialCharacter1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onSpecialCharacter1()
}

func (c *current) onApostrophe2() (any, error) {
	return asciidoc.NewString("'"), nil

}

func (p *parser) callonApostrophe2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onApostrophe2()
}

func (c *current) onApostrophe7() (any, error) {
	return asciidoc.NewString("'"), nil

}

func (p *parser) callonApostrophe7() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onApostrophe7()
}

func (c *current) onPunctuation1() (any, error) {
	return asciidoc.NewString(string(c.text)), nil
}

func (p *parser) callonPunctuation1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPunctuation1()
}

func (c *current) onLineBreak7() (bool, error) {
	return c.previousRuneIsWhitespace(), nil
}

func (p *parser) callonLineBreak7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLineBreak7()
}

func (c *current) onLineBreak1() (any, error) {
	return &asciidoc.LineBreak{}, nil
}

func (p *parser) callonLineBreak1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onLineBreak1()
}

func (c *current) onEmptyLine1() (any, error) {
	return compose(c, asciidoc.NewEmptyLine(string(c.text)))

}

func (p *parser) callonEmptyLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onEmptyLine1()
}

func (c *current) onNewLine1() (any, error) {
	return compose(c, &asciidoc.NewLine{})
}

func (p *parser) callonNewLine1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onNewLine1()
}

func (c *current) onPercentage1(percentage any) (any, error) {
	return percentage, nil
}

func (p *parser) callonPercentage1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPercentage1(stack["percentage"])
}

func (c *current) onPositiveInteger5() (bool, error) {
	return len(string(c.text)) < 10, nil
}

func (p *parser) callonPositiveInteger5() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPositiveInteger5()
}

func (c *current) onPositiveInteger1() (any, error) {
	return strconv.Atoi(string(c.text))
}

func (p *parser) callonPositiveInteger1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onPositiveInteger1()
}

func (c *current) onBeginningOfFile4() (bool, error) {
	if c.pos.line == 0 && c.pos.col == 0 {
	}
	return c.pos.line == 0 && c.pos.col == 0, nil
}

func (p *parser) callonBeginningOfFile4() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onBeginningOfFile4()
}

func (c *current) onOffsetCharacter3() (bool, error) {
	return c.currentColumn() > 1, nil
}

func (p *parser) callonOffsetCharacter3() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onOffsetCharacter3()
}

func (c *current) onIndent7() (bool, error) {
	return c.pos.col < 2, nil
}

func (p *parser) callonIndent7() (bool, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndent7()
}

func (c *current) onIndent1() (any, error) {
	return nil, nil
}

func (p *parser) callonIndent1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onIndent1()
}

func (c *current) onInlineText2() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonInlineText2() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onInlineText2()
}

func (c *current) onUnbrokenText1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonUnbrokenText1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onUnbrokenText1()
}

func (c *current) onCharacterClassAll1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callonCharacterClassAll1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.onCharacterClassAll1()
}

func (c *current) on__1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callon__1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on__1()
}

func (c *current) on_1() (any, error) {
	return string(c.text), nil
}

func (p *parser) callon_1() (any, error) {
	stack := p.vstack[len(p.vstack)-1]
	_ = stack
	return p.cur.on_1()
}

var (
	// errNoRule is returned when the grammar to parse has no rule.
	errNoRule = errors.New("grammar has no rule")

	// errInvalidEntrypoint is returned when the specified entrypoint rule
	// does not exit.
	errInvalidEntrypoint = errors.New("invalid entrypoint")

	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errMaxExprCnt is used to signal that the maximum number of
	// expressions have been parsed.
	errMaxExprCnt = errors.New("max number of expressions parsed")
)

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*parser) Option

// MaxExpressions creates an Option to stop parsing after the provided
// number of expressions have been parsed, if the value is 0 then the parser will
// parse for as many steps as needed (possibly an infinite number).
//
// The default for maxExprCnt is 0.
func MaxExpressions(maxExprCnt uint64) Option {
	return func(p *parser) Option {
		oldMaxExprCnt := p.maxExprCnt
		p.maxExprCnt = maxExprCnt
		return MaxExpressions(oldMaxExprCnt)
	}
}

// Entrypoint creates an Option to set the rule name to use as entrypoint.
// The rule name must have been specified in the -alternate-entrypoints
// if generating the parser with the -optimize-grammar flag, otherwise
// it may have been optimized out. Passing an empty string sets the
// entrypoint to the first rule in the grammar.
//
// The default is to start parsing at the first rule in the grammar.
func Entrypoint(ruleName string) Option {
	return func(p *parser) Option {
		oldEntrypoint := p.entrypoint
		p.entrypoint = ruleName
		if ruleName == "" {
			p.entrypoint = g.rules[0].name
		}
		return Entrypoint(oldEntrypoint)
	}
}

// AllowInvalidUTF8 creates an Option to allow invalid UTF-8 bytes.
// Every invalid UTF-8 byte is treated as a utf8.RuneError (U+FFFD)
// by character class matchers and is matched by the any matcher.
// The returned matched value, c.text and c.offset are NOT affected.
//
// The default is false.
func AllowInvalidUTF8(b bool) Option {
	return func(p *parser) Option {
		old := p.allowInvalidUTF8
		p.allowInvalidUTF8 = b
		return AllowInvalidUTF8(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(p *parser) Option {
		old := p.recover
		p.recover = b
		return Recover(old)
	}
}

// GlobalStore creates an Option to set a key to a certain value in
// the globalStore.
func GlobalStore(key string, value any) Option {
	return func(p *parser) Option {
		old := p.cur.globalStore[key]
		p.cur.globalStore[key] = value
		return GlobalStore(key, old)
	}
}

// ParseFile parses the file identified by filename.
func parseFile(filename string, opts ...Option) (i any, err error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer func() {
		if closeErr := f.Close(); closeErr != nil {
			err = closeErr
		}
	}()
	return parseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func parseReader(filename string, r io.Reader, opts ...Option) (any, error) {
	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func parse(filename string, b []byte, opts ...Option) (any, error) {
	return newParser(filename, b, opts...).parse(g)
}

// position records a position in the text.
type position struct {
	line, col, offset int
}

func (p position) String() string {
	return strconv.Itoa(p.line) + ":" + strconv.Itoa(p.col) + " [" + strconv.Itoa(p.offset) + "]"
}

// savepoint stores all state required to go back to this point in the
// parser.
type savepoint struct {
	position
	rn rune
	w  int
}

type current struct {
	pos  position // start position of the match
	text []byte   // raw text of the match

	// globalStore is a general store for the user to store arbitrary key-value
	// pairs that they need to manage and that they do not want tied to the
	// backtracking of the parser. This is only modified by the user and never
	// rolled back by the parser. It is always up to the user to keep this in a
	// consistent state.
	globalStore storeDict

	parser                *parser                         // Alchemy patch: we keep a reference to the parent parser here, so inline code can access it
	delimitedBlockState   delimitedBlockState             // Alchemy patch: we keep track of levels of delimited blocks here
	tableColumnsAttribute *asciidoc.TableColumnsAttribute // Alchemy patch: we keep track of explicit table columns here to aid in allocating columns
}

type storeDict map[string]any

// the AST types...

type grammar struct {
	pos   position
	rules []*rule
}

type rule struct {
	pos         position
	name        string
	displayName string
	expr        any
}

type choiceExpr struct {
	pos          position
	alternatives []any
}

type actionExpr struct {
	pos  position
	expr any
	run  func(*parser) (any, error)
}

type recoveryExpr struct {
	pos          position
	expr         any
	recoverExpr  any
	failureLabel []string
}

type seqExpr struct {
	pos   position
	exprs []any
}

type throwExpr struct {
	pos   position
	label string
}

type labeledExpr struct {
	pos   position
	label string
	expr  any
}

type expr struct {
	pos  position
	expr any
}

type (
	andExpr        expr
	notExpr        expr
	zeroOrOneExpr  expr
	zeroOrMoreExpr expr
	oneOrMoreExpr  expr
)

type ruleRefExpr struct {
	pos    position
	offset int
}

type andCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type notCodeExpr struct {
	pos position
	run func(*parser) (bool, error)
}

type litMatcher struct {
	pos        position
	val        string
	ignoreCase bool
	want       string
}

type charClassMatcher struct {
	pos position
	val string
	// Alchemy patch: we don't use this optimization, so don't allocate the array
	//basicLatinChars [128]bool
	chars      []rune
	ranges     []rune
	classes    []*unicode.RangeTable
	ignoreCase bool
	inverted   bool
}

type anyMatcher position

// errList cumulates the errors found by the parser.
type errList []error

func (e *errList) add(err error) {
	*e = append(*e, err)
}

func (e errList) err() error {
	if len(e) == 0 {
		return nil
	}
	e.dedupe()
	return e
}

func (e *errList) dedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

func (e errList) Error() string {
	switch len(e) {
	case 0:
		return ""
	case 1:
		return e[0].Error()
	default:
		var buf bytes.Buffer

		for i, err := range e {
			if i > 0 {
				buf.WriteRune('\n')
			}
			buf.WriteString(err.Error())
		}
		return buf.String()
	}
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
type parserError struct {
	Inner    error
	pos      position
	prefix   string
	expected []string
}

// Error returns the error message.
func (p *parserError) Error() string {
	return p.prefix + ": " + p.Inner.Error()
}

// newParser creates a parser with the specified input source and options.
func newParser(filename string, b []byte, opts ...Option) *parser {
	stats := Stats{
		ChoiceAltCnt: make(map[string]map[string]int),
	}

	p := &parser{
		filename: filename,
		errs:     new(errList),
		data:     b,
		pt:       savepoint{position: position{line: 1}},
		recover:  true,
		cur: current{
			globalStore:         make(storeDict),
			delimitedBlockState: make(delimitedBlockState),
		},
		maxFailPos:      position{col: 1, line: 1},
		maxFailExpected: make([]string, 0, 20),
		Stats:           &stats,
		// start rule is rule [0] unless an alternate entrypoint is specified
		entrypoint: g.rules[0].name,
	}
	p.setOptions(opts)
	p.cur.parser = p

	if p.maxExprCnt == 0 {
		p.maxExprCnt = math.MaxUint64
	}

	return p
}

// setOptions applies the options to the parser.
func (p *parser) setOptions(opts []Option) {
	for _, opt := range opts {
		opt(p)
	}
}

type resultTuple struct {
	v   any
	b   bool
	end savepoint
}

const choiceNoMatch = -1

// Stats stores some statistics, gathered during parsing
type Stats struct {
	// ExprCnt counts the number of expressions processed during parsing
	// This value is compared to the maximum number of expressions allowed
	// (set by the MaxExpressions option).
	ExprCnt uint64

	// ChoiceAltCnt is used to count for each ordered choice expression,
	// which alternative is used how may times.
	// These numbers allow to optimize the order of the ordered choice expression
	// to increase the performance of the parser
	//
	// The outer key of ChoiceAltCnt is composed of the name of the rule as well
	// as the line and the column of the ordered choice.
	// The inner key of ChoiceAltCnt is the number (one-based) of the matching alternative.
	// For each alternative the number of matches are counted. If an ordered choice does not
	// match, a special counter is incremented. The name of this counter is set with
	// the parser option Statistics.
	// For an alternative to be included in ChoiceAltCnt, it has to match at least once.
	ChoiceAltCnt map[string]map[string]int
}

type parser struct {
	filename string
	pt       savepoint
	cur      current

	data []byte
	errs *errList

	depth   int
	recover bool

	// rules table, maps the rule offset to the rule node
	rules []*rule
	// variables stack, map of label to value
	vstack []map[string]any
	// rule stack, allows identification of the current rule in errors
	rstack []*rule

	// parse fail
	maxFailPos            position
	maxFailExpected       []string
	maxFailInvertExpected bool

	// max number of expressions to be parsed
	maxExprCnt uint64
	// entrypoint for the parser
	entrypoint string

	allowInvalidUTF8 bool

	*Stats

	choiceNoMatch string
	// recovery expression stack, keeps track of the currently available recovery expression, these are traversed in reverse
	recoveryStack []map[string]any

	offset   position           // Alchemy patch: we add an offset field to track element positions in the doc
	document *asciidoc.Document // Alchemy patch: we add a reference to the document being parsed
}

// push a variable set on the vstack.
func (p *parser) pushV() {
	if cap(p.vstack) == len(p.vstack) {
		// create new empty slot in the stack
		p.vstack = append(p.vstack, nil)
	} else {
		// slice to 1 more
		p.vstack = p.vstack[:len(p.vstack)+1]
	}

	// get the last args set
	m := p.vstack[len(p.vstack)-1]
	if m != nil && len(m) == 0 {
		// empty map, all good
		return
	}

	m = make(map[string]any)
	p.vstack[len(p.vstack)-1] = m
}

// pop a variable set from the vstack.
func (p *parser) popV() {
	// if the map is not empty, clear it
	m := p.vstack[len(p.vstack)-1]
	if len(m) > 0 {
		// GC that map
		p.vstack[len(p.vstack)-1] = nil
	}
	p.vstack = p.vstack[:len(p.vstack)-1]
}

// push a recovery expression with its labels to the recoveryStack
func (p *parser) pushRecovery(labels []string, expr any) {
	if cap(p.recoveryStack) == len(p.recoveryStack) {
		// create new empty slot in the stack
		p.recoveryStack = append(p.recoveryStack, nil)
	} else {
		// slice to 1 more
		p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)+1]
	}

	m := make(map[string]any, len(labels))
	for _, fl := range labels {
		m[fl] = expr
	}
	p.recoveryStack[len(p.recoveryStack)-1] = m
}

// pop a recovery expression from the recoveryStack
func (p *parser) popRecovery() {
	// GC that map
	p.recoveryStack[len(p.recoveryStack)-1] = nil

	p.recoveryStack = p.recoveryStack[:len(p.recoveryStack)-1]
}

func (p *parser) addErr(err error) {
	p.addErrAt(err, p.pt.position, []string{})
}

func (p *parser) addErrAt(err error, pos position, expected []string) {
	var buf bytes.Buffer
	if p.filename != "" {
		buf.WriteString(p.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%d:%d (%d)", pos.line, pos.col, pos.offset))
	if len(p.rstack) > 0 {
		if buf.Len() > 0 {
			buf.WriteString(": ")
		}
		rule := p.rstack[len(p.rstack)-1]
		if rule.displayName != "" {
			buf.WriteString("rule " + rule.displayName)
		} else {
			buf.WriteString("rule " + rule.name)
		}
	}
	pe := &parserError{Inner: err, pos: pos, prefix: buf.String(), expected: expected}
	p.errs.add(pe)
}

func (p *parser) failAt(fail bool, pos position, want string) {
	// process fail if parsing fails and not inverted or parsing succeeds and invert is set
	if fail == p.maxFailInvertExpected {
		if pos.offset < p.maxFailPos.offset {
			return
		}

		if pos.offset > p.maxFailPos.offset {
			p.maxFailPos = pos
			p.maxFailExpected = p.maxFailExpected[:0]
		}

		if p.maxFailInvertExpected {
			want = "!" + want
		}
		p.maxFailExpected = append(p.maxFailExpected, want)
	}
}

// read advances the parser to the next rune.
func (p *parser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n
	p.pt.col++
	if rn == '\n' {
		p.pt.line++
		p.pt.col = 0
	}

	if rn == utf8.RuneError && n == 1 { // see utf8.DecodeRune
		if !p.allowInvalidUTF8 {
			p.addErr(errInvalidEncoding)
		}
	}
}

// restore parser position to the savepoint pt.
func (p *parser) restore(pt savepoint) {
	if pt.offset == p.pt.offset {
		return
	}
	p.pt = pt
}

// get the slice of bytes from the savepoint start to the current position.
func (p *parser) sliceFrom(start savepoint) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

func (p *parser) parse(g *grammar) (val any, err error) {
	if len(g.rules) == 0 {
		p.addErr(errNoRule)
		return nil, p.errs.err()
	}

	// TODO : not super critical but this could be generated
	p.rules = g.rules

	if p.recover {
		// panic can be used in action code to stop parsing immediately
		// and return the panic as an error.
		defer func() {
			if e := recover(); e != nil {
				val = nil
				switch e := e.(type) {
				case error:
					p.addErr(e)
				default:
					p.addErr(fmt.Errorf("%v", e))
				}
				err = p.errs.err()
			}
		}()
	}

	var startRule *rule
	for _, r := range p.rules {
		if r.name == p.entrypoint {
			startRule = r
			break
		}
	}
	if startRule == nil {
		p.addErr(errInvalidEntrypoint)
		return nil, p.errs.err()
	}

	p.read() // advance to first rune
	var ok bool
	val, ok = p.parseRuleWrap(startRule)
	if !ok {
		if len(*p.errs) == 0 {
			// If parsing fails, but no errors have been recorded, the expected values
			// for the farthest parser position are returned as error.
			maxFailExpectedMap := make(map[string]struct{}, len(p.maxFailExpected))
			for _, v := range p.maxFailExpected {
				maxFailExpectedMap[v] = struct{}{}
			}
			expected := make([]string, 0, len(maxFailExpectedMap))
			eof := false
			if _, ok := maxFailExpectedMap["!."]; ok {
				delete(maxFailExpectedMap, "!.")
				eof = true
			}
			for k := range maxFailExpectedMap {
				expected = append(expected, k)
			}
			sort.Strings(expected)
			if eof {
				expected = append(expected, "EOF")
			}
			p.addErrAt(errors.New("no match found, expected: "+listJoin(expected, ", ", "or")), p.maxFailPos, expected)
		}

		return nil, p.errs.err()
	}
	return val, p.errs.err()
}

func listJoin(list []string, sep string, lastSep string) string {
	switch len(list) {
	case 0:
		return ""
	case 1:
		return list[0]
	default:
		return strings.Join(list[:len(list)-1], sep) + " " + lastSep + " " + list[len(list)-1]
	}
}

func (p *parser) parseRuleWrap(rule *rule) (any, bool) {
	var (
		val any
		ok  bool
	)

	val, ok = p.parseRule(rule)

	return val, ok
}

func (p *parser) parseRule(rule *rule) (any, bool) {
	p.rstack = append(p.rstack, rule)
	p.pushV()
	val, ok := p.parseExprWrap(rule.expr)
	p.popV()
	p.rstack = p.rstack[:len(p.rstack)-1]
	return val, ok
}

func (p *parser) parseExprWrap(expr any) (any, bool) {
	val, ok := p.parseExpr(expr)

	return val, ok
}

func (p *parser) parseExpr(expr any) (any, bool) {
	p.ExprCnt++
	if p.ExprCnt > p.maxExprCnt {
		panic(errMaxExprCnt)
	}

	var val any
	var ok bool
	switch expr := expr.(type) {
	case *actionExpr:
		val, ok = p.parseActionExpr(expr)
	case *andCodeExpr:
		val, ok = p.parseAndCodeExpr(expr)
	case *andExpr:
		val, ok = p.parseAndExpr(expr)
	case *anyMatcher:
		val, ok = p.parseAnyMatcher(expr)
	case *charClassMatcher:
		val, ok = p.parseCharClassMatcher(expr)
	case *choiceExpr:
		val, ok = p.parseChoiceExpr(expr)
	case *labeledExpr:
		val, ok = p.parseLabeledExpr(expr)
	case *litMatcher:
		val, ok = p.parseLitMatcher(expr)
	case *notCodeExpr:
		val, ok = p.parseNotCodeExpr(expr)
	case *notExpr:
		val, ok = p.parseNotExpr(expr)
	case *oneOrMoreExpr:
		val, ok = p.parseOneOrMoreExpr(expr)
	case *recoveryExpr:
		val, ok = p.parseRecoveryExpr(expr)
	case *ruleRefExpr:
		val, ok = p.parseRuleRefExpr(expr)
	case *seqExpr:
		val, ok = p.parseSeqExpr(expr)
	case *throwExpr:
		val, ok = p.parseThrowExpr(expr)
	case *zeroOrMoreExpr:
		val, ok = p.parseZeroOrMoreExpr(expr)
	case *zeroOrOneExpr:
		val, ok = p.parseZeroOrOneExpr(expr)
	default:
		panic(fmt.Sprintf("unknown expression type %T", expr))
	}
	return val, ok
}

func (p *parser) parseActionExpr(act *actionExpr) (any, bool) {
	start := p.pt
	val, ok := p.parseExprWrap(act.expr)
	if ok {
		p.cur.pos = start.position
		p.cur.text = p.sliceFrom(start)
		actVal, err := act.run(p)
		if err != nil {
			p.addErrAt(err, start.position, []string{})
		}

		val = actVal
	}
	return val, ok
}

func (p *parser) parseAndCodeExpr(and *andCodeExpr) (any, bool) {

	ok, err := and.run(p)
	if err != nil {
		p.addErr(err)
	}

	return nil, ok
}

func (p *parser) parseAndExpr(and *andExpr) (any, bool) {
	pt := p.pt
	p.pushV()
	_, ok := p.parseExprWrap(and.expr)
	p.popV()
	p.restore(pt)

	return nil, ok
}

func (p *parser) parseAnyMatcher(any *anyMatcher) (any, bool) {
	if p.pt.rn == utf8.RuneError && p.pt.w == 0 {
		// EOF - see utf8.DecodeRune
		p.failAt(false, p.pt.position, ".")
		return nil, false
	}
	start := p.pt
	p.read()
	p.failAt(true, start.position, ".")
	return p.sliceFrom(start), true
}

func (p *parser) parseCharClassMatcher(chr *charClassMatcher) (any, bool) {
	cur := p.pt.rn
	start := p.pt

	// can't match EOF
	if cur == utf8.RuneError && p.pt.w == 0 { // see utf8.DecodeRune
		p.failAt(false, start.position, chr.val)
		return nil, false
	}

	if chr.ignoreCase {
		cur = unicode.ToLower(cur)
	}

	// try to match in the list of available chars
	for _, rn := range chr.chars {
		if rn == cur {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(chr.ranges); i += 2 {
		if cur >= chr.ranges[i] && cur <= chr.ranges[i+1] {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range chr.classes {
		if unicode.Is(cl, cur) {
			if chr.inverted {
				p.failAt(false, start.position, chr.val)
				return nil, false
			}
			p.read()
			p.failAt(true, start.position, chr.val)
			return p.sliceFrom(start), true
		}
	}

	if chr.inverted {
		p.read()
		p.failAt(true, start.position, chr.val)
		return p.sliceFrom(start), true
	}
	p.failAt(false, start.position, chr.val)
	return nil, false
}

func (p *parser) parseChoiceExpr(ch *choiceExpr) (any, bool) {

	for altI, alt := range ch.alternatives {
		// dummy assignment to prevent compile error if optimized
		_ = altI

		p.pushV()
		val, ok := p.parseExprWrap(alt)
		p.popV()
		if ok {
			return val, ok
		}
	}
	return nil, false
}

func (p *parser) parseLabeledExpr(lab *labeledExpr) (any, bool) {
	p.pushV()
	val, ok := p.parseExprWrap(lab.expr)
	p.popV()
	if ok && lab.label != "" {
		m := p.vstack[len(p.vstack)-1]
		m[lab.label] = val
	}
	return val, ok
}

func (p *parser) parseLitMatcher(lit *litMatcher) (any, bool) {
	start := p.pt
	for _, want := range lit.val {
		cur := p.pt.rn
		if lit.ignoreCase {
			cur = unicode.ToLower(cur)
		}
		if cur != want {
			p.failAt(false, start.position, lit.want)
			p.restore(start)
			return nil, false
		}
		p.read()
	}
	p.failAt(true, start.position, lit.want)
	return p.sliceFrom(start), true
}

func (p *parser) parseNotCodeExpr(not *notCodeExpr) (any, bool) {
	ok, err := not.run(p)
	if err != nil {
		p.addErr(err)
	}

	return nil, !ok
}

func (p *parser) parseNotExpr(not *notExpr) (any, bool) {
	pt := p.pt
	p.pushV()
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	_, ok := p.parseExprWrap(not.expr)
	p.maxFailInvertExpected = !p.maxFailInvertExpected
	p.popV()
	p.restore(pt)

	return nil, !ok
}

func (p *parser) parseOneOrMoreExpr(expr *oneOrMoreExpr) (any, bool) {
	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			if len(vals) == 0 {
				// did not match once, no match
				return nil, false
			}
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseRecoveryExpr(recover *recoveryExpr) (any, bool) {

	p.pushRecovery(recover.failureLabel, recover.recoverExpr)
	val, ok := p.parseExprWrap(recover.expr)
	p.popRecovery()

	return val, ok
}

func (p *parser) parseRuleRefExpr(ref *ruleRefExpr) (any, bool) {
	if ref.offset > len(p.rules)-1 {
		panic(fmt.Sprintf("%s: invalid rule: out of range", ref.pos))
	}

	rule := p.rules[ref.offset]
	return p.parseRuleWrap(rule)
}

func (p *parser) parseSeqExpr(seq *seqExpr) (any, bool) {
	var vals []any // Alchemy patch: we lazily allocate this array, as it's infrequently populated

	pt := p.pt
	for _, expr := range seq.exprs {
		val, ok := p.parseExprWrap(expr)
		if !ok {
			p.restore(pt)
			return nil, false
		}
		vals = append(vals, val)
	}
	return vals, true
}

func (p *parser) parseThrowExpr(expr *throwExpr) (any, bool) {

	for i := len(p.recoveryStack) - 1; i >= 0; i-- {
		if recoverExpr, ok := p.recoveryStack[i][expr.label]; ok {
			if val, ok := p.parseExprWrap(recoverExpr); ok {
				return val, ok
			}
		}
	}

	return nil, false
}

func (p *parser) parseZeroOrMoreExpr(expr *zeroOrMoreExpr) (any, bool) {
	var vals []any

	for {
		p.pushV()
		val, ok := p.parseExprWrap(expr.expr)
		p.popV()
		if !ok {
			return vals, true
		}
		vals = append(vals, val)
	}
}

func (p *parser) parseZeroOrOneExpr(expr *zeroOrOneExpr) (any, bool) {
	p.pushV()
	val, _ := p.parseExprWrap(expr.expr)
	p.popV()
	// whether it matched or not, consider it a match
	return val, true
}

func rangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}
