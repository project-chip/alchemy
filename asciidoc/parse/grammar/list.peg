

ListItemValue = line:InlineElement+ &EndOfLine lines:(ListItemLine)* attachedBlocks:(AttachedBlocks)?  &EndOfLine {
    value := []any{line}
    if lines != nil {
        value = append(value, lines.([]any)...)
    }
     if attachedBlocks != nil {
        value = append(value, attachedBlocks.([]any))
    }
    return flat(value), nil
}


ListContinuationMarker = newlines:(EmptyLine*) BeginningOfLine "+" {
    debugPosition(c, "ListContinuationMarker\n")
    count := len(newlines.([]any))
    if count > 0 {
        count--
    }
    return count, nil
}

ListContinuation = marker:ListContinuationMarker AnySpaces NewLine value:ContinuationBlockElement {
    debugPosition(c, "ListContinuation\n")
    return compose(c, asciidoc.NewListContinuation(value.(asciidoc.Element), marker.(int)))
}

ListItemLine = EndOfLine !OrderedListMarker !UnorderedListMarker !BlockDelimiters !ConditionalStatement !ListContinuationMarker element:(InlineElement)+ &EndOfLine {
    return append([]any{&asciidoc.NewLine{}}, element.([]any)...), nil
}

AttachedBlocks = blocks:(ListContinuation)+ &EndOfLine {
    return blocks, nil
}


ContinuationBlockElement =  element:(ContinuationBlockElements) &EndOfLine 
&{
    debugPosition(c, "checking continuation block element: %T %v\n", element, element)
    return element != nil, nil
} {
    debugPosition(c, "continuation block element: %T %v\n", element, element)
   return element, nil
}

ContinuationBlockElements = (
    AlchemyEscape /
    AttributableBlocks /
    Table /
    NakedBlocks / els:InlineElements {
            return compose(c, asciidoc.NewParagraph(), setElements[*asciidoc.Paragraph](els.(asciidoc.Elements)))
    })
