{
package conformance

import (
    "fmt"
    "strconv"

    "github.com/hasty/alchemy/matter"
)

}

Input <- conf:Conformance+  {
    cs := conf.([]interface{})

    if len(cs) == 1 {
        return cs[0].(matter.Conformance), nil
    }
    oc := &OtherwiseConformance{}
    for _, i := range cs {
        con := i.(matter.Conformance)
        oc.Conformances = append(oc.Conformances, con)
    }
    return oc, nil
}

Conformance <- '[' i:Equality ']' choice:Choice? _ Comma? _ {
    exp := i.(ConformanceExpression)
    o := &OptionalConformance{Expression:exp}
    if choice != nil {
        o.Choice = choice.(*Choice)
    }
    return o, nil   
} / 'M'  _ Comma? _ {
    return &MandatoryConformance{}, nil
} / 'O' choice:Choice?  _ Comma? _ {
    o := &OptionalConformance{}
    if choice != nil {
        o.Choice = choice.(*Choice)
    }
    return o, nil
} / 'P'  _ Comma? _ {
    return &ProvisionalConformance{}, nil
} / 'D'  _ Comma? _ {
    return &DeprecatedConformance{}, nil
} / 'X'  _ Comma? _ {
    return &DisallowedConformance{}, nil
} / eq:Equality _ Comma? _ {
    exp := eq.(ConformanceExpression)
    return &MandatoryConformance{Expression:exp}, nil
}

Equality <- _ left:Logical right:EqualsOp* _ {
    if right == nil {
        return left, nil
    }
    equalityOps := right.([]interface{}) 
    if len(equalityOps) == 0 {
        return left, nil
    }
    leftCE := left.(ConformanceExpression)
    var ee *EqualityExpression
    for _, equalityOp := range equalityOps {
        ee = equalityOp.(*EqualityExpression) 
        ee.Left = leftCE
        leftCE = ee
    }
    return ee, nil
}

Logical <- _ left:FeatureTerm _ right:LogicalOp* _ {
    if right == nil {
        return left, nil
    }
    logicalOps := right.([]interface{})
    if len(logicalOps) == 0 {
        return left, nil
    }
    leftCE := left.(ConformanceExpression)
    var le *LogicalExpression
    for _, logicalOp := range logicalOps {
        le = logicalOp.(*LogicalExpression) 
        le.Left = leftCE
        leftCE = le
    }
    return le, nil
} 

LogicalOperators <- ("|" / "&" / "^") {
    return c.text, nil
}

LogicalOp <- _ logical:LogicalOperators _ f:FeatureTerm {
    fc := f.(ConformanceExpression)
    return &LogicalExpression{
        Operand: string(logical.([]uint8)),
        Right:fc,
    }, nil
}

EqualsOp <- _ equals:("=="/"!=") _ f:Logical {
    fc := f.(ConformanceExpression)
    return &EqualityExpression{
        Not: (string(equals.([]uint8)) == "!="),
        Right:fc,
    }, nil
}

FeatureTerm <- '(' _  eq:Equality _ ')' {
    return eq, nil
} / feature:IdentifierOp {
    return feature, nil 
}

IdentifierOp <- not:'!'? identifier:Identifier {
    id := identifier.(string)
    switch id {
        case "O", "M", "P":
            return nil, fmt.Errorf("invalid optional conformance value: %s", id)
    }
    ic := &IdentifierExpression{ID:id}
    if not != nil {
        ic.Not = true
    }
    return ic, nil
}

Identifier <- [A-Z]+ {
    return string(c.text), nil
}

ChoiceRange <- lower:Integer '-' upper:Integer {
    minVal := lower.(int)
    if minVal <= 0 {
        return nil, fmt.Errorf("invalid minimum: %d", minVal)
    } 
    maxVal := upper.(int)
    if maxVal <= 0  && minVal > maxVal {
        return nil, fmt.Errorf("invalid maximum: %d", maxVal)
    } 
    return &ChoiceRangeLimit{Min:minVal, Max:maxVal}, nil
}

ChoiceMin <- limit:Integer? '+' {
    if limit == nil {
        return &ChoiceMinLimit{Min:1}, nil
    }
    minVal := limit.(int)
    if minVal <= 0 {
        return nil, fmt.Errorf("invalid minimum: %d", minVal)
    }    
    return &ChoiceMinLimit{Min:minVal}, nil
}

ChoiceMax <- limit:Integer? '-' {
     if limit == nil {
        return &ChoiceMaxLimit{Max:1}, nil
    }
    maxVal := limit.(int)
    if maxVal <= 0 {
        return nil, fmt.Errorf("invalid maximum: %d", maxVal)
    } 
    return &ChoiceMaxLimit{Max:maxVal}, nil
}

ChoiceExact <- limit:Integer {
    exact := limit.(int)
    if exact <= 0 {
        return nil, fmt.Errorf("invalid exact: %d", exact)
    } 
    return &ChoiceExactLimit{Limit:exact}, nil
}

ChoiceLimit <- limit:(ChoiceRange / ChoiceMin / ChoiceMax / ChoiceExact) {
    return limit.(ChoiceLimit), nil
}

Set <- [a-z]+ {
    return string(c.text), nil
}

Choice <- '.' set:Set limit:ChoiceLimit? {
    choice := &Choice{Set:set.(string)}
    if limit != nil {
        switch v := limit.(type) {
            case ChoiceLimit:
            choice.Limit = v
            default:
            return nil, fmt.Errorf("unexpected choice limit type: %T", limit)
        }
    }
    return choice, nil
}

Integer <- ([0-9]+) {
        return strconv.Atoi(string(c.text))
    }

_ "whitespace" ← [ \t\r\n]*

Comma <- ',' 

EOF ← !.