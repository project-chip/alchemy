{
package conformance

import (
    "fmt"
    "strconv"

    "github.com/hasty/alchemy/matter"
)

func debug(format string, a ...any) (n int, err error) {
	return
	return fmt.Fprintf(os.Stdout, format, a...)
}


}

Input <- conf:Conformance+ EOF {
    cs := conf.([]interface{})

    var set ConformanceSet
    for _, i := range cs {
        con := i.(matter.Conformance)
        set = append(set, con)
    }
    return set, nil
}

Conformance <- '[' i:Equality ']' choice:Choice? _ Comma? _ {
    exp := i.(ConformanceExpression)
    o := &OptionalConformance{Expression:exp}
    if choice != nil {
        o.Choice = choice.(*Choice)
    }
    return o, nil   
} / eq:Equality _ Comma? _ {
    exp := eq.(ConformanceExpression)
    return &MandatoryConformance{Expression:exp}, nil
} / 'M'  _ Comma? _ {
    return &MandatoryConformance{}, nil
} / 'O' choice:Choice?  _ Comma? _ {
    o := &OptionalConformance{}
    if choice != nil {
        o.Choice = choice.(*Choice)
    }
    return o, nil
} / 'P'  _ Comma? _ {
    return &ProvisionalConformance{}, nil
} / 'D'  _ Comma? _ {
    return &DeprecatedConformance{}, nil
} / 'X'  _ Comma? _ {
    return &DisallowedConformance{}, nil
} / "desc"  _ Comma? _ { 
     return &DescribedConformance{}, nil

}

Equality <- _ left:Logical right:EqualsOp* _ {
    if right == nil {
        return left, nil
    }
    equalityOps := right.([]interface{}) 
    if len(equalityOps) == 0 {
        return left, nil
    }
    leftCE := left.(ConformanceExpression)
    var ee *EqualityExpression
    for _, equalityOp := range equalityOps {
        ee = equalityOp.(*EqualityExpression) 
        ee.Left = leftCE
        leftCE = ee
    }
    return ee, nil
}

EqualsOp <- _ equals:("=="/"!=") _ f:Logical {
    fc := f.(ConformanceExpression)
    return &EqualityExpression{
        Not: (string(equals.([]uint8)) == "!="),
        Right:fc,
    }, nil
}

Logical <- _ left:FeatureTerm _ right:LogicalOp* _ {
    if right == nil {
        return left, nil
    }
    logicalOps := right.([]interface{})
    if len(logicalOps) == 0 {
        return left, nil
    }
    leftCE := left.(ConformanceExpression)
    var le *LogicalExpression
    for _, logicalOp := range logicalOps {
        le = logicalOp.(*LogicalExpression) 
        le.Left = leftCE
        leftCE = le
    }
    return le, nil
} 

LogicalOp <- _ logical:LogicalOperators _ f:FeatureTerm {
    fc := f.(ConformanceExpression)
    return &LogicalExpression{
        Operand: string(logical.([]uint8)),
        Right:fc,
    }, nil
}

LogicalOperators <- ("|" / "&" / "^") {
    return c.text, nil
}

FeatureTerm <- not:'!'? '(' _  eq:Equality _ ')' {
    if not != nil {
        switch eq := eq.(type) {
            case *EqualityExpression:
                eq.Not = true
            case *LogicalExpression:
                eq.Not = true
        }
    }
    return eq, nil
} / feature:FeatureOp {
    return feature, nil 
} / identifier:IdentifierOp {
    return identifier, nil 
}


FeatureOp <- not:'!'? feature:Feature {
    id := feature.(string)
    switch id {
        case "O", "M", "P":
            return nil, fmt.Errorf("invalid optional conformance value: %s", id)
    }
    ic := &FeatureExpression{ID:id}
    if not != nil {
        ic.Not = true
    }
    return ic, nil
}


Feature <- [A-Z][A-Z0-9_]+ {
    return string(c.text), nil
}

IdentifierOp <- not:'!'? identifier:Identifier {
    id := identifier.(string)
    ic := &IdentifierExpression{ID:id}
    if not != nil {
        ic.Not = true
    }
    return ic, nil
}


Identifier <- ([A-Z]+[a-z]+)+ {
    debug("matched identifier %s", string(c.text))
    return string(c.text), nil
}

ChoiceRange <- lower:Integer '-' upper:Integer {
    minVal := lower.(int)
    if minVal <= 0 {
        return nil, fmt.Errorf("invalid minimum: %d", minVal)
    } 
    maxVal := upper.(int)
    if maxVal <= 0  && minVal > maxVal {
        return nil, fmt.Errorf("invalid maximum: %d", maxVal)
    } 
    return &ChoiceRangeLimit{Min:minVal, Max:maxVal}, nil
}

ChoiceMin <- limit:Integer? '+' {
    if limit == nil {
        return &ChoiceMinLimit{Min:1}, nil
    }
    minVal := limit.(int)
    if minVal <= 0 {
        return nil, fmt.Errorf("invalid minimum: %d", minVal)
    }    
    return &ChoiceMinLimit{Min:minVal}, nil
}

ChoiceMax <- limit:Integer? '-' {
     if limit == nil {
        return &ChoiceMaxLimit{Max:1}, nil
    }
    maxVal := limit.(int)
    if maxVal <= 0 {
        return nil, fmt.Errorf("invalid maximum: %d", maxVal)
    } 
    return &ChoiceMaxLimit{Max:maxVal}, nil
}

ChoiceExact <- limit:Integer {
    exact := limit.(int)
    if exact <= 0 {
        return nil, fmt.Errorf("invalid exact: %d", exact)
    } 
    return &ChoiceExactLimit{Limit:exact}, nil
}

ChoiceLimit <- limit:(ChoiceRange / ChoiceMin / ChoiceMax / ChoiceExact) {
    return limit.(ChoiceLimit), nil
}

Set <- [a-z]+ {
    return string(c.text), nil
}

Choice <- '.' set:Set limit:ChoiceLimit? {
    choice := &Choice{Set:set.(string)}
    if limit != nil {
        switch v := limit.(type) {
            case ChoiceLimit:
            choice.Limit = v
            default:
            return nil, fmt.Errorf("unexpected choice limit type: %T", limit)
        }
    }
    return choice, nil
}

Integer <- ([0-9]+) {
        return strconv.Atoi(string(c.text))
    }

_ "whitespace" ← [ \t\r\n]*

Comma <- ',' 

EOF ← !.