package generate

import (
	"bytes"
	"fmt"
	"log/slog"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"text/template"
	"time"

	"github.com/beevik/etree"
	"github.com/project-chip/alchemy/asciidoc"
	"github.com/project-chip/alchemy/zap"
)

func (tg *configuratorRenderer) patchComments(configurator *zap.Configurator, x *etree.Document) {
	var alchemyComment *etree.Comment
	var copyrightComment *etree.Comment
	var lastProcInst *etree.ProcInst
	for _, e := range x.Child {
		switch e := e.(type) {
		case *etree.ProcInst:
			lastProcInst = e
		case *etree.Comment:
			if strings.Contains(e.Data, "Copyright") {
				copyrightComment = e
			} else if strings.Contains(e.Data, "generated by Alchemy") {
				alchemyComment = e
			}
		}
	}
	copyrightComment = tg.patchCopyright(configurator, x, lastProcInst, copyrightComment)
	tg.patchAlchemyComment(configurator, x, alchemyComment, copyrightComment)
}

var licenseDatePattern = regexp.MustCompile(`Copyright(?:\s+\(c\))?\s+(?P<Date>(?P<Start>[0-9]+)(\s*-\s*(?P<End>[0-9]+))?)`)
var licenseDatePatternDateStartIndex = 2
var licenseDatePatternDateEndIndex = 3
var licenseDatePatternStartYearStartIndex = 4
var licenseDatePatternStartYearEndIndex = 5
var licenseDatePatternEndYearStartIndex = 6
var licenseDatePatternEndYearEndIndex = 7

func (tg *configuratorRenderer) patchCopyright(configurator *zap.Configurator, x *etree.Document, lastProcInst *etree.ProcInst, copyrightComment *etree.Comment) *etree.Comment {
	if copyrightComment == nil {
		copyrightComment = etree.NewComment(fmt.Sprintf(license, time.Now().Year()))
		if lastProcInst != nil {
			x.InsertChildAt(lastProcInst.Index()+1, copyrightComment)
		} else {
			x.InsertChildAt(0, copyrightComment)
		}
		return copyrightComment
	}
	comment := copyrightComment.Data
	locations := licenseDatePattern.FindStringSubmatchIndex(copyrightComment.Data)
	if locations == nil {
		return copyrightComment
	}
	var startYear, endYear int
	var err error
	startYear, err = strconv.Atoi(comment[locations[licenseDatePatternStartYearStartIndex]:locations[licenseDatePatternStartYearEndIndex]])
	if err != nil {
		slog.Warn("Could not read copyright start date", slog.String("path", configurator.OutPath))
		return copyrightComment
	}
	if locations[6] != -1 {
		endYear, err = strconv.Atoi(comment[locations[licenseDatePatternEndYearStartIndex]:locations[licenseDatePatternEndYearEndIndex]])
		if err != nil {
			slog.Warn("Could not read copyright end date", slog.String("path", configurator.OutPath))
			return copyrightComment
		}
	}
	currentYear := time.Now().Year()

	if endYear != 0 {
		if endYear == currentYear {
			return copyrightComment
		}
	} else if startYear == currentYear {
		return copyrightComment
	}
	var sb strings.Builder
	sb.WriteString(comment[0:locations[licenseDatePatternDateStartIndex]])
	sb.WriteString(fmt.Sprintf("%d-%d", startYear, currentYear))
	sb.WriteString(comment[locations[licenseDatePatternDateEndIndex]:])
	copyrightComment.Data = sb.String()
	return copyrightComment
}

var alchemyCommentTemplate *template.Template
var alchemyComment = `
XML generated by Alchemy; DO NOT EDIT.
Source: {{.Path}}
Parameters: {{range .Parameters}}{{.}} {{end}}
Git: {{.Git}}
`

var initAlchemyTemplate = sync.OnceFunc(func() {
	alchemyCommentTemplate = template.Must(template.New("alchemyComment").Parse(alchemyComment))
})

func (tg *configuratorRenderer) patchAlchemyComment(configurator *zap.Configurator, x *etree.Document, alchemyComment *etree.Comment, copyrightComment *etree.Comment) {
	initAlchemyTemplate()
	var alchemyCommentText bytes.Buffer
	var paths []string
	for _, d := range configurator.Docs {
		paths = append(paths, d.Path.Relative)
	}
	alchemyCommentTemplate.Execute(&alchemyCommentText, struct {
		Path       string
		Parameters []asciidoc.AttributeName
		Git        string
	}{
		Path:       strings.Join(paths, " "),
		Parameters: tg.generator.attributes,
		Git:        tg.generator.specVersion})
	if alchemyComment != nil {
		alchemyComment.Data = alchemyCommentText.String()
	} else {
		alchemyComment = etree.NewComment(alchemyCommentText.String())
		x.InsertChildAt(copyrightComment.Index()+1, alchemyComment)
	}
}

func gitDescribe(specRoot string) (string, error) {
	cmd := exec.Command("git", "describe", "--dirty", "--broken", "--tags")
	cmd.Dir = specRoot
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}
